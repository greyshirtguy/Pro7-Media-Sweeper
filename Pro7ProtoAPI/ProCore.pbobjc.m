// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proCore.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "ProCore.pbobjc.h"
#import "Effects.pbobjc.h"
#import "Action.pbobjc.h"
#import "GraphicsData.pbobjc.h"
#import "Input.pbobjc.h"
#import "Recording.pbobjc.h"
#import "BasicTypes.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AudioInput);
GPBObjCClassDeclaration(ControlTransport);
GPBObjCClassDeclaration(ControlTransport_BeginScrubControlType);
GPBObjCClassDeclaration(ControlTransport_EndScrubControlType);
GPBObjCClassDeclaration(ControlTransport_FastForwardControlType);
GPBObjCClassDeclaration(ControlTransport_GoToEndControlType);
GPBObjCClassDeclaration(ControlTransport_GoToStartControlType);
GPBObjCClassDeclaration(ControlTransport_JumpToPercentControlType);
GPBObjCClassDeclaration(ControlTransport_JumpToTimeControlType);
GPBObjCClassDeclaration(ControlTransport_MarkInPointControlType);
GPBObjCClassDeclaration(ControlTransport_MarkOutPointControlType);
GPBObjCClassDeclaration(ControlTransport_PauseControlType);
GPBObjCClassDeclaration(ControlTransport_PlayControlType);
GPBObjCClassDeclaration(ControlTransport_RewindControlType);
GPBObjCClassDeclaration(ControlTransport_ScrubToPercentControlType);
GPBObjCClassDeclaration(ControlTransport_ScrubToTimeControlType);
GPBObjCClassDeclaration(ControlTransport_SetAudioFadeType);
GPBObjCClassDeclaration(ControlTransport_SetAudioPropertiesType);
GPBObjCClassDeclaration(ControlTransport_SetEffectsControlType);
GPBObjCClassDeclaration(ControlTransport_SetFlippedModeControlType);
GPBObjCClassDeclaration(ControlTransport_SetNativeRotationControlType);
GPBObjCClassDeclaration(ControlTransport_SetPlayRateControlType);
GPBObjCClassDeclaration(ControlTransport_SetScaleModeControlType);
GPBObjCClassDeclaration(ControlTransport_SkipBackControlType);
GPBObjCClassDeclaration(ControlTransport_SkipForwardControlType);
GPBObjCClassDeclaration(ControlTransport_StepBackControlType);
GPBObjCClassDeclaration(ControlTransport_StepForwardControlType);
GPBObjCClassDeclaration(ControlTransport_TogglePlaybackControlType);
GPBObjCClassDeclaration(ControlTransport_UpdateEffectControlType);
GPBObjCClassDeclaration(Effect);
GPBObjCClassDeclaration(Graphics_EdgeInsets);
GPBObjCClassDeclaration(MediaMetadataRequestResponse);
GPBObjCClassDeclaration(MediaMetadataRequestResponse_BitmapInfo);
GPBObjCClassDeclaration(MediaMetadataRequestResponse_Metadata);
GPBObjCClassDeclaration(Media_AudioProperties);
GPBObjCClassDeclaration(RecordRequest);
GPBObjCClassDeclaration(RecordRequest_Resi);
GPBObjCClassDeclaration(Recording_Stream);
GPBObjCClassDeclaration(TextSegmentRequest);
GPBObjCClassDeclaration(TextSegmentRequest_Segment);
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(VideoInput);

#pragma mark - ProCoreRoot

@implementation ProCoreRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ProCoreRoot_FileDescriptor

static GPBFileDescriptor *ProCoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MediaMetadataRequestInfo

@implementation MediaMetadataRequestInfo

@dynamic filePath;
@dynamic time;
@dynamic width;
@dynamic height;
@dynamic effectsArray, effectsArray_Count;
@dynamic hasCropInsets, cropInsets;
@dynamic nativeRotation;
@dynamic flippedHorizontally;
@dynamic flippedVertically;

typedef struct MediaMetadataRequestInfo__storage_ {
  uint32_t _has_storage_[1];
  float time;
  uint32_t width;
  uint32_t height;
  MediaMetadataRequestInfo_NativeRotationType nativeRotation;
  NSString *filePath;
  NSMutableArray *effectsArray;
  Graphics_EdgeInsets *cropInsets;
} MediaMetadataRequestInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filePath",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_FilePath,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, filePath),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "effectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = MediaMetadataRequestInfo_FieldNumber_EffectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, effectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cropInsets",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_EdgeInsets),
        .number = MediaMetadataRequestInfo_FieldNumber_CropInsets,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, cropInsets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nativeRotation",
        .dataTypeSpecific.enumDescFunc = MediaMetadataRequestInfo_NativeRotationType_EnumDescriptor,
        .number = MediaMetadataRequestInfo_FieldNumber_NativeRotation,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MediaMetadataRequestInfo__storage_, nativeRotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "flippedHorizontally",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_FlippedHorizontally,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flippedVertically",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestInfo_FieldNumber_FlippedVertically,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaMetadataRequestInfo class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaMetadataRequestInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MediaMetadataRequestInfo_NativeRotation_RawValue(MediaMetadataRequestInfo *message) {
  GPBDescriptor *descriptor = [MediaMetadataRequestInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMetadataRequestInfo_FieldNumber_NativeRotation];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMediaMetadataRequestInfo_NativeRotation_RawValue(MediaMetadataRequestInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaMetadataRequestInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMetadataRequestInfo_FieldNumber_NativeRotation];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum MediaMetadataRequestInfo_NativeRotationType

GPBEnumDescriptor *MediaMetadataRequestInfo_NativeRotationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NativeRotationTypeRotateStandard\000NativeR"
        "otationTypeRotate90\000NativeRotationTypeRo"
        "tate180\000NativeRotationTypeRotate270\000";
    static const int32_t values[] = {
        MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotateStandard,
        MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate90,
        MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate180,
        MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate270,
    };
    static const char *extraTextFormatInfo = "\003\001f\350\344\346\202\000\002f\350\344\346\203\000\003f\350\344\346\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaMetadataRequestInfo_NativeRotationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaMetadataRequestInfo_NativeRotationType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaMetadataRequestInfo_NativeRotationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotateStandard:
    case MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate90:
    case MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate180:
    case MediaMetadataRequestInfo_NativeRotationType_NativeRotationTypeRotate270:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MediaMetadataRequestResponse

@implementation MediaMetadataRequestResponse

@dynamic hasMetadata, metadata;
@dynamic hasGeneratedBitmapInfo, generatedBitmapInfo;

typedef struct MediaMetadataRequestResponse__storage_ {
  uint32_t _has_storage_[1];
  MediaMetadataRequestResponse_Metadata *metadata;
  MediaMetadataRequestResponse_BitmapInfo *generatedBitmapInfo;
} MediaMetadataRequestResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(MediaMetadataRequestResponse_Metadata),
        .number = MediaMetadataRequestResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "generatedBitmapInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(MediaMetadataRequestResponse_BitmapInfo),
        .number = MediaMetadataRequestResponse_FieldNumber_GeneratedBitmapInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse__storage_, generatedBitmapInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaMetadataRequestResponse class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaMetadataRequestResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MediaMetadataRequestResponse_Metadata

@implementation MediaMetadataRequestResponse_Metadata

@dynamic width;
@dynamic height;
@dynamic fps;
@dynamic duration;
@dynamic numberAudioChannels;
@dynamic codec;
@dynamic artist;
@dynamic title;
@dynamic rotation;
@dynamic contentType;

typedef struct MediaMetadataRequestResponse_Metadata__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
  float fps;
  float duration;
  uint32_t numberAudioChannels;
  float rotation;
  MediaMetadataRequestResponse_Metadata_ContentType contentType;
  NSString *codec;
  NSString *artist;
  NSString *title;
} MediaMetadataRequestResponse_Metadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fps",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Fps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, fps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Duration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "numberAudioChannels",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_NumberAudioChannels,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, numberAudioChannels),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "codec",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Codec,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, codec),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "artist",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Artist,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, artist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Title,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rotation",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_Rotation,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, rotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.enumDescFunc = MediaMetadataRequestResponse_Metadata_ContentType_EnumDescriptor,
        .number = MediaMetadataRequestResponse_Metadata_FieldNumber_ContentType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_Metadata__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaMetadataRequestResponse_Metadata class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaMetadataRequestResponse_Metadata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(MediaMetadataRequestResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MediaMetadataRequestResponse_Metadata_ContentType_RawValue(MediaMetadataRequestResponse_Metadata *message) {
  GPBDescriptor *descriptor = [MediaMetadataRequestResponse_Metadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMetadataRequestResponse_Metadata_FieldNumber_ContentType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMediaMetadataRequestResponse_Metadata_ContentType_RawValue(MediaMetadataRequestResponse_Metadata *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaMetadataRequestResponse_Metadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMetadataRequestResponse_Metadata_FieldNumber_ContentType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum MediaMetadataRequestResponse_Metadata_ContentType

GPBEnumDescriptor *MediaMetadataRequestResponse_Metadata_ContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentTypeUnknown\000ContentTypeAudio\000Cont"
        "entTypeImage\000ContentTypeVideo\000";
    static const int32_t values[] = {
        MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeUnknown,
        MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeAudio,
        MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeImage,
        MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeVideo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaMetadataRequestResponse_Metadata_ContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaMetadataRequestResponse_Metadata_ContentType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaMetadataRequestResponse_Metadata_ContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeUnknown:
    case MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeAudio:
    case MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeImage:
    case MediaMetadataRequestResponse_Metadata_ContentType_ContentTypeVideo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MediaMetadataRequestResponse_BitmapInfo

@implementation MediaMetadataRequestResponse_BitmapInfo

@dynamic width;
@dynamic height;

typedef struct MediaMetadataRequestResponse_BitmapInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
} MediaMetadataRequestResponse_BitmapInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_BitmapInfo_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_BitmapInfo__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMetadataRequestResponse_BitmapInfo_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaMetadataRequestResponse_BitmapInfo__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaMetadataRequestResponse_BitmapInfo class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaMetadataRequestResponse_BitmapInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(MediaMetadataRequestResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TriggerOptions

@implementation TriggerOptions

@dynamic contentDestination;
@dynamic suppressAutoStartVideo;
@dynamic suppressMediaBackground;
@dynamic forceRetrigger;
@dynamic resetChordChart;
@dynamic fromPlaylistLibrary;
@dynamic fromTimeline;
@dynamic ignoreAnalytics;

typedef struct TriggerOptions__storage_ {
  uint32_t _has_storage_[1];
  TriggerOptions_ContentDestination contentDestination;
} TriggerOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentDestination",
        .dataTypeSpecific.enumDescFunc = TriggerOptions_ContentDestination_EnumDescriptor,
        .number = TriggerOptions_FieldNumber_ContentDestination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TriggerOptions__storage_, contentDestination),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "suppressAutoStartVideo",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_SuppressAutoStartVideo,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "suppressMediaBackground",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_SuppressMediaBackground,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "forceRetrigger",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_ForceRetrigger,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "resetChordChart",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_ResetChordChart,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fromPlaylistLibrary",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_FromPlaylistLibrary,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fromTimeline",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_FromTimeline,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ignoreAnalytics",
        .dataTypeSpecific.clazz = Nil,
        .number = TriggerOptions_FieldNumber_IgnoreAnalytics,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TriggerOptions class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TriggerOptions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\026\000\003\027\000\004\016\000\005\017\000\006\023\000\007\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TriggerOptions_ContentDestination_RawValue(TriggerOptions *message) {
  GPBDescriptor *descriptor = [TriggerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TriggerOptions_FieldNumber_ContentDestination];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTriggerOptions_ContentDestination_RawValue(TriggerOptions *message, int32_t value) {
  GPBDescriptor *descriptor = [TriggerOptions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TriggerOptions_FieldNumber_ContentDestination];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum TriggerOptions_ContentDestination

GPBEnumDescriptor *TriggerOptions_ContentDestination_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentDestinationGlobal\000ContentDestinat"
        "ionAnnouncements\000";
    static const int32_t values[] = {
        TriggerOptions_ContentDestination_ContentDestinationGlobal,
        TriggerOptions_ContentDestination_ContentDestinationAnnouncements,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TriggerOptions_ContentDestination)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TriggerOptions_ContentDestination_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TriggerOptions_ContentDestination_IsValidValue(int32_t value__) {
  switch (value__) {
    case TriggerOptions_ContentDestination_ContentDestinationGlobal:
    case TriggerOptions_ContentDestination_ContentDestinationAnnouncements:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ControlTransport

@implementation ControlTransport

@dynamic controlTypeOneOfCase;
@dynamic play;
@dynamic pause;
@dynamic rewind;
@dynamic fastforward;
@dynamic skipBack;
@dynamic skipForward;
@dynamic stepBack;
@dynamic stepForward;
@dynamic goToStart;
@dynamic goToEnd;
@dynamic jumpToTime;
@dynamic jumpToPercent;
@dynamic markIn;
@dynamic markOut;
@dynamic setScaleMode;
@dynamic setFlippedMode;
@dynamic setPlayRate;
@dynamic setRotation;
@dynamic togglePlayback;
@dynamic setEffects;
@dynamic updateEffect;
@dynamic beginScrub;
@dynamic endScrub;
@dynamic scrubToTime;
@dynamic scrubToPercent;
@dynamic setAudioFade;
@dynamic setAudioProperties;

typedef struct ControlTransport__storage_ {
  uint32_t _has_storage_[2];
  ControlTransport_PlayControlType *play;
  ControlTransport_PauseControlType *pause;
  ControlTransport_RewindControlType *rewind;
  ControlTransport_FastForwardControlType *fastforward;
  ControlTransport_SkipBackControlType *skipBack;
  ControlTransport_SkipForwardControlType *skipForward;
  ControlTransport_StepBackControlType *stepBack;
  ControlTransport_StepForwardControlType *stepForward;
  ControlTransport_GoToStartControlType *goToStart;
  ControlTransport_GoToEndControlType *goToEnd;
  ControlTransport_JumpToTimeControlType *jumpToTime;
  ControlTransport_JumpToPercentControlType *jumpToPercent;
  ControlTransport_MarkInPointControlType *markIn;
  ControlTransport_MarkOutPointControlType *markOut;
  ControlTransport_SetScaleModeControlType *setScaleMode;
  ControlTransport_SetFlippedModeControlType *setFlippedMode;
  ControlTransport_SetPlayRateControlType *setPlayRate;
  ControlTransport_SetNativeRotationControlType *setRotation;
  ControlTransport_TogglePlaybackControlType *togglePlayback;
  ControlTransport_SetEffectsControlType *setEffects;
  ControlTransport_UpdateEffectControlType *updateEffect;
  ControlTransport_BeginScrubControlType *beginScrub;
  ControlTransport_EndScrubControlType *endScrub;
  ControlTransport_ScrubToTimeControlType *scrubToTime;
  ControlTransport_ScrubToPercentControlType *scrubToPercent;
  ControlTransport_SetAudioFadeType *setAudioFade;
  ControlTransport_SetAudioPropertiesType *setAudioProperties;
} ControlTransport__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "play",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_PlayControlType),
        .number = ControlTransport_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pause",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_PauseControlType),
        .number = ControlTransport_FieldNumber_Pause,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, pause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rewind",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_RewindControlType),
        .number = ControlTransport_FieldNumber_Rewind,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, rewind),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fastforward",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_FastForwardControlType),
        .number = ControlTransport_FieldNumber_Fastforward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, fastforward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skipBack",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SkipBackControlType),
        .number = ControlTransport_FieldNumber_SkipBack,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, skipBack),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skipForward",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SkipForwardControlType),
        .number = ControlTransport_FieldNumber_SkipForward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, skipForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stepBack",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_StepBackControlType),
        .number = ControlTransport_FieldNumber_StepBack,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, stepBack),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stepForward",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_StepForwardControlType),
        .number = ControlTransport_FieldNumber_StepForward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, stepForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goToStart",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_GoToStartControlType),
        .number = ControlTransport_FieldNumber_GoToStart,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, goToStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goToEnd",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_GoToEndControlType),
        .number = ControlTransport_FieldNumber_GoToEnd,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, goToEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jumpToTime",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_JumpToTimeControlType),
        .number = ControlTransport_FieldNumber_JumpToTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, jumpToTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jumpToPercent",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_JumpToPercentControlType),
        .number = ControlTransport_FieldNumber_JumpToPercent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, jumpToPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "markIn",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_MarkInPointControlType),
        .number = ControlTransport_FieldNumber_MarkIn,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, markIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "markOut",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_MarkOutPointControlType),
        .number = ControlTransport_FieldNumber_MarkOut,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, markOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setScaleMode",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetScaleModeControlType),
        .number = ControlTransport_FieldNumber_SetScaleMode,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setScaleMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setFlippedMode",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetFlippedModeControlType),
        .number = ControlTransport_FieldNumber_SetFlippedMode,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setFlippedMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setPlayRate",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetPlayRateControlType),
        .number = ControlTransport_FieldNumber_SetPlayRate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setPlayRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setRotation",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetNativeRotationControlType),
        .number = ControlTransport_FieldNumber_SetRotation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setRotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "togglePlayback",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_TogglePlaybackControlType),
        .number = ControlTransport_FieldNumber_TogglePlayback,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, togglePlayback),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setEffects",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetEffectsControlType),
        .number = ControlTransport_FieldNumber_SetEffects,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setEffects),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateEffect",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_UpdateEffectControlType),
        .number = ControlTransport_FieldNumber_UpdateEffect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, updateEffect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "beginScrub",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_BeginScrubControlType),
        .number = ControlTransport_FieldNumber_BeginScrub,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, beginScrub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endScrub",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_EndScrubControlType),
        .number = ControlTransport_FieldNumber_EndScrub,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, endScrub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scrubToTime",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_ScrubToTimeControlType),
        .number = ControlTransport_FieldNumber_ScrubToTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, scrubToTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scrubToPercent",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_ScrubToPercentControlType),
        .number = ControlTransport_FieldNumber_ScrubToPercent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, scrubToPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAudioFade",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetAudioFadeType),
        .number = ControlTransport_FieldNumber_SetAudioFade,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setAudioFade),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAudioProperties",
        .dataTypeSpecific.clazz = GPBObjCClass(ControlTransport_SetAudioPropertiesType),
        .number = ControlTransport_FieldNumber_SetAudioProperties,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlTransport__storage_, setAudioProperties),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "controlType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ControlTransport_ClearControlTypeOneOfCase(ControlTransport *message) {
  GPBDescriptor *descriptor = [ControlTransport descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ControlTransport_PlayControlType

@implementation ControlTransport_PlayControlType


typedef struct ControlTransport_PlayControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_PlayControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_PlayControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_PlayControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_PauseControlType

@implementation ControlTransport_PauseControlType


typedef struct ControlTransport_PauseControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_PauseControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_PauseControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_PauseControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_RewindControlType

@implementation ControlTransport_RewindControlType


typedef struct ControlTransport_RewindControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_RewindControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_RewindControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_RewindControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_FastForwardControlType

@implementation ControlTransport_FastForwardControlType


typedef struct ControlTransport_FastForwardControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_FastForwardControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_FastForwardControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_FastForwardControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SkipBackControlType

@implementation ControlTransport_SkipBackControlType

@dynamic offset;

typedef struct ControlTransport_SkipBackControlType__storage_ {
  uint32_t _has_storage_[1];
  double offset;
} ControlTransport_SkipBackControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SkipBackControlType_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SkipBackControlType__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SkipBackControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SkipBackControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SkipForwardControlType

@implementation ControlTransport_SkipForwardControlType

@dynamic offset;

typedef struct ControlTransport_SkipForwardControlType__storage_ {
  uint32_t _has_storage_[1];
  double offset;
} ControlTransport_SkipForwardControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SkipForwardControlType_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SkipForwardControlType__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SkipForwardControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SkipForwardControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_StepBackControlType

@implementation ControlTransport_StepBackControlType


typedef struct ControlTransport_StepBackControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_StepBackControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_StepBackControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_StepBackControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_StepForwardControlType

@implementation ControlTransport_StepForwardControlType


typedef struct ControlTransport_StepForwardControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_StepForwardControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_StepForwardControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_StepForwardControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_GoToStartControlType

@implementation ControlTransport_GoToStartControlType

@dynamic offset;

typedef struct ControlTransport_GoToStartControlType__storage_ {
  uint32_t _has_storage_[1];
  double offset;
} ControlTransport_GoToStartControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_GoToStartControlType_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_GoToStartControlType__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_GoToStartControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_GoToStartControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_GoToEndControlType

@implementation ControlTransport_GoToEndControlType

@dynamic offset;

typedef struct ControlTransport_GoToEndControlType__storage_ {
  uint32_t _has_storage_[1];
  double offset;
} ControlTransport_GoToEndControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_GoToEndControlType_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_GoToEndControlType__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_GoToEndControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_GoToEndControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_JumpToTimeControlType

@implementation ControlTransport_JumpToTimeControlType

@dynamic time;

typedef struct ControlTransport_JumpToTimeControlType__storage_ {
  uint32_t _has_storage_[1];
  double time;
} ControlTransport_JumpToTimeControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_JumpToTimeControlType_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_JumpToTimeControlType__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_JumpToTimeControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_JumpToTimeControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_JumpToPercentControlType

@implementation ControlTransport_JumpToPercentControlType

@dynamic percent;

typedef struct ControlTransport_JumpToPercentControlType__storage_ {
  uint32_t _has_storage_[1];
  double percent;
} ControlTransport_JumpToPercentControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "percent",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_JumpToPercentControlType_FieldNumber_Percent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_JumpToPercentControlType__storage_, percent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_JumpToPercentControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_JumpToPercentControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_MarkInPointControlType

@implementation ControlTransport_MarkInPointControlType

@dynamic time;

typedef struct ControlTransport_MarkInPointControlType__storage_ {
  uint32_t _has_storage_[1];
  double time;
} ControlTransport_MarkInPointControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_MarkInPointControlType_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_MarkInPointControlType__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_MarkInPointControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_MarkInPointControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_MarkOutPointControlType

@implementation ControlTransport_MarkOutPointControlType

@dynamic time;

typedef struct ControlTransport_MarkOutPointControlType__storage_ {
  uint32_t _has_storage_[1];
  double time;
} ControlTransport_MarkOutPointControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_MarkOutPointControlType_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_MarkOutPointControlType__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_MarkOutPointControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_MarkOutPointControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetScaleModeControlType

@implementation ControlTransport_SetScaleModeControlType

@dynamic mode;
@dynamic alignment;

typedef struct ControlTransport_SetScaleModeControlType__storage_ {
  uint32_t _has_storage_[1];
  ControlTransport_SetScaleModeControlType_ScaleBehavior mode;
  ControlTransport_SetScaleModeControlType_ScaleAlignment alignment;
} ControlTransport_SetScaleModeControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = ControlTransport_SetScaleModeControlType_ScaleBehavior_EnumDescriptor,
        .number = ControlTransport_SetScaleModeControlType_FieldNumber_Mode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SetScaleModeControlType__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "alignment",
        .dataTypeSpecific.enumDescFunc = ControlTransport_SetScaleModeControlType_ScaleAlignment_EnumDescriptor,
        .number = ControlTransport_SetScaleModeControlType_FieldNumber_Alignment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ControlTransport_SetScaleModeControlType__storage_, alignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetScaleModeControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetScaleModeControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ControlTransport_SetScaleModeControlType_Mode_RawValue(ControlTransport_SetScaleModeControlType *message) {
  GPBDescriptor *descriptor = [ControlTransport_SetScaleModeControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetScaleModeControlType_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetControlTransport_SetScaleModeControlType_Mode_RawValue(ControlTransport_SetScaleModeControlType *message, int32_t value) {
  GPBDescriptor *descriptor = [ControlTransport_SetScaleModeControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetScaleModeControlType_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ControlTransport_SetScaleModeControlType_Alignment_RawValue(ControlTransport_SetScaleModeControlType *message) {
  GPBDescriptor *descriptor = [ControlTransport_SetScaleModeControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetScaleModeControlType_FieldNumber_Alignment];
  return GPBGetMessageRawEnumField(message, field);
}

void SetControlTransport_SetScaleModeControlType_Alignment_RawValue(ControlTransport_SetScaleModeControlType *message, int32_t value) {
  GPBDescriptor *descriptor = [ControlTransport_SetScaleModeControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetScaleModeControlType_FieldNumber_Alignment];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ControlTransport_SetScaleModeControlType_ScaleBehavior

GPBEnumDescriptor *ControlTransport_SetScaleModeControlType_ScaleBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleBehaviorFit\000ScaleBehaviorFill\000Scale"
        "BehaviorStretch\000ScaleBehaviorCustom\000";
    static const int32_t values[] = {
        ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorFit,
        ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorFill,
        ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorStretch,
        ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorCustom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ControlTransport_SetScaleModeControlType_ScaleBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ControlTransport_SetScaleModeControlType_ScaleBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ControlTransport_SetScaleModeControlType_ScaleBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorFit:
    case ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorFill:
    case ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorStretch:
    case ControlTransport_SetScaleModeControlType_ScaleBehavior_ScaleBehaviorCustom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ControlTransport_SetScaleModeControlType_ScaleAlignment

GPBEnumDescriptor *ControlTransport_SetScaleModeControlType_ScaleAlignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleAlignmentMiddleCenter\000ScaleAlignmen"
        "tTopLeft\000ScaleAlignmentTopCenter\000ScaleAl"
        "ignmentTopRight\000ScaleAlignmentMiddleRigh"
        "t\000ScaleAlignmentBottomRight\000ScaleAlignme"
        "ntBottomCenter\000ScaleAlignmentBottomLeft\000"
        "ScaleAlignmentMiddleLeft\000";
    static const int32_t values[] = {
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleCenter,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopLeft,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopCenter,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopRight,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleRight,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomRight,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomCenter,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomLeft,
        ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleLeft,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ControlTransport_SetScaleModeControlType_ScaleAlignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ControlTransport_SetScaleModeControlType_ScaleAlignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ControlTransport_SetScaleModeControlType_ScaleAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleCenter:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopLeft:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopCenter:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentTopRight:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleRight:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomRight:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomCenter:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentBottomLeft:
    case ControlTransport_SetScaleModeControlType_ScaleAlignment_ScaleAlignmentMiddleLeft:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ControlTransport_SetFlippedModeControlType

@implementation ControlTransport_SetFlippedModeControlType

@dynamic horizontal;
@dynamic vertical;

typedef struct ControlTransport_SetFlippedModeControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_SetFlippedModeControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "horizontal",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetFlippedModeControlType_FieldNumber_Horizontal,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "vertical",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetFlippedModeControlType_FieldNumber_Vertical,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetFlippedModeControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetFlippedModeControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetPlayRateControlType

@implementation ControlTransport_SetPlayRateControlType

@dynamic playRate;

typedef struct ControlTransport_SetPlayRateControlType__storage_ {
  uint32_t _has_storage_[1];
  double playRate;
} ControlTransport_SetPlayRateControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playRate",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetPlayRateControlType_FieldNumber_PlayRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SetPlayRateControlType__storage_, playRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetPlayRateControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetPlayRateControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetNativeRotationControlType

@implementation ControlTransport_SetNativeRotationControlType

@dynamic rotation;

typedef struct ControlTransport_SetNativeRotationControlType__storage_ {
  uint32_t _has_storage_[1];
  ControlTransport_SetNativeRotationControlType_NativeRotationType rotation;
} ControlTransport_SetNativeRotationControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rotation",
        .dataTypeSpecific.enumDescFunc = ControlTransport_SetNativeRotationControlType_NativeRotationType_EnumDescriptor,
        .number = ControlTransport_SetNativeRotationControlType_FieldNumber_Rotation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SetNativeRotationControlType__storage_, rotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetNativeRotationControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetNativeRotationControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ControlTransport_SetNativeRotationControlType_Rotation_RawValue(ControlTransport_SetNativeRotationControlType *message) {
  GPBDescriptor *descriptor = [ControlTransport_SetNativeRotationControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetNativeRotationControlType_FieldNumber_Rotation];
  return GPBGetMessageRawEnumField(message, field);
}

void SetControlTransport_SetNativeRotationControlType_Rotation_RawValue(ControlTransport_SetNativeRotationControlType *message, int32_t value) {
  GPBDescriptor *descriptor = [ControlTransport_SetNativeRotationControlType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlTransport_SetNativeRotationControlType_FieldNumber_Rotation];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ControlTransport_SetNativeRotationControlType_NativeRotationType

GPBEnumDescriptor *ControlTransport_SetNativeRotationControlType_NativeRotationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NativeRotationTypeRotateStandard\000NativeR"
        "otationTypeRotate90\000NativeRotationTypeRo"
        "tate180\000NativeRotationTypeRotate270\000";
    static const int32_t values[] = {
        ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotateStandard,
        ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate90,
        ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate180,
        ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate270,
    };
    static const char *extraTextFormatInfo = "\003\001f\350\344\346\202\000\002f\350\344\346\203\000\003f\350\344\346\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ControlTransport_SetNativeRotationControlType_NativeRotationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ControlTransport_SetNativeRotationControlType_NativeRotationType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ControlTransport_SetNativeRotationControlType_NativeRotationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotateStandard:
    case ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate90:
    case ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate180:
    case ControlTransport_SetNativeRotationControlType_NativeRotationType_NativeRotationTypeRotate270:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ControlTransport_TogglePlaybackControlType

@implementation ControlTransport_TogglePlaybackControlType


typedef struct ControlTransport_TogglePlaybackControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_TogglePlaybackControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_TogglePlaybackControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_TogglePlaybackControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetEffectsControlType

@implementation ControlTransport_SetEffectsControlType

@dynamic effectsArray, effectsArray_Count;

typedef struct ControlTransport_SetEffectsControlType__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectsArray;
} ControlTransport_SetEffectsControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = ControlTransport_SetEffectsControlType_FieldNumber_EffectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ControlTransport_SetEffectsControlType__storage_, effectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetEffectsControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetEffectsControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_UpdateEffectControlType

@implementation ControlTransport_UpdateEffectControlType

@dynamic hasEffect, effect;

typedef struct ControlTransport_UpdateEffectControlType__storage_ {
  uint32_t _has_storage_[1];
  Effect *effect;
} ControlTransport_UpdateEffectControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effect",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = ControlTransport_UpdateEffectControlType_FieldNumber_Effect,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_UpdateEffectControlType__storage_, effect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_UpdateEffectControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_UpdateEffectControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_BeginScrubControlType

@implementation ControlTransport_BeginScrubControlType


typedef struct ControlTransport_BeginScrubControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_BeginScrubControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_BeginScrubControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_BeginScrubControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_EndScrubControlType

@implementation ControlTransport_EndScrubControlType


typedef struct ControlTransport_EndScrubControlType__storage_ {
  uint32_t _has_storage_[1];
} ControlTransport_EndScrubControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_EndScrubControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ControlTransport_EndScrubControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_ScrubToTimeControlType

@implementation ControlTransport_ScrubToTimeControlType

@dynamic time;

typedef struct ControlTransport_ScrubToTimeControlType__storage_ {
  uint32_t _has_storage_[1];
  double time;
} ControlTransport_ScrubToTimeControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_ScrubToTimeControlType_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_ScrubToTimeControlType__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_ScrubToTimeControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_ScrubToTimeControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_ScrubToPercentControlType

@implementation ControlTransport_ScrubToPercentControlType

@dynamic percent;

typedef struct ControlTransport_ScrubToPercentControlType__storage_ {
  uint32_t _has_storage_[1];
  double percent;
} ControlTransport_ScrubToPercentControlType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "percent",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_ScrubToPercentControlType_FieldNumber_Percent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_ScrubToPercentControlType__storage_, percent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_ScrubToPercentControlType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_ScrubToPercentControlType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetAudioFadeType

@implementation ControlTransport_SetAudioFadeType

@dynamic fadeInDuration;
@dynamic fadeOutDuration;
@dynamic shouldFadeIn;
@dynamic shouldFadeOut;

typedef struct ControlTransport_SetAudioFadeType__storage_ {
  uint32_t _has_storage_[1];
  double fadeInDuration;
  double fadeOutDuration;
} ControlTransport_SetAudioFadeType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fadeInDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetAudioFadeType_FieldNumber_FadeInDuration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SetAudioFadeType__storage_, fadeInDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fadeOutDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetAudioFadeType_FieldNumber_FadeOutDuration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ControlTransport_SetAudioFadeType__storage_, fadeOutDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "shouldFadeIn",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetAudioFadeType_FieldNumber_ShouldFadeIn,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shouldFadeOut",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetAudioFadeType_FieldNumber_ShouldFadeOut,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetAudioFadeType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetAudioFadeType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ControlTransport_SetAudioPropertiesType

@implementation ControlTransport_SetAudioPropertiesType

@dynamic hasAudioProperties, audioProperties;
@dynamic soloArray, soloArray_Count;

typedef struct ControlTransport_SetAudioPropertiesType__storage_ {
  uint32_t _has_storage_[1];
  Media_AudioProperties *audioProperties;
  GPBBoolArray *soloArray;
} ControlTransport_SetAudioPropertiesType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioProperties",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioProperties),
        .number = ControlTransport_SetAudioPropertiesType_FieldNumber_AudioProperties,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlTransport_SetAudioPropertiesType__storage_, audioProperties),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "soloArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ControlTransport_SetAudioPropertiesType_FieldNumber_SoloArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ControlTransport_SetAudioPropertiesType__storage_, soloArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlTransport_SetAudioPropertiesType class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlTransport_SetAudioPropertiesType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ControlTransport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioInputSettings

@implementation AudioInputSettings

@dynamic inputsArray, inputsArray_Count;
@dynamic transitionTime;

typedef struct AudioInputSettings__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inputsArray;
  double transitionTime;
} AudioInputSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioInput),
        .number = AudioInputSettings_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AudioInputSettings__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transitionTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AudioInputSettings_FieldNumber_TransitionTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioInputSettings__storage_, transitionTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioInputSettings class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioInputSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VideoInputSettings

@implementation VideoInputSettings

@dynamic inputsArray, inputsArray_Count;

typedef struct VideoInputSettings__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inputsArray;
} VideoInputSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VideoInput),
        .number = VideoInputSettings_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VideoInputSettings__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VideoInputSettings class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VideoInputSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecordRequest

@implementation RecordRequest

@dynamic hasStream, stream;
@dynamic hasWorkingDirectory, workingDirectory;
@dynamic hasResi, resi;

typedef struct RecordRequest__storage_ {
  uint32_t _has_storage_[1];
  Recording_Stream *stream;
  URL *workingDirectory;
  RecordRequest_Resi *resi;
} RecordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stream",
        .dataTypeSpecific.clazz = GPBObjCClass(Recording_Stream),
        .number = RecordRequest_FieldNumber_Stream,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecordRequest__storage_, stream),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "workingDirectory",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = RecordRequest_FieldNumber_WorkingDirectory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecordRequest__storage_, workingDirectory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resi",
        .dataTypeSpecific.clazz = GPBObjCClass(RecordRequest_Resi),
        .number = RecordRequest_FieldNumber_Resi,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RecordRequest__storage_, resi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecordRequest class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecordRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecordRequest_Resi

@implementation RecordRequest_Resi

@dynamic gop;
@dynamic segmentSize;
@dynamic destinationGroupId;
@dynamic bufSize;
@dynamic minRate;
@dynamic maxRate;
@dynamic eventName;
@dynamic socialDescription;

typedef struct RecordRequest_Resi__storage_ {
  uint32_t _has_storage_[1];
  uint32_t gop;
  uint32_t bufSize;
  uint32_t minRate;
  uint32_t maxRate;
  NSString *destinationGroupId;
  NSString *eventName;
  NSString *socialDescription;
  double segmentSize;
} RecordRequest_Resi__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gop",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_Gop,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, gop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "segmentSize",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_SegmentSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, segmentSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "destinationGroupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_DestinationGroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, destinationGroupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bufSize",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_BufSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, bufSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minRate",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_MinRate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, minRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxRate",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_MaxRate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, maxRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "eventName",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_EventName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, eventName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "socialDescription",
        .dataTypeSpecific.clazz = Nil,
        .number = RecordRequest_Resi_FieldNumber_SocialDescription,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RecordRequest_Resi__storage_, socialDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecordRequest_Resi class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecordRequest_Resi__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\013\000\003\022\000\004\007\000\005\007\000\006\007\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(RecordRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextSegmentRequest

@implementation TextSegmentRequest

@dynamic segmentsArray, segmentsArray_Count;
@dynamic startPosition;

typedef struct TextSegmentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *segmentsArray;
  double startPosition;
} TextSegmentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "segmentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TextSegmentRequest_Segment),
        .number = TextSegmentRequest_FieldNumber_SegmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextSegmentRequest__storage_, segmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startPosition",
        .dataTypeSpecific.clazz = Nil,
        .number = TextSegmentRequest_FieldNumber_StartPosition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextSegmentRequest__storage_, startPosition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextSegmentRequest class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextSegmentRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextSegmentRequest_Segment

@implementation TextSegmentRequest_Segment

@dynamic index;
@dynamic size;

typedef struct TextSegmentRequest_Segment__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  double size;
} TextSegmentRequest_Segment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = TextSegmentRequest_Segment_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextSegmentRequest_Segment__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = TextSegmentRequest_Segment_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextSegmentRequest_Segment__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextSegmentRequest_Segment class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextSegmentRequest_Segment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TextSegmentRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProClockSource

@implementation ProClockSource

@dynamic uuid;
@dynamic name;
@dynamic connected;
@dynamic active;
@dynamic type;

typedef struct ProClockSource__storage_ {
  uint32_t _has_storage_[1];
  ProClockSource_Type type;
  NSString *uuid;
  NSString *name;
} ProClockSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = Nil,
        .number = ProClockSource_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProClockSource__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProClockSource_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProClockSource__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connected",
        .dataTypeSpecific.clazz = Nil,
        .number = ProClockSource_FieldNumber_Connected,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "active",
        .dataTypeSpecific.clazz = Nil,
        .number = ProClockSource_FieldNumber_Active,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ProClockSource_Type_EnumDescriptor,
        .number = ProClockSource_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ProClockSource__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProClockSource class]
                                     rootClass:[ProCoreRoot class]
                                          file:ProCoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProClockSource__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProClockSource_Type_RawValue(ProClockSource *message) {
  GPBDescriptor *descriptor = [ProClockSource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProClockSource_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProClockSource_Type_RawValue(ProClockSource *message, int32_t value) {
  GPBDescriptor *descriptor = [ProClockSource descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProClockSource_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ProClockSource_Type

GPBEnumDescriptor *ProClockSource_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeUnkown\000TypeInput\000TypeOutput\000";
    static const int32_t values[] = {
        ProClockSource_Type_TypeUnkown,
        ProClockSource_Type_TypeInput,
        ProClockSource_Type_TypeOutput,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProClockSource_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProClockSource_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProClockSource_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProClockSource_Type_TypeUnkown:
    case ProClockSource_Type_TypeInput:
    case ProClockSource_Type_TypeOutput:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
