// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: basicTypes.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "BasicTypes.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(URL_ExternalRelativePath);
GPBObjCClassDeclaration(URL_ExternalRelativePath_MacOSExternalVolume);
GPBObjCClassDeclaration(URL_ExternalRelativePath_Win32ExternalVolume);
GPBObjCClassDeclaration(URL_LocalRelativePath);
GPBObjCClassDeclaration(UUID);
GPBObjCClassDeclaration(Version);

#pragma mark - BasicTypesRoot

@implementation BasicTypesRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - BasicTypesRoot_FileDescriptor

static GPBFileDescriptor *BasicTypesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - URL

@implementation URL

@dynamic storageOneOfCase;
@dynamic relativeFilePathOneOfCase;
@dynamic platform;
@dynamic absoluteString;
@dynamic relativePath;
@dynamic local;
@dynamic external;

typedef struct URL__storage_ {
  uint32_t _has_storage_[3];
  URL_Platform platform;
  NSString *absoluteString;
  NSString *relativePath;
  URL_LocalRelativePath *local;
  URL_ExternalRelativePath *external;
} URL__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "absoluteString",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_FieldNumber_AbsoluteString,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(URL__storage_, absoluteString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "relativePath",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_FieldNumber_RelativePath,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(URL__storage_, relativePath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = URL_Platform_EnumDescriptor,
        .number = URL_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(URL__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "local",
        .dataTypeSpecific.clazz = GPBObjCClass(URL_LocalRelativePath),
        .number = URL_FieldNumber_Local,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(URL__storage_, local),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "external",
        .dataTypeSpecific.clazz = GPBObjCClass(URL_ExternalRelativePath),
        .number = URL_FieldNumber_External,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(URL__storage_, external),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URL class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URL__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "storage",
      "relativeFilePath",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t URL_Platform_RawValue(URL *message) {
  GPBDescriptor *descriptor = [URL descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:URL_FieldNumber_Platform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetURL_Platform_RawValue(URL *message, int32_t value) {
  GPBDescriptor *descriptor = [URL descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:URL_FieldNumber_Platform];
  GPBSetMessageRawEnumField(message, field, value);
}

void URL_ClearStorageOneOfCase(URL *message) {
  GPBDescriptor *descriptor = [URL descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
void URL_ClearRelativeFilePathOneOfCase(URL *message) {
  GPBDescriptor *descriptor = [URL descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum URL_Platform

GPBEnumDescriptor *URL_Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlatformUnknown\000PlatformMacos\000PlatformWi"
        "n32\000PlatformWeb\000";
    static const int32_t values[] = {
        URL_Platform_PlatformUnknown,
        URL_Platform_PlatformMacos,
        URL_Platform_PlatformWin32,
        URL_Platform_PlatformWeb,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(URL_Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:URL_Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL URL_Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case URL_Platform_PlatformUnknown:
    case URL_Platform_PlatformMacos:
    case URL_Platform_PlatformWin32:
    case URL_Platform_PlatformWeb:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - URL_LocalRelativePath

@implementation URL_LocalRelativePath

@dynamic root;
@dynamic path;

typedef struct URL_LocalRelativePath__storage_ {
  uint32_t _has_storage_[1];
  URL_LocalRelativePath_Root root;
  NSString *path;
} URL_LocalRelativePath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "root",
        .dataTypeSpecific.enumDescFunc = URL_LocalRelativePath_Root_EnumDescriptor,
        .number = URL_LocalRelativePath_FieldNumber_Root,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(URL_LocalRelativePath__storage_, root),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_LocalRelativePath_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(URL_LocalRelativePath__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URL_LocalRelativePath class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URL_LocalRelativePath__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(URL)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t URL_LocalRelativePath_Root_RawValue(URL_LocalRelativePath *message) {
  GPBDescriptor *descriptor = [URL_LocalRelativePath descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:URL_LocalRelativePath_FieldNumber_Root];
  return GPBGetMessageRawEnumField(message, field);
}

void SetURL_LocalRelativePath_Root_RawValue(URL_LocalRelativePath *message, int32_t value) {
  GPBDescriptor *descriptor = [URL_LocalRelativePath descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:URL_LocalRelativePath_FieldNumber_Root];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum URL_LocalRelativePath_Root

GPBEnumDescriptor *URL_LocalRelativePath_Root_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RootUnknown\000RootBootVolume\000RootUserHome\000"
        "RootUserDocuments\000RootUserDownloads\000Root"
        "UserMusic\000RootUserPictures\000RootUserVideo"
        "s\000RootUserDesktop\000RootUserAppSupport\000Roo"
        "tShared\000RootShow\000RootCurrentResource\000";
    static const int32_t values[] = {
        URL_LocalRelativePath_Root_RootUnknown,
        URL_LocalRelativePath_Root_RootBootVolume,
        URL_LocalRelativePath_Root_RootUserHome,
        URL_LocalRelativePath_Root_RootUserDocuments,
        URL_LocalRelativePath_Root_RootUserDownloads,
        URL_LocalRelativePath_Root_RootUserMusic,
        URL_LocalRelativePath_Root_RootUserPictures,
        URL_LocalRelativePath_Root_RootUserVideos,
        URL_LocalRelativePath_Root_RootUserDesktop,
        URL_LocalRelativePath_Root_RootUserAppSupport,
        URL_LocalRelativePath_Root_RootShared,
        URL_LocalRelativePath_Root_RootShow,
        URL_LocalRelativePath_Root_RootCurrentResource,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(URL_LocalRelativePath_Root)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:URL_LocalRelativePath_Root_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL URL_LocalRelativePath_Root_IsValidValue(int32_t value__) {
  switch (value__) {
    case URL_LocalRelativePath_Root_RootUnknown:
    case URL_LocalRelativePath_Root_RootBootVolume:
    case URL_LocalRelativePath_Root_RootUserHome:
    case URL_LocalRelativePath_Root_RootUserDocuments:
    case URL_LocalRelativePath_Root_RootUserDownloads:
    case URL_LocalRelativePath_Root_RootUserMusic:
    case URL_LocalRelativePath_Root_RootUserPictures:
    case URL_LocalRelativePath_Root_RootUserVideos:
    case URL_LocalRelativePath_Root_RootUserDesktop:
    case URL_LocalRelativePath_Root_RootUserAppSupport:
    case URL_LocalRelativePath_Root_RootShared:
    case URL_LocalRelativePath_Root_RootShow:
    case URL_LocalRelativePath_Root_RootCurrentResource:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - URL_ExternalRelativePath

@implementation URL_ExternalRelativePath

@dynamic hasMacos, macos;
@dynamic hasWin32, win32;
@dynamic path;

typedef struct URL_ExternalRelativePath__storage_ {
  uint32_t _has_storage_[1];
  URL_ExternalRelativePath_MacOSExternalVolume *macos;
  URL_ExternalRelativePath_Win32ExternalVolume *win32;
  NSString *path;
} URL_ExternalRelativePath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "macos",
        .dataTypeSpecific.clazz = GPBObjCClass(URL_ExternalRelativePath_MacOSExternalVolume),
        .number = URL_ExternalRelativePath_FieldNumber_Macos,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath__storage_, macos),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "win32",
        .dataTypeSpecific.clazz = GPBObjCClass(URL_ExternalRelativePath_Win32ExternalVolume),
        .number = URL_ExternalRelativePath_FieldNumber_Win32,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath__storage_, win32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_ExternalRelativePath_FieldNumber_Path,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URL_ExternalRelativePath class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URL_ExternalRelativePath__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(URL)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - URL_ExternalRelativePath_MacOSExternalVolume

@implementation URL_ExternalRelativePath_MacOSExternalVolume

@dynamic volumeName;

typedef struct URL_ExternalRelativePath_MacOSExternalVolume__storage_ {
  uint32_t _has_storage_[1];
  NSString *volumeName;
} URL_ExternalRelativePath_MacOSExternalVolume__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "volumeName",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_ExternalRelativePath_MacOSExternalVolume_FieldNumber_VolumeName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath_MacOSExternalVolume__storage_, volumeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URL_ExternalRelativePath_MacOSExternalVolume class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URL_ExternalRelativePath_MacOSExternalVolume__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(URL_ExternalRelativePath)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - URL_ExternalRelativePath_Win32ExternalVolume

@implementation URL_ExternalRelativePath_Win32ExternalVolume

@dynamic driveLetter;
@dynamic volumeName;
@dynamic networkShare;

typedef struct URL_ExternalRelativePath_Win32ExternalVolume__storage_ {
  uint32_t _has_storage_[1];
  NSString *driveLetter;
  NSString *volumeName;
} URL_ExternalRelativePath_Win32ExternalVolume__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "driveLetter",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_ExternalRelativePath_Win32ExternalVolume_FieldNumber_DriveLetter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath_Win32ExternalVolume__storage_, driveLetter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "volumeName",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_ExternalRelativePath_Win32ExternalVolume_FieldNumber_VolumeName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(URL_ExternalRelativePath_Win32ExternalVolume__storage_, volumeName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "networkShare",
        .dataTypeSpecific.clazz = Nil,
        .number = URL_ExternalRelativePath_Win32ExternalVolume_FieldNumber_NetworkShare,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URL_ExternalRelativePath_Win32ExternalVolume class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URL_ExternalRelativePath_Win32ExternalVolume__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(URL_ExternalRelativePath)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - URLs

@implementation URLs

@dynamic urlsArray, urlsArray_Count;

typedef struct URLs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *urlsArray;
} URLs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "urlsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = URLs_FieldNumber_UrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(URLs__storage_, urlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[URLs class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(URLs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UUID

@implementation UUID

@dynamic string;

typedef struct UUID__storage_ {
  uint32_t _has_storage_[1];
  NSString *string;
} UUID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "string",
        .dataTypeSpecific.clazz = Nil,
        .number = UUID_FieldNumber_String,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UUID__storage_, string),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UUID class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UUID__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IntRange

@implementation IntRange

@dynamic start;
@dynamic end;

typedef struct IntRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t start;
  int32_t end;
} IntRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = Nil,
        .number = IntRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IntRange__storage_, start),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.clazz = Nil,
        .number = IntRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IntRange__storage_, end),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IntRange class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IntRange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Color

@implementation Color

@dynamic red;
@dynamic green;
@dynamic blue;
@dynamic alpha;

typedef struct Color__storage_ {
  uint32_t _has_storage_[1];
  float red;
  float green;
  float blue;
  float alpha;
} Color__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "red",
        .dataTypeSpecific.clazz = Nil,
        .number = Color_FieldNumber_Red,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Color__storage_, red),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "green",
        .dataTypeSpecific.clazz = Nil,
        .number = Color_FieldNumber_Green,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Color__storage_, green),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "blue",
        .dataTypeSpecific.clazz = Nil,
        .number = Color_FieldNumber_Blue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Color__storage_, blue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.clazz = Nil,
        .number = Color_FieldNumber_Alpha,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Color__storage_, alpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Color class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Color__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Version

@implementation Version

@dynamic majorVersion;
@dynamic minorVersion;
@dynamic patchVersion;
@dynamic build;

typedef struct Version__storage_ {
  uint32_t _has_storage_[1];
  uint32_t majorVersion;
  uint32_t minorVersion;
  uint32_t patchVersion;
  NSString *build;
} Version__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "majorVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_MajorVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Version__storage_, majorVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minorVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_MinorVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Version__storage_, minorVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "patchVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_PatchVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Version__storage_, patchVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "build",
        .dataTypeSpecific.clazz = Nil,
        .number = Version_FieldNumber_Build,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Version__storage_, build),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Version class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Version__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ApplicationInfo

@implementation ApplicationInfo

@dynamic platform;
@dynamic hasPlatformVersion, platformVersion;
@dynamic application;
@dynamic hasApplicationVersion, applicationVersion;

typedef struct ApplicationInfo__storage_ {
  uint32_t _has_storage_[1];
  ApplicationInfo_Platform platform;
  ApplicationInfo_Application application;
  Version *platformVersion;
  Version *applicationVersion;
} ApplicationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = ApplicationInfo_Platform_EnumDescriptor,
        .number = ApplicationInfo_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ApplicationInfo__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "platformVersion",
        .dataTypeSpecific.clazz = GPBObjCClass(Version),
        .number = ApplicationInfo_FieldNumber_PlatformVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ApplicationInfo__storage_, platformVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "application",
        .dataTypeSpecific.enumDescFunc = ApplicationInfo_Application_EnumDescriptor,
        .number = ApplicationInfo_FieldNumber_Application,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ApplicationInfo__storage_, application),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "applicationVersion",
        .dataTypeSpecific.clazz = GPBObjCClass(Version),
        .number = ApplicationInfo_FieldNumber_ApplicationVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ApplicationInfo__storage_, applicationVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ApplicationInfo class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ApplicationInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ApplicationInfo_Platform_RawValue(ApplicationInfo *message) {
  GPBDescriptor *descriptor = [ApplicationInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ApplicationInfo_FieldNumber_Platform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetApplicationInfo_Platform_RawValue(ApplicationInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ApplicationInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ApplicationInfo_FieldNumber_Platform];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ApplicationInfo_Application_RawValue(ApplicationInfo *message) {
  GPBDescriptor *descriptor = [ApplicationInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ApplicationInfo_FieldNumber_Application];
  return GPBGetMessageRawEnumField(message, field);
}

void SetApplicationInfo_Application_RawValue(ApplicationInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ApplicationInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ApplicationInfo_FieldNumber_Application];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ApplicationInfo_Platform

GPBEnumDescriptor *ApplicationInfo_Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlatformUndefined\000PlatformMacos\000Platform"
        "Windows\000";
    static const int32_t values[] = {
        ApplicationInfo_Platform_PlatformUndefined,
        ApplicationInfo_Platform_PlatformMacos,
        ApplicationInfo_Platform_PlatformWindows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ApplicationInfo_Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ApplicationInfo_Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ApplicationInfo_Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case ApplicationInfo_Platform_PlatformUndefined:
    case ApplicationInfo_Platform_PlatformMacos:
    case ApplicationInfo_Platform_PlatformWindows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ApplicationInfo_Application

GPBEnumDescriptor *ApplicationInfo_Application_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ApplicationUndefined\000ApplicationProprese"
        "nter\000ApplicationPvp\000ApplicationProvideos"
        "erver\000ApplicationScoreboard\000";
    static const int32_t values[] = {
        ApplicationInfo_Application_ApplicationUndefined,
        ApplicationInfo_Application_ApplicationPropresenter,
        ApplicationInfo_Application_ApplicationPvp,
        ApplicationInfo_Application_ApplicationProvideoserver,
        ApplicationInfo_Application_ApplicationScoreboard,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ApplicationInfo_Application)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ApplicationInfo_Application_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ApplicationInfo_Application_IsValidValue(int32_t value__) {
  switch (value__) {
    case ApplicationInfo_Application_ApplicationUndefined:
    case ApplicationInfo_Application_ApplicationPropresenter:
    case ApplicationInfo_Application_ApplicationPvp:
    case ApplicationInfo_Application_ApplicationProvideoserver:
    case ApplicationInfo_Application_ApplicationScoreboard:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CollectionElementType

@implementation CollectionElementType

@dynamic hasParameterUuid, parameterUuid;
@dynamic parameterName;

typedef struct CollectionElementType__storage_ {
  uint32_t _has_storage_[1];
  UUID *parameterUuid;
  NSString *parameterName;
} CollectionElementType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parameterUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = CollectionElementType_FieldNumber_ParameterUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectionElementType__storage_, parameterUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "parameterName",
        .dataTypeSpecific.clazz = Nil,
        .number = CollectionElementType_FieldNumber_ParameterName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CollectionElementType__storage_, parameterName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectionElementType class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectionElementType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MusicKeyScale

@implementation MusicKeyScale

@dynamic musicKey;
@dynamic musicScale;

typedef struct MusicKeyScale__storage_ {
  uint32_t _has_storage_[1];
  MusicKeyScale_MusicKey musicKey;
  MusicKeyScale_MusicScale musicScale;
} MusicKeyScale__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "musicKey",
        .dataTypeSpecific.enumDescFunc = MusicKeyScale_MusicKey_EnumDescriptor,
        .number = MusicKeyScale_FieldNumber_MusicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MusicKeyScale__storage_, musicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "musicScale",
        .dataTypeSpecific.enumDescFunc = MusicKeyScale_MusicScale_EnumDescriptor,
        .number = MusicKeyScale_FieldNumber_MusicScale,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MusicKeyScale__storage_, musicScale),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MusicKeyScale class]
                                     rootClass:[BasicTypesRoot class]
                                          file:BasicTypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MusicKeyScale__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MusicKeyScale_MusicKey_RawValue(MusicKeyScale *message) {
  GPBDescriptor *descriptor = [MusicKeyScale descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MusicKeyScale_FieldNumber_MusicKey];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMusicKeyScale_MusicKey_RawValue(MusicKeyScale *message, int32_t value) {
  GPBDescriptor *descriptor = [MusicKeyScale descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MusicKeyScale_FieldNumber_MusicKey];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t MusicKeyScale_MusicScale_RawValue(MusicKeyScale *message) {
  GPBDescriptor *descriptor = [MusicKeyScale descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MusicKeyScale_FieldNumber_MusicScale];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMusicKeyScale_MusicScale_RawValue(MusicKeyScale *message, int32_t value) {
  GPBDescriptor *descriptor = [MusicKeyScale descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MusicKeyScale_FieldNumber_MusicScale];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum MusicKeyScale_MusicKey

GPBEnumDescriptor *MusicKeyScale_MusicKey_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MusicKeyAFlat\000MusicKeyA\000MusicKeyASharp\000M"
        "usicKeyBFlat\000MusicKeyB\000MusicKeyBSharp\000Mu"
        "sicKeyCFlat\000MusicKeyC\000MusicKeyCSharp\000Mus"
        "icKeyDFlat\000MusicKeyD\000MusicKeyDSharp\000Musi"
        "cKeyEFlat\000MusicKeyE\000MusicKeyESharp\000Music"
        "KeyFFlat\000MusicKeyF\000MusicKeyFSharp\000MusicK"
        "eyGFlat\000MusicKeyG\000MusicKeyGSharp\000";
    static const int32_t values[] = {
        MusicKeyScale_MusicKey_MusicKeyAFlat,
        MusicKeyScale_MusicKey_MusicKeyA,
        MusicKeyScale_MusicKey_MusicKeyASharp,
        MusicKeyScale_MusicKey_MusicKeyBFlat,
        MusicKeyScale_MusicKey_MusicKeyB,
        MusicKeyScale_MusicKey_MusicKeyBSharp,
        MusicKeyScale_MusicKey_MusicKeyCFlat,
        MusicKeyScale_MusicKey_MusicKeyC,
        MusicKeyScale_MusicKey_MusicKeyCSharp,
        MusicKeyScale_MusicKey_MusicKeyDFlat,
        MusicKeyScale_MusicKey_MusicKeyD,
        MusicKeyScale_MusicKey_MusicKeyDSharp,
        MusicKeyScale_MusicKey_MusicKeyEFlat,
        MusicKeyScale_MusicKey_MusicKeyE,
        MusicKeyScale_MusicKey_MusicKeyESharp,
        MusicKeyScale_MusicKey_MusicKeyFFlat,
        MusicKeyScale_MusicKey_MusicKeyF,
        MusicKeyScale_MusicKey_MusicKeyFSharp,
        MusicKeyScale_MusicKey_MusicKeyGFlat,
        MusicKeyScale_MusicKey_MusicKeyG,
        MusicKeyScale_MusicKey_MusicKeyGSharp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MusicKeyScale_MusicKey)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MusicKeyScale_MusicKey_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MusicKeyScale_MusicKey_IsValidValue(int32_t value__) {
  switch (value__) {
    case MusicKeyScale_MusicKey_MusicKeyAFlat:
    case MusicKeyScale_MusicKey_MusicKeyA:
    case MusicKeyScale_MusicKey_MusicKeyASharp:
    case MusicKeyScale_MusicKey_MusicKeyBFlat:
    case MusicKeyScale_MusicKey_MusicKeyB:
    case MusicKeyScale_MusicKey_MusicKeyBSharp:
    case MusicKeyScale_MusicKey_MusicKeyCFlat:
    case MusicKeyScale_MusicKey_MusicKeyC:
    case MusicKeyScale_MusicKey_MusicKeyCSharp:
    case MusicKeyScale_MusicKey_MusicKeyDFlat:
    case MusicKeyScale_MusicKey_MusicKeyD:
    case MusicKeyScale_MusicKey_MusicKeyDSharp:
    case MusicKeyScale_MusicKey_MusicKeyEFlat:
    case MusicKeyScale_MusicKey_MusicKeyE:
    case MusicKeyScale_MusicKey_MusicKeyESharp:
    case MusicKeyScale_MusicKey_MusicKeyFFlat:
    case MusicKeyScale_MusicKey_MusicKeyF:
    case MusicKeyScale_MusicKey_MusicKeyFSharp:
    case MusicKeyScale_MusicKey_MusicKeyGFlat:
    case MusicKeyScale_MusicKey_MusicKeyG:
    case MusicKeyScale_MusicKey_MusicKeyGSharp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MusicKeyScale_MusicScale

GPBEnumDescriptor *MusicKeyScale_MusicScale_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MusicScaleMajor\000MusicScaleMinor\000";
    static const int32_t values[] = {
        MusicKeyScale_MusicScale_MusicScaleMajor,
        MusicKeyScale_MusicScale_MusicScaleMinor,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MusicKeyScale_MusicScale)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MusicKeyScale_MusicScale_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MusicKeyScale_MusicScale_IsValidValue(int32_t value__) {
  switch (value__) {
    case MusicKeyScale_MusicScale_MusicScaleMajor:
    case MusicKeyScale_MusicScale_MusicScaleMinor:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
