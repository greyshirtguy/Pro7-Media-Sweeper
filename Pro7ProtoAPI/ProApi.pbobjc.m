// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proApi.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "ProApi.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "Messages.pbobjc.h"
#import "Timers.pbobjc.h"
#import "Timestamp.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Message_TokenValue);
GPBObjCClassDeclaration(NetworkAPI);
GPBObjCClassDeclaration(NetworkAPI_Action);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Clear);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Look);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Macro);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Message);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Message_ClearMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Message_TriggerMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Prop);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Prop_ClearProp);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Prop_TriggerProp);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage_StageLayouts);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage_StageMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage_StageMessage_ClearMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage_StageMessage_HideMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Stage_StageMessage_ShowMessage);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Status);
GPBObjCClassDeclaration(NetworkAPI_Action_API_StatusResponse);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Timer);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Timer_ConfigureTimer);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Timer_ResetTimer);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Timer_StartTimer);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Timer_StopTimer);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport_GoToEnd);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport_Pause);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport_Play);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport_SkipBackward);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Transport_SkipForward);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_Audio);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_Media);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_Presentation);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation);
GPBObjCClassDeclaration(NetworkAPI_Action_API_Trigger_VideoInput);
GPBObjCClassDeclaration(NetworkAPI_Group);
GPBObjCClassDeclaration(NetworkAPI_GroupChange);
GPBObjCClassDeclaration(NetworkAPI_GroupInvite);
GPBObjCClassDeclaration(NetworkAPI_GroupJoin);
GPBObjCClassDeclaration(NetworkAPI_GroupKick);
GPBObjCClassDeclaration(NetworkAPI_GroupResponse);
GPBObjCClassDeclaration(NetworkAPI_GroupResponse_Status);
GPBObjCClassDeclaration(NetworkAPI_GroupResponse_Success);
GPBObjCClassDeclaration(NetworkAPI_GroupStatus);
GPBObjCClassDeclaration(NetworkAPI_Group_Member);
GPBObjCClassDeclaration(NetworkAPI_IndexOrNameIdentifier);
GPBObjCClassDeclaration(NetworkAPI_IndexOrNameIdentifierPair);
GPBObjCClassDeclaration(NetworkAPI_ServerState);
GPBObjCClassDeclaration(ProLink);
GPBObjCClassDeclaration(ProLink_ClientAction);
GPBObjCClassDeclaration(ProLink_ClientAction_AddConnection);
GPBObjCClassDeclaration(ProLink_ClientAction_CancelAction);
GPBObjCClassDeclaration(ProLink_ClientAction_RemoveConnection);
GPBObjCClassDeclaration(ProLink_Configuration);
GPBObjCClassDeclaration(ProLink_GroupDefinition);
GPBObjCClassDeclaration(ProLink_GroupDefinition_Member);
GPBObjCClassDeclaration(ProLink_HandlerIn);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_Declined);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_Timeout);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected);
GPBObjCClassDeclaration(ProLink_HandlerIn_AddConnectionResult_Success);
GPBObjCClassDeclaration(ProLink_HandlerIn_ConfigurationRequest);
GPBObjCClassDeclaration(ProLink_HandlerIn_GroupDefinitionRequest);
GPBObjCClassDeclaration(ProLink_HandlerIn_GroupJoinConfirmation);
GPBObjCClassDeclaration(ProLink_HandlerIn_GroupJoinPassword);
GPBObjCClassDeclaration(ProLink_HandlerIn_GroupName);
GPBObjCClassDeclaration(ProLink_HandlerIn_MemberStatusChange);
GPBObjCClassDeclaration(ProLink_HandlerIn_ProPresenterInfo);
GPBObjCClassDeclaration(ProLink_HandlerIn_ServerState);
GPBObjCClassDeclaration(ProLink_HandlerOut);
GPBObjCClassDeclaration(ProLink_HandlerOut_GroupJoinConfirmation);
GPBObjCClassDeclaration(ProLink_HandlerOut_GroupJoinPassword);
GPBObjCClassDeclaration(ProLink_HandlerOut_GroupName);
GPBObjCClassDeclaration(ProLink_HandlerOut_ProPresenterInfo);
GPBObjCClassDeclaration(ProLink_MemberStatus);
GPBObjCClassDeclaration(ProLink_TowerMessage);
GPBObjCClassDeclaration(ProLink_TowerMessage_TowerAddMemberResponse);
GPBObjCClassDeclaration(ProLink_TowerMessage_TowerAddMemberResponse_Accept);
GPBObjCClassDeclaration(Timer_Configuration);
GPBObjCClassDeclaration(Timestamp);

#pragma mark - ProApiRoot

@implementation ProApiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ProApiRoot_FileDescriptor

static GPBFileDescriptor *ProApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ProApiIn

@implementation ProApiIn

@dynamic messageTypeOneOfCase;
@dynamic handlerIn;
@dynamic networkApi;

typedef struct ProApiIn__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerIn *handlerIn;
  NetworkAPI *networkApi;
} ProApiIn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "handlerIn",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn),
        .number = ProApiIn_FieldNumber_HandlerIn,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProApiIn__storage_, handlerIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkApi",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI),
        .number = ProApiIn_FieldNumber_NetworkApi,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProApiIn__storage_, networkApi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProApiIn class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProApiIn__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "messageType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProApiIn_ClearMessageTypeOneOfCase(ProApiIn *message) {
  GPBDescriptor *descriptor = [ProApiIn descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProApiOut

@implementation ProApiOut

@dynamic messageTypeOneOfCase;
@dynamic handlerOut;
@dynamic clientAction;
@dynamic networkApi;

typedef struct ProApiOut__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerOut *handlerOut;
  ProLink_ClientAction *clientAction;
  NetworkAPI *networkApi;
} ProApiOut__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "handlerOut",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerOut),
        .number = ProApiOut_FieldNumber_HandlerOut,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProApiOut__storage_, handlerOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientAction",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_ClientAction),
        .number = ProApiOut_FieldNumber_ClientAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProApiOut__storage_, clientAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkApi",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI),
        .number = ProApiOut_FieldNumber_NetworkApi,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProApiOut__storage_, networkApi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProApiOut class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProApiOut__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "messageType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProApiOut_ClearMessageTypeOneOfCase(ProApiOut *message) {
  GPBDescriptor *descriptor = [ProApiOut descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink

@implementation ProLink


typedef struct ProLink__storage_ {
  uint32_t _has_storage_[1];
} ProLink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_GroupDefinition

@implementation ProLink_GroupDefinition

@dynamic hasTimestamp, timestamp;
@dynamic secret;
@dynamic name;
@dynamic membersArray, membersArray_Count;

typedef struct ProLink_GroupDefinition__storage_ {
  uint32_t _has_storage_[1];
  Timestamp *timestamp;
  NSString *secret;
  NSString *name;
  NSMutableArray *membersArray;
} ProLink_GroupDefinition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(Timestamp),
        .number = ProLink_GroupDefinition_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secret",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_GroupDefinition_FieldNumber_Secret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition__storage_, secret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_GroupDefinition_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition_Member),
        .number = ProLink_GroupDefinition_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_GroupDefinition class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_GroupDefinition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_GroupDefinition_Member

@implementation ProLink_GroupDefinition_Member

@dynamic ip;
@dynamic port;

typedef struct ProLink_GroupDefinition_Member__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *ip;
} ProLink_GroupDefinition_Member__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_GroupDefinition_Member_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition_Member__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_GroupDefinition_Member_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_GroupDefinition_Member__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_GroupDefinition_Member class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_GroupDefinition_Member__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_GroupDefinition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage

@implementation ProLink_TowerMessage


typedef struct ProLink_TowerMessage__storage_ {
  uint32_t _has_storage_[1];
} ProLink_TowerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_TowerMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage_TowerStatusRequest

@implementation ProLink_TowerMessage_TowerStatusRequest


typedef struct ProLink_TowerMessage_TowerStatusRequest__storage_ {
  uint32_t _has_storage_[1];
} ProLink_TowerMessage_TowerStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerStatusRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_TowerMessage_TowerStatusRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage_TowerStatusResponse

@implementation ProLink_TowerMessage_TowerStatusResponse

@dynamic responseOneOfCase;
@dynamic memberName;
@dynamic groupDefinition;

typedef struct ProLink_TowerMessage_TowerStatusResponse__storage_ {
  uint32_t _has_storage_[2];
  ProLink_GroupDefinition *groupDefinition;
  NSString *memberName;
} ProLink_TowerMessage_TowerStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_TowerMessage_TowerStatusResponse_FieldNumber_GroupDefinition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerStatusResponse__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_TowerMessage_TowerStatusResponse_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerStatusResponse__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerStatusResponse class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_TowerMessage_TowerStatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_TowerMessage_TowerStatusResponse_ClearResponseOneOfCase(ProLink_TowerMessage_TowerStatusResponse *message) {
  GPBDescriptor *descriptor = [ProLink_TowerMessage_TowerStatusResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_TowerMessage_TowerAddMemberRequest

@implementation ProLink_TowerMessage_TowerAddMemberRequest

@dynamic requestOneOfCase;
@dynamic groupDefinition;
@dynamic joiningMember;

typedef struct ProLink_TowerMessage_TowerAddMemberRequest__storage_ {
  uint32_t _has_storage_[2];
  ProLink_GroupDefinition *groupDefinition;
  ProLink_GroupDefinition_Member *joiningMember;
} ProLink_TowerMessage_TowerAddMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_TowerMessage_TowerAddMemberRequest_FieldNumber_GroupDefinition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerAddMemberRequest__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "joiningMember",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition_Member),
        .number = ProLink_TowerMessage_TowerAddMemberRequest_FieldNumber_JoiningMember,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerAddMemberRequest__storage_, joiningMember),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerAddMemberRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_TowerMessage_TowerAddMemberRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "request",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_TowerMessage_TowerAddMemberRequest_ClearRequestOneOfCase(ProLink_TowerMessage_TowerAddMemberRequest *message) {
  GPBDescriptor *descriptor = [ProLink_TowerMessage_TowerAddMemberRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_TowerMessage_TowerRemoveMemberRequest

@implementation ProLink_TowerMessage_TowerRemoveMemberRequest

@dynamic hasRemovingMember, removingMember;

typedef struct ProLink_TowerMessage_TowerRemoveMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  ProLink_GroupDefinition_Member *removingMember;
} ProLink_TowerMessage_TowerRemoveMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "removingMember",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition_Member),
        .number = ProLink_TowerMessage_TowerRemoveMemberRequest_FieldNumber_RemovingMember,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerRemoveMemberRequest__storage_, removingMember),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerRemoveMemberRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_TowerMessage_TowerRemoveMemberRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage_TowerAddMemberResponse

@implementation ProLink_TowerMessage_TowerAddMemberResponse

@dynamic responseOneOfCase;
@dynamic groupDefinition;
@dynamic accept;
@dynamic declineReason;

typedef struct ProLink_TowerMessage_TowerAddMemberResponse__storage_ {
  uint32_t _has_storage_[2];
  ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason declineReason;
  ProLink_GroupDefinition *groupDefinition;
  ProLink_TowerMessage_TowerAddMemberResponse_Accept *accept;
} ProLink_TowerMessage_TowerAddMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_TowerMessage_TowerAddMemberResponse_FieldNumber_GroupDefinition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerAddMemberResponse__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accept",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_TowerMessage_TowerAddMemberResponse_Accept),
        .number = ProLink_TowerMessage_TowerAddMemberResponse_FieldNumber_Accept,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerAddMemberResponse__storage_, accept),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "declineReason",
        .dataTypeSpecific.enumDescFunc = ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_EnumDescriptor,
        .number = ProLink_TowerMessage_TowerAddMemberResponse_FieldNumber_DeclineReason,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerAddMemberResponse__storage_, declineReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerAddMemberResponse class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_TowerMessage_TowerAddMemberResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_RawValue(ProLink_TowerMessage_TowerAddMemberResponse *message) {
  GPBDescriptor *descriptor = [ProLink_TowerMessage_TowerAddMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_TowerMessage_TowerAddMemberResponse_FieldNumber_DeclineReason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_RawValue(ProLink_TowerMessage_TowerAddMemberResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ProLink_TowerMessage_TowerAddMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_TowerMessage_TowerAddMemberResponse_FieldNumber_DeclineReason];
  GPBSetMessageRawEnumField(message, field, value);
}

void ProLink_TowerMessage_TowerAddMemberResponse_ClearResponseOneOfCase(ProLink_TowerMessage_TowerAddMemberResponse *message) {
  GPBDescriptor *descriptor = [ProLink_TowerMessage_TowerAddMemberResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason

GPBEnumDescriptor *ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AlreadyInGroup\000UserDeclined\000";
    static const int32_t values[] = {
        ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_AlreadyInGroup,
        ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_UserDeclined,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_AlreadyInGroup:
    case ProLink_TowerMessage_TowerAddMemberResponse_DeclineReason_UserDeclined:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ProLink_TowerMessage_TowerAddMemberResponse_Accept

@implementation ProLink_TowerMessage_TowerAddMemberResponse_Accept


typedef struct ProLink_TowerMessage_TowerAddMemberResponse_Accept__storage_ {
  uint32_t _has_storage_[1];
} ProLink_TowerMessage_TowerAddMemberResponse_Accept__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerAddMemberResponse_Accept class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_TowerMessage_TowerAddMemberResponse_Accept__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage_TowerAddMemberResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage_TowerHeartbeatRequest

@implementation ProLink_TowerMessage_TowerHeartbeatRequest


typedef struct ProLink_TowerMessage_TowerHeartbeatRequest__storage_ {
  uint32_t _has_storage_[1];
} ProLink_TowerMessage_TowerHeartbeatRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerHeartbeatRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_TowerMessage_TowerHeartbeatRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_TowerMessage_TowerHeartbeatResponse

@implementation ProLink_TowerMessage_TowerHeartbeatResponse

@dynamic hasGroupDefinition, groupDefinition;

typedef struct ProLink_TowerMessage_TowerHeartbeatResponse__storage_ {
  uint32_t _has_storage_[1];
  ProLink_GroupDefinition *groupDefinition;
} ProLink_TowerMessage_TowerHeartbeatResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_TowerMessage_TowerHeartbeatResponse_FieldNumber_GroupDefinition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_TowerMessage_TowerHeartbeatResponse__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_TowerMessage_TowerHeartbeatResponse class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_TowerMessage_TowerHeartbeatResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_TowerMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_MemberStatus

@implementation ProLink_MemberStatus

@dynamic ip;
@dynamic port;
@dynamic name;
@dynamic platform;
@dynamic osVersion;
@dynamic hostDescription;
@dynamic apiVersion;
@dynamic connectionStatus;

typedef struct ProLink_MemberStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  ProLink_MemberStatus_Platform platform;
  ProLink_MemberStatus_ConnectionStatus connectionStatus;
  NSString *ip;
  NSString *name;
  NSString *osVersion;
  NSString *hostDescription;
  NSString *apiVersion;
} ProLink_MemberStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = ProLink_MemberStatus_Platform_EnumDescriptor,
        .number = ProLink_MemberStatus_FieldNumber_Platform,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_OsVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, osVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostDescription",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_HostDescription,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, hostDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_MemberStatus_FieldNumber_ApiVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, apiVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectionStatus",
        .dataTypeSpecific.enumDescFunc = ProLink_MemberStatus_ConnectionStatus_EnumDescriptor,
        .number = ProLink_MemberStatus_FieldNumber_ConnectionStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ProLink_MemberStatus__storage_, connectionStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_MemberStatus class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_MemberStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProLink_MemberStatus_Platform_RawValue(ProLink_MemberStatus *message) {
  GPBDescriptor *descriptor = [ProLink_MemberStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_MemberStatus_FieldNumber_Platform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProLink_MemberStatus_Platform_RawValue(ProLink_MemberStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [ProLink_MemberStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_MemberStatus_FieldNumber_Platform];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t ProLink_MemberStatus_ConnectionStatus_RawValue(ProLink_MemberStatus *message) {
  GPBDescriptor *descriptor = [ProLink_MemberStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_MemberStatus_FieldNumber_ConnectionStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProLink_MemberStatus_ConnectionStatus_RawValue(ProLink_MemberStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [ProLink_MemberStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_MemberStatus_FieldNumber_ConnectionStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ProLink_MemberStatus_Platform

GPBEnumDescriptor *ProLink_MemberStatus_Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlatformUndefined\000PlatformMacos\000Platform"
        "Windows\000";
    static const int32_t values[] = {
        ProLink_MemberStatus_Platform_PlatformUndefined,
        ProLink_MemberStatus_Platform_PlatformMacos,
        ProLink_MemberStatus_Platform_PlatformWindows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProLink_MemberStatus_Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProLink_MemberStatus_Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProLink_MemberStatus_Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProLink_MemberStatus_Platform_PlatformUndefined:
    case ProLink_MemberStatus_Platform_PlatformMacos:
    case ProLink_MemberStatus_Platform_PlatformWindows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ProLink_MemberStatus_ConnectionStatus

GPBEnumDescriptor *ProLink_MemberStatus_ConnectionStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ConnectionStatusUnknown\000ConnectionStatus"
        "Connected\000ConnectionStatusDisconnected\000";
    static const int32_t values[] = {
        ProLink_MemberStatus_ConnectionStatus_ConnectionStatusUnknown,
        ProLink_MemberStatus_ConnectionStatus_ConnectionStatusConnected,
        ProLink_MemberStatus_ConnectionStatus_ConnectionStatusDisconnected,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProLink_MemberStatus_ConnectionStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProLink_MemberStatus_ConnectionStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProLink_MemberStatus_ConnectionStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProLink_MemberStatus_ConnectionStatus_ConnectionStatusUnknown:
    case ProLink_MemberStatus_ConnectionStatus_ConnectionStatusConnected:
    case ProLink_MemberStatus_ConnectionStatus_ConnectionStatusDisconnected:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ProLink_Configuration

@implementation ProLink_Configuration

@dynamic enableNetwork;
@dynamic port;
@dynamic networkName;
@dynamic remoteEnable;
@dynamic remoteControlEnable;
@dynamic remoteControlPassword;
@dynamic remoteObserveEnable;
@dynamic remoteObservePassword;
@dynamic stageEnable;
@dynamic stagePassword;
@dynamic linkEnable;

typedef struct ProLink_Configuration__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *networkName;
  NSString *remoteControlPassword;
  NSString *remoteObservePassword;
  NSString *stagePassword;
} ProLink_Configuration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enableNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_EnableNetwork,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_Port,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_Configuration__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "networkName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_NetworkName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProLink_Configuration__storage_, networkName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_RemoteEnable,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remoteControlEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_RemoteControlEnable,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remoteControlPassword",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_RemoteControlPassword,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ProLink_Configuration__storage_, remoteControlPassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteObserveEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_RemoteObserveEnable,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remoteObservePassword",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_RemoteObservePassword,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ProLink_Configuration__storage_, remoteObservePassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stageEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_StageEnable,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stagePassword",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_StagePassword,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ProLink_Configuration__storage_, stagePassword),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_Configuration_FieldNumber_LinkEnable,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_Configuration class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_Configuration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_ClientAction

@implementation ProLink_ClientAction

@dynamic actionTypeOneOfCase;
@dynamic setConfiguration;
@dynamic addConnection;
@dynamic removeConnection;
@dynamic cancelAction;

typedef struct ProLink_ClientAction__storage_ {
  uint32_t _has_storage_[2];
  ProLink_Configuration *setConfiguration;
  ProLink_ClientAction_AddConnection *addConnection;
  ProLink_ClientAction_RemoveConnection *removeConnection;
  ProLink_ClientAction_CancelAction *cancelAction;
} ProLink_ClientAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "setConfiguration",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_Configuration),
        .number = ProLink_ClientAction_FieldNumber_SetConfiguration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction__storage_, setConfiguration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addConnection",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_ClientAction_AddConnection),
        .number = ProLink_ClientAction_FieldNumber_AddConnection,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction__storage_, addConnection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeConnection",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_ClientAction_RemoveConnection),
        .number = ProLink_ClientAction_FieldNumber_RemoveConnection,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction__storage_, removeConnection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cancelAction",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_ClientAction_CancelAction),
        .number = ProLink_ClientAction_FieldNumber_CancelAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction__storage_, cancelAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_ClientAction class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_ClientAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "actionType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_ClientAction_ClearActionTypeOneOfCase(ProLink_ClientAction *message) {
  GPBDescriptor *descriptor = [ProLink_ClientAction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_ClientAction_AddConnection

@implementation ProLink_ClientAction_AddConnection

@dynamic ip;
@dynamic port;
@dynamic groupName;

typedef struct ProLink_ClientAction_AddConnection__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *ip;
  NSString *groupName;
} ProLink_ClientAction_AddConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_ClientAction_AddConnection_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_ClientAction_AddConnection__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_ClientAction_AddConnection_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction_AddConnection__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_ClientAction_AddConnection_FieldNumber_GroupName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_ClientAction_AddConnection__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_ClientAction_AddConnection class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_ClientAction_AddConnection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_ClientAction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_ClientAction_RemoveConnection

@implementation ProLink_ClientAction_RemoveConnection

@dynamic ip;
@dynamic port;

typedef struct ProLink_ClientAction_RemoveConnection__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *ip;
} ProLink_ClientAction_RemoveConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_ClientAction_RemoveConnection_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_ClientAction_RemoveConnection__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_ClientAction_RemoveConnection_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_ClientAction_RemoveConnection__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_ClientAction_RemoveConnection class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_ClientAction_RemoveConnection__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_ClientAction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_ClientAction_CancelAction

@implementation ProLink_ClientAction_CancelAction


typedef struct ProLink_ClientAction_CancelAction__storage_ {
  uint32_t _has_storage_[1];
} ProLink_ClientAction_CancelAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_ClientAction_CancelAction class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_ClientAction_CancelAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_ClientAction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn

@implementation ProLink_HandlerIn

@dynamic requestOneOfCase;
@dynamic groupName;
@dynamic groupDefinitionRequest;
@dynamic groupJoinConfirmation;
@dynamic groupJoinPassword;
@dynamic addConnectionResult;
@dynamic groupUpdate;
@dynamic memberStatusChange;
@dynamic propresenterInfo;
@dynamic serverState;
@dynamic configurationRequest;

typedef struct ProLink_HandlerIn__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerIn_GroupName *groupName;
  ProLink_HandlerIn_GroupDefinitionRequest *groupDefinitionRequest;
  ProLink_HandlerIn_GroupJoinConfirmation *groupJoinConfirmation;
  ProLink_HandlerIn_GroupJoinPassword *groupJoinPassword;
  ProLink_HandlerIn_AddConnectionResult *addConnectionResult;
  ProLink_GroupDefinition *groupUpdate;
  ProLink_HandlerIn_MemberStatusChange *memberStatusChange;
  ProLink_HandlerIn_ProPresenterInfo *propresenterInfo;
  ProLink_HandlerIn_ServerState *serverState;
  ProLink_HandlerIn_ConfigurationRequest *configurationRequest;
} ProLink_HandlerIn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_GroupName),
        .number = ProLink_HandlerIn_FieldNumber_GroupName,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupDefinitionRequest",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_GroupDefinitionRequest),
        .number = ProLink_HandlerIn_FieldNumber_GroupDefinitionRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, groupDefinitionRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupJoinConfirmation",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_GroupJoinConfirmation),
        .number = ProLink_HandlerIn_FieldNumber_GroupJoinConfirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, groupJoinConfirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupJoinPassword",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_GroupJoinPassword),
        .number = ProLink_HandlerIn_FieldNumber_GroupJoinPassword,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, groupJoinPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addConnectionResult",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult),
        .number = ProLink_HandlerIn_FieldNumber_AddConnectionResult,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, addConnectionResult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupUpdate",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_HandlerIn_FieldNumber_GroupUpdate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, groupUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberStatusChange",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_MemberStatusChange),
        .number = ProLink_HandlerIn_FieldNumber_MemberStatusChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, memberStatusChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "propresenterInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_ProPresenterInfo),
        .number = ProLink_HandlerIn_FieldNumber_PropresenterInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, propresenterInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverState",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_ServerState),
        .number = ProLink_HandlerIn_FieldNumber_ServerState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, serverState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configurationRequest",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_ConfigurationRequest),
        .number = ProLink_HandlerIn_FieldNumber_ConfigurationRequest,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn__storage_, configurationRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "request",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_HandlerIn_ClearRequestOneOfCase(ProLink_HandlerIn *message) {
  GPBDescriptor *descriptor = [ProLink_HandlerIn descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_HandlerIn_GroupName

@implementation ProLink_HandlerIn_GroupName


typedef struct ProLink_HandlerIn_GroupName__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_GroupName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_GroupName class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_GroupName__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_GroupDefinitionRequest

@implementation ProLink_HandlerIn_GroupDefinitionRequest


typedef struct ProLink_HandlerIn_GroupDefinitionRequest__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_GroupDefinitionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_GroupDefinitionRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_GroupDefinitionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_GroupJoinConfirmation

@implementation ProLink_HandlerIn_GroupJoinConfirmation

@dynamic name;

typedef struct ProLink_HandlerIn_GroupJoinConfirmation__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} ProLink_HandlerIn_GroupJoinConfirmation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_GroupJoinConfirmation_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_GroupJoinConfirmation__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_GroupJoinConfirmation class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_GroupJoinConfirmation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_GroupJoinPassword

@implementation ProLink_HandlerIn_GroupJoinPassword

@dynamic name;

typedef struct ProLink_HandlerIn_GroupJoinPassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} ProLink_HandlerIn_GroupJoinPassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_GroupJoinPassword_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_GroupJoinPassword__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_GroupJoinPassword class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_GroupJoinPassword__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult

@implementation ProLink_HandlerIn_AddConnectionResult

@dynamic resultOneOfCase;
@dynamic success;
@dynamic failure;

typedef struct ProLink_HandlerIn_AddConnectionResult__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerIn_AddConnectionResult_Success *success;
  ProLink_HandlerIn_AddConnectionResult_Failure *failure;
} ProLink_HandlerIn_AddConnectionResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Success),
        .number = ProLink_HandlerIn_AddConnectionResult_FieldNumber_Success,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult__storage_, success),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "failure",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure),
        .number = ProLink_HandlerIn_AddConnectionResult_FieldNumber_Failure,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult__storage_, failure),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_HandlerIn_AddConnectionResult_ClearResultOneOfCase(ProLink_HandlerIn_AddConnectionResult *message) {
  GPBDescriptor *descriptor = [ProLink_HandlerIn_AddConnectionResult descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_HandlerIn_AddConnectionResult_Success

@implementation ProLink_HandlerIn_AddConnectionResult_Success

@dynamic hasNewGroupDefinition, newGroupDefinition;

typedef struct ProLink_HandlerIn_AddConnectionResult_Success__storage_ {
  uint32_t _has_storage_[1];
  ProLink_GroupDefinition *newGroupDefinition;
} ProLink_HandlerIn_AddConnectionResult_Success__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newGroupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_HandlerIn_AddConnectionResult_Success_FieldNumber_NewGroupDefinition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Success__storage_, newGroupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Success class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Success__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure

@implementation ProLink_HandlerIn_AddConnectionResult_Failure

@dynamic reasonOneOfCase;
@dynamic unexpected;
@dynamic declined;
@dynamic timeout;
@dynamic linkDisabled;
@dynamic inOtherGroup;
@dynamic invalidIpAddress;
@dynamic alreadyInGroup;
@dynamic couldNotAdd;
@dynamic couldNotJoin;

typedef struct ProLink_HandlerIn_AddConnectionResult_Failure__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected *unexpected;
  ProLink_HandlerIn_AddConnectionResult_Failure_Declined *declined;
  ProLink_HandlerIn_AddConnectionResult_Failure_Timeout *timeout;
  ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled *linkDisabled;
  ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup *inOtherGroup;
  ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress *invalidIpAddress;
  ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup *alreadyInGroup;
  ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd *couldNotAdd;
  ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin *couldNotJoin;
} ProLink_HandlerIn_AddConnectionResult_Failure__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unexpected",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_Unexpected,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, unexpected),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "declined",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_Declined),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_Declined,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, declined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_Timeout),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_Timeout,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linkDisabled",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_LinkDisabled,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, linkDisabled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inOtherGroup",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_InOtherGroup,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, inOtherGroup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invalidIpAddress",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_InvalidIpAddress,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, invalidIpAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alreadyInGroup",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_AlreadyInGroup,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, alreadyInGroup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "couldNotAdd",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_CouldNotAdd,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, couldNotAdd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "couldNotJoin",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin),
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_FieldNumber_CouldNotJoin,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_, couldNotJoin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "reason",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_HandlerIn_AddConnectionResult_Failure_ClearReasonOneOfCase(ProLink_HandlerIn_AddConnectionResult_Failure *message) {
  GPBDescriptor *descriptor = [ProLink_HandlerIn_AddConnectionResult_Failure descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected


typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_Unexpected__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_Declined

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_Declined


typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_Declined__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_AddConnectionResult_Failure_Declined__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_Declined class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_Declined__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_Timeout

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_Timeout


typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_Timeout__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_AddConnectionResult_Failure_Timeout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_Timeout class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_Timeout__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled


typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_LinkDisabled__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup

@dynamic memberName;
@dynamic groupName;

typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberName;
  NSString *groupName;
} ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_InOtherGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress


typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_InvalidIpAddress__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup

@dynamic memberName;
@dynamic groupName;

typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberName;
  NSString *groupName;
} ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_AlreadyInGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd

@dynamic memberName;

typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberName;
} ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotAdd__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin

@implementation ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin

@dynamic groupName;

typedef struct ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupName;
} ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin_FieldNumber_GroupName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_AddConnectionResult_Failure_CouldNotJoin__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn_AddConnectionResult_Failure)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_MemberStatusChange

@implementation ProLink_HandlerIn_MemberStatusChange

@dynamic membersArray, membersArray_Count;

typedef struct ProLink_HandlerIn_MemberStatusChange__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *membersArray;
} ProLink_HandlerIn_MemberStatusChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_MemberStatus),
        .number = ProLink_HandlerIn_MemberStatusChange_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_MemberStatusChange__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_MemberStatusChange class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_MemberStatusChange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_ProPresenterInfo

@implementation ProLink_HandlerIn_ProPresenterInfo


typedef struct ProLink_HandlerIn_ProPresenterInfo__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_ProPresenterInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_ProPresenterInfo class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_ProPresenterInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_ServerState

@implementation ProLink_HandlerIn_ServerState

@dynamic localIp;
@dynamic publicIp;
@dynamic port;

typedef struct ProLink_HandlerIn_ServerState__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSString *localIp;
  NSString *publicIp;
} ProLink_HandlerIn_ServerState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "localIp",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_ServerState_FieldNumber_LocalIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_ServerState__storage_, localIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicIp",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_ServerState_FieldNumber_PublicIp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_ServerState__storage_, publicIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerIn_ServerState_FieldNumber_Port,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_HandlerIn_ServerState__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_ServerState class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerIn_ServerState__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerIn_ConfigurationRequest

@implementation ProLink_HandlerIn_ConfigurationRequest


typedef struct ProLink_HandlerIn_ConfigurationRequest__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerIn_ConfigurationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerIn_ConfigurationRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProLink_HandlerIn_ConfigurationRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerIn)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerOut

@implementation ProLink_HandlerOut

@dynamic responseOneOfCase;
@dynamic groupName;
@dynamic groupDefinition;
@dynamic groupJoinConfirmation;
@dynamic groupJoinPassword;
@dynamic propresenterInfo;
@dynamic configuration;

typedef struct ProLink_HandlerOut__storage_ {
  uint32_t _has_storage_[2];
  ProLink_HandlerOut_GroupName *groupName;
  ProLink_GroupDefinition *groupDefinition;
  ProLink_HandlerOut_GroupJoinConfirmation *groupJoinConfirmation;
  ProLink_HandlerOut_GroupJoinPassword *groupJoinPassword;
  ProLink_HandlerOut_ProPresenterInfo *propresenterInfo;
  ProLink_Configuration *configuration;
} ProLink_HandlerOut__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerOut_GroupName),
        .number = ProLink_HandlerOut_FieldNumber_GroupName,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = ProLink_HandlerOut_FieldNumber_GroupDefinition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupJoinConfirmation",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerOut_GroupJoinConfirmation),
        .number = ProLink_HandlerOut_FieldNumber_GroupJoinConfirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, groupJoinConfirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupJoinPassword",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerOut_GroupJoinPassword),
        .number = ProLink_HandlerOut_FieldNumber_GroupJoinPassword,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, groupJoinPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "propresenterInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_HandlerOut_ProPresenterInfo),
        .number = ProLink_HandlerOut_FieldNumber_PropresenterInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, propresenterInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configuration",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_Configuration),
        .number = ProLink_HandlerOut_FieldNumber_Configuration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut__storage_, configuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerOut class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerOut__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ProLink_HandlerOut_ClearResponseOneOfCase(ProLink_HandlerOut *message) {
  GPBDescriptor *descriptor = [ProLink_HandlerOut descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ProLink_HandlerOut_GroupName

@implementation ProLink_HandlerOut_GroupName

@dynamic name;

typedef struct ProLink_HandlerOut_GroupName__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} ProLink_HandlerOut_GroupName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerOut_GroupName_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut_GroupName__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerOut_GroupName class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerOut_GroupName__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerOut)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerOut_GroupJoinConfirmation

@implementation ProLink_HandlerOut_GroupJoinConfirmation

@dynamic accept;

typedef struct ProLink_HandlerOut_GroupJoinConfirmation__storage_ {
  uint32_t _has_storage_[1];
} ProLink_HandlerOut_GroupJoinConfirmation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accept",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerOut_GroupJoinConfirmation_FieldNumber_Accept,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerOut_GroupJoinConfirmation class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerOut_GroupJoinConfirmation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerOut)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerOut_GroupJoinPassword

@implementation ProLink_HandlerOut_GroupJoinPassword

@dynamic password;

typedef struct ProLink_HandlerOut_GroupJoinPassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *password;
} ProLink_HandlerOut_GroupJoinPassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "password",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerOut_GroupJoinPassword_FieldNumber_Password,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut_GroupJoinPassword__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerOut_GroupJoinPassword class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerOut_GroupJoinPassword__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerOut)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProLink_HandlerOut_ProPresenterInfo

@implementation ProLink_HandlerOut_ProPresenterInfo

@dynamic platform;
@dynamic osVersion;
@dynamic hostDescription;

typedef struct ProLink_HandlerOut_ProPresenterInfo__storage_ {
  uint32_t _has_storage_[1];
  ProLink_HandlerOut_ProPresenterInfo_Platform platform;
  NSString *osVersion;
  NSString *hostDescription;
} ProLink_HandlerOut_ProPresenterInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = ProLink_HandlerOut_ProPresenterInfo_Platform_EnumDescriptor,
        .number = ProLink_HandlerOut_ProPresenterInfo_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut_ProPresenterInfo__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerOut_ProPresenterInfo_FieldNumber_OsVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut_ProPresenterInfo__storage_, osVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hostDescription",
        .dataTypeSpecific.clazz = Nil,
        .number = ProLink_HandlerOut_ProPresenterInfo_FieldNumber_HostDescription,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProLink_HandlerOut_ProPresenterInfo__storage_, hostDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProLink_HandlerOut_ProPresenterInfo class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProLink_HandlerOut_ProPresenterInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ProLink_HandlerOut)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProLink_HandlerOut_ProPresenterInfo_Platform_RawValue(ProLink_HandlerOut_ProPresenterInfo *message) {
  GPBDescriptor *descriptor = [ProLink_HandlerOut_ProPresenterInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_HandlerOut_ProPresenterInfo_FieldNumber_Platform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProLink_HandlerOut_ProPresenterInfo_Platform_RawValue(ProLink_HandlerOut_ProPresenterInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ProLink_HandlerOut_ProPresenterInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProLink_HandlerOut_ProPresenterInfo_FieldNumber_Platform];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ProLink_HandlerOut_ProPresenterInfo_Platform

GPBEnumDescriptor *ProLink_HandlerOut_ProPresenterInfo_Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlatformUndefined\000PlatformMacos\000Platform"
        "Windows\000";
    static const int32_t values[] = {
        ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformUndefined,
        ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformMacos,
        ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformWindows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProLink_HandlerOut_ProPresenterInfo_Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProLink_HandlerOut_ProPresenterInfo_Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProLink_HandlerOut_ProPresenterInfo_Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformUndefined:
    case ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformMacos:
    case ProLink_HandlerOut_ProPresenterInfo_Platform_PlatformWindows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NetworkAPI

@implementation NetworkAPI

@dynamic commandOneOfCase;
@dynamic action;
@dynamic serverState;
@dynamic groupChange;
@dynamic groupResponse;

typedef struct NetworkAPI__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action *action;
  NetworkAPI_ServerState *serverState;
  NetworkAPI_GroupChange *groupChange;
  NetworkAPI_GroupResponse *groupResponse;
} NetworkAPI__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action),
        .number = NetworkAPI_FieldNumber_Action,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverState",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_ServerState),
        .number = NetworkAPI_FieldNumber_ServerState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI__storage_, serverState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupChange",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupChange),
        .number = NetworkAPI_FieldNumber_GroupChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI__storage_, groupChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupResponse),
        .number = NetworkAPI_FieldNumber_GroupResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI__storage_, groupResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "command",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_ClearCommandOneOfCase(NetworkAPI *message) {
  GPBDescriptor *descriptor = [NetworkAPI descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_LinkStatus

@implementation NetworkAPI_LinkStatus

@dynamic platform;
@dynamic osVersion;
@dynamic version;
@dynamic description_p;
@dynamic hasGroupInfo, groupInfo;

typedef struct NetworkAPI_LinkStatus__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_LinkStatus_Platform platform;
  NSString *osVersion;
  NSString *version;
  NSString *description_p;
  NetworkAPI_Group *groupInfo;
} NetworkAPI_LinkStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "platform",
        .dataTypeSpecific.enumDescFunc = NetworkAPI_LinkStatus_Platform_EnumDescriptor,
        .number = NetworkAPI_LinkStatus_FieldNumber_Platform,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_LinkStatus__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_LinkStatus_FieldNumber_OsVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_LinkStatus__storage_, osVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_LinkStatus_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkAPI_LinkStatus__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_LinkStatus_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkAPI_LinkStatus__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group),
        .number = NetworkAPI_LinkStatus_FieldNumber_GroupInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkAPI_LinkStatus__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_LinkStatus class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_LinkStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NetworkAPI_LinkStatus_Platform_RawValue(NetworkAPI_LinkStatus *message) {
  GPBDescriptor *descriptor = [NetworkAPI_LinkStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_LinkStatus_FieldNumber_Platform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetNetworkAPI_LinkStatus_Platform_RawValue(NetworkAPI_LinkStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [NetworkAPI_LinkStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_LinkStatus_FieldNumber_Platform];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum NetworkAPI_LinkStatus_Platform

GPBEnumDescriptor *NetworkAPI_LinkStatus_Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlatformUndefined\000PlatformMacos\000Platform"
        "Windows\000";
    static const int32_t values[] = {
        NetworkAPI_LinkStatus_Platform_PlatformUndefined,
        NetworkAPI_LinkStatus_Platform_PlatformMacos,
        NetworkAPI_LinkStatus_Platform_PlatformWindows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NetworkAPI_LinkStatus_Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NetworkAPI_LinkStatus_Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NetworkAPI_LinkStatus_Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case NetworkAPI_LinkStatus_Platform_PlatformUndefined:
    case NetworkAPI_LinkStatus_Platform_PlatformMacos:
    case NetworkAPI_LinkStatus_Platform_PlatformWindows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NetworkAPI_Group

@implementation NetworkAPI_Group

@dynamic name;
@dynamic membersArray, membersArray_Count;

typedef struct NetworkAPI_Group__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *membersArray;
} NetworkAPI_Group__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Group_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Group__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_Group_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Group__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Group class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Group__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Group_Member

@implementation NetworkAPI_Group_Member

@dynamic ipAddress;
@dynamic port;

typedef struct NetworkAPI_Group_Member__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *ipAddress;
} NetworkAPI_Group_Member__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ipAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Group_Member_FieldNumber_IpAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Group_Member__storage_, ipAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Group_Member_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_Group_Member__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Group_Member class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Group_Member__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Group)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupChange

@implementation NetworkAPI_GroupChange

@dynamic changeOneOfCase;
@dynamic invite;
@dynamic join;
@dynamic kick;
@dynamic status;

typedef struct NetworkAPI_GroupChange__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_GroupInvite *invite;
  NetworkAPI_GroupJoin *join;
  NetworkAPI_GroupKick *kick;
  NetworkAPI_GroupStatus *status;
} NetworkAPI_GroupChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invite",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupInvite),
        .number = NetworkAPI_GroupChange_FieldNumber_Invite,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupChange__storage_, invite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "join",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupJoin),
        .number = NetworkAPI_GroupChange_FieldNumber_Join,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupChange__storage_, join),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "kick",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupKick),
        .number = NetworkAPI_GroupChange_FieldNumber_Kick,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupChange__storage_, kick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupStatus),
        .number = NetworkAPI_GroupChange_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupChange__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupChange class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupChange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "change",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_GroupChange_ClearChangeOneOfCase(NetworkAPI_GroupChange *message) {
  GPBDescriptor *descriptor = [NetworkAPI_GroupChange descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_GroupResponse

@implementation NetworkAPI_GroupResponse

@dynamic responseOneOfCase;
@dynamic success;
@dynamic status;

typedef struct NetworkAPI_GroupResponse__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_GroupResponse_Success *success;
  NetworkAPI_GroupResponse_Status *status;
} NetworkAPI_GroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupResponse_Success),
        .number = NetworkAPI_GroupResponse_FieldNumber_Success,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupResponse__storage_, success),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_GroupResponse_Status),
        .number = NetworkAPI_GroupResponse_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupResponse class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_GroupResponse_ClearResponseOneOfCase(NetworkAPI_GroupResponse *message) {
  GPBDescriptor *descriptor = [NetworkAPI_GroupResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_GroupResponse_Success

@implementation NetworkAPI_GroupResponse_Success


typedef struct NetworkAPI_GroupResponse_Success__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_GroupResponse_Success__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupResponse_Success class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_GroupResponse_Success__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_GroupResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupResponse_Status

@implementation NetworkAPI_GroupResponse_Status

@dynamic memberName;
@dynamic groupName;

typedef struct NetworkAPI_GroupResponse_Status__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberName;
  NSString *groupName;
} NetworkAPI_GroupResponse_Status__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_GroupResponse_Status_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupResponse_Status__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_GroupResponse_Status_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupResponse_Status__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupResponse_Status class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupResponse_Status__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_GroupResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupStatus

@implementation NetworkAPI_GroupStatus

@dynamic hasMember, member;

typedef struct NetworkAPI_GroupStatus__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_Group_Member *member;
} NetworkAPI_GroupStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "member",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_GroupStatus_FieldNumber_Member,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupStatus__storage_, member),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupStatus class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupInvite

@implementation NetworkAPI_GroupInvite

@dynamic hasGroupInfo, groupInfo;
@dynamic secret;
@dynamic hasProspect, prospect;

typedef struct NetworkAPI_GroupInvite__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_Group *groupInfo;
  NSString *secret;
  NetworkAPI_Group_Member *prospect;
} NetworkAPI_GroupInvite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group),
        .number = NetworkAPI_GroupInvite_FieldNumber_GroupInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupInvite__storage_, groupInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secret",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_GroupInvite_FieldNumber_Secret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupInvite__storage_, secret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prospect",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_GroupInvite_FieldNumber_Prospect,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupInvite__storage_, prospect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupInvite class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupInvite__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupJoin

@implementation NetworkAPI_GroupJoin

@dynamic hasSponsor, sponsor;
@dynamic hasProspect, prospect;

typedef struct NetworkAPI_GroupJoin__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_Group_Member *sponsor;
  NetworkAPI_Group_Member *prospect;
} NetworkAPI_GroupJoin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sponsor",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_GroupJoin_FieldNumber_Sponsor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupJoin__storage_, sponsor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prospect",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_GroupJoin_FieldNumber_Prospect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupJoin__storage_, prospect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupJoin class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupJoin__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_GroupKick

@implementation NetworkAPI_GroupKick

@dynamic hasMember, member;

typedef struct NetworkAPI_GroupKick__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_Group_Member *member;
} NetworkAPI_GroupKick__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "member",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Group_Member),
        .number = NetworkAPI_GroupKick_FieldNumber_Member,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_GroupKick__storage_, member),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_GroupKick class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_GroupKick__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_ServerState

@implementation NetworkAPI_ServerState

@dynamic localIp;
@dynamic publicIp;
@dynamic port;

typedef struct NetworkAPI_ServerState__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  NSString *localIp;
  NSString *publicIp;
} NetworkAPI_ServerState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "localIp",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_ServerState_FieldNumber_LocalIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_ServerState__storage_, localIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicIp",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_ServerState_FieldNumber_PublicIp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_ServerState__storage_, publicIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_ServerState_FieldNumber_Port,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkAPI_ServerState__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_ServerState class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_ServerState__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action

@implementation NetworkAPI_Action

@dynamic commandOneOfCase;
@dynamic clear_p;
@dynamic trigger;
@dynamic transport;
@dynamic prop;
@dynamic timer;
@dynamic message;
@dynamic macro;
@dynamic look;
@dynamic stage;
@dynamic status;
@dynamic statusResponse;

typedef struct NetworkAPI_Action__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Clear *clear_p;
  NetworkAPI_Action_API_Trigger *trigger;
  NetworkAPI_Action_API_Transport *transport;
  NetworkAPI_Action_API_Prop *prop;
  NetworkAPI_Action_API_Timer *timer;
  NetworkAPI_Action_API_Message *message;
  NetworkAPI_Action_API_Macro *macro;
  NetworkAPI_Action_API_Look *look;
  NetworkAPI_Action_API_Stage *stage;
  NetworkAPI_Action_API_Status *status;
  NetworkAPI_Action_API_StatusResponse *statusResponse;
} NetworkAPI_Action__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clear_p",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Clear),
        .number = NetworkAPI_Action_FieldNumber_Clear_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, clear_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trigger",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger),
        .number = NetworkAPI_Action_FieldNumber_Trigger,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, trigger),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transport",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport),
        .number = NetworkAPI_Action_FieldNumber_Transport,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, transport),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prop",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Prop),
        .number = NetworkAPI_Action_FieldNumber_Prop,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, prop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timer",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Timer),
        .number = NetworkAPI_Action_FieldNumber_Timer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, timer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Message),
        .number = NetworkAPI_Action_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "macro",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Macro),
        .number = NetworkAPI_Action_FieldNumber_Macro,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, macro),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "look",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Look),
        .number = NetworkAPI_Action_FieldNumber_Look,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, look),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stage",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage),
        .number = NetworkAPI_Action_FieldNumber_Stage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, stage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Status),
        .number = NetworkAPI_Action_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statusResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_StatusResponse),
        .number = NetworkAPI_Action_FieldNumber_StatusResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action__storage_, statusResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "command",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\007\200\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_ClearCommandOneOfCase(NetworkAPI_Action *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Clear

@implementation NetworkAPI_Action_API_Clear

@dynamic clearInfoOneOfCase;
@dynamic layer;
@dynamic groupIdentifier;

typedef struct NetworkAPI_Action_API_Clear__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Clear_Layer layer;
  NetworkAPI_IndexOrNameIdentifier *groupIdentifier;
} NetworkAPI_Action_API_Clear__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layer",
        .dataTypeSpecific.enumDescFunc = NetworkAPI_Action_API_Clear_Layer_EnumDescriptor,
        .number = NetworkAPI_Action_API_Clear_FieldNumber_Layer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Clear__storage_, layer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "groupIdentifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Clear_FieldNumber_GroupIdentifier,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Clear__storage_, groupIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Clear class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Clear__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "clearInfo",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NetworkAPI_Action_API_Clear_Layer_RawValue(NetworkAPI_Action_API_Clear *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Clear descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_Action_API_Clear_FieldNumber_Layer];
  return GPBGetMessageRawEnumField(message, field);
}

void SetNetworkAPI_Action_API_Clear_Layer_RawValue(NetworkAPI_Action_API_Clear *message, int32_t value) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Clear descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_Action_API_Clear_FieldNumber_Layer];
  GPBSetMessageRawEnumField(message, field, value);
}

void NetworkAPI_Action_API_Clear_ClearClearInfoOneOfCase(NetworkAPI_Action_API_Clear *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Clear descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum NetworkAPI_Action_API_Clear_Layer

GPBEnumDescriptor *NetworkAPI_Action_API_Clear_Layer_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LayerUnknown\000LayerVideoInput\000LayerMedia\000"
        "LayerPresentation\000LayerAnnouncement\000Laye"
        "rProp\000LayerMessage\000LayerAudio\000";
    static const int32_t values[] = {
        NetworkAPI_Action_API_Clear_Layer_LayerUnknown,
        NetworkAPI_Action_API_Clear_Layer_LayerVideoInput,
        NetworkAPI_Action_API_Clear_Layer_LayerMedia,
        NetworkAPI_Action_API_Clear_Layer_LayerPresentation,
        NetworkAPI_Action_API_Clear_Layer_LayerAnnouncement,
        NetworkAPI_Action_API_Clear_Layer_LayerProp,
        NetworkAPI_Action_API_Clear_Layer_LayerMessage,
        NetworkAPI_Action_API_Clear_Layer_LayerAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NetworkAPI_Action_API_Clear_Layer)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NetworkAPI_Action_API_Clear_Layer_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NetworkAPI_Action_API_Clear_Layer_IsValidValue(int32_t value__) {
  switch (value__) {
    case NetworkAPI_Action_API_Clear_Layer_LayerUnknown:
    case NetworkAPI_Action_API_Clear_Layer_LayerVideoInput:
    case NetworkAPI_Action_API_Clear_Layer_LayerMedia:
    case NetworkAPI_Action_API_Clear_Layer_LayerPresentation:
    case NetworkAPI_Action_API_Clear_Layer_LayerAnnouncement:
    case NetworkAPI_Action_API_Clear_Layer_LayerProp:
    case NetworkAPI_Action_API_Clear_Layer_LayerMessage:
    case NetworkAPI_Action_API_Clear_Layer_LayerAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NetworkAPI_Action_API_Trigger

@implementation NetworkAPI_Action_API_Trigger

@dynamic triggerDataOneOfCase;
@dynamic presentation;
@dynamic media;
@dynamic videoInput;
@dynamic audio;

typedef struct NetworkAPI_Action_API_Trigger__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Trigger_Presentation *presentation;
  NetworkAPI_Action_API_Trigger_Media *media;
  NetworkAPI_Action_API_Trigger_VideoInput *videoInput;
  NetworkAPI_Action_API_Trigger_Audio *audio;
} NetworkAPI_Action_API_Trigger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "presentation",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_Presentation),
        .number = NetworkAPI_Action_API_Trigger_FieldNumber_Presentation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger__storage_, presentation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_Media),
        .number = NetworkAPI_Action_API_Trigger_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoInput",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_VideoInput),
        .number = NetworkAPI_Action_API_Trigger_FieldNumber_VideoInput,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger__storage_, videoInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_Audio),
        .number = NetworkAPI_Action_API_Trigger_FieldNumber_Audio,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "triggerData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Trigger_ClearTriggerDataOneOfCase(NetworkAPI_Action_API_Trigger *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Trigger descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Trigger_Presentation

@implementation NetworkAPI_Action_API_Trigger_Presentation

@dynamic presentationSourceOneOfCase;
@dynamic cueIndex;
@dynamic playlistIndexPath;
@dynamic libraryIndexPath;

typedef struct NetworkAPI_Action_API_Trigger_Presentation__storage_ {
  uint32_t _has_storage_[2];
  int32_t cueIndex;
  NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation *playlistIndexPath;
  NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation *libraryIndexPath;
} NetworkAPI_Action_API_Trigger_Presentation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cueIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Action_API_Trigger_Presentation_FieldNumber_CueIndex,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation__storage_, cueIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "playlistIndexPath",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation),
        .number = NetworkAPI_Action_API_Trigger_Presentation_FieldNumber_PlaylistIndexPath,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation__storage_, playlistIndexPath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "libraryIndexPath",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation),
        .number = NetworkAPI_Action_API_Trigger_Presentation_FieldNumber_LibraryIndexPath,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation__storage_, libraryIndexPath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_Presentation class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_Presentation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "presentationSource",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Trigger_Presentation_ClearPresentationSourceOneOfCase(NetworkAPI_Action_API_Trigger_Presentation *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Trigger_Presentation descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation

@implementation NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation

@dynamic indexPathComponentsArray, indexPathComponentsArray_Count;

typedef struct NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *indexPathComponentsArray;
} NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indexPathComponentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation_FieldNumber_IndexPathComponentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation__storage_, indexPathComponentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_Presentation_PlaylistPresentation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger_Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation

@implementation NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation

@dynamic hasLibraryComponent, libraryComponent;
@dynamic hasPresentationComponent, presentationComponent;
@dynamic hasCueComponent, cueComponent;

typedef struct NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *libraryComponent;
  NetworkAPI_IndexOrNameIdentifier *presentationComponent;
  NetworkAPI_IndexOrNameIdentifier *cueComponent;
} NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "libraryComponent",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation_FieldNumber_LibraryComponent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_, libraryComponent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "presentationComponent",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation_FieldNumber_PresentationComponent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_, presentationComponent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cueComponent",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation_FieldNumber_CueComponent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_, cueComponent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_Presentation_LibraryPresentation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger_Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Trigger_Media

@implementation NetworkAPI_Action_API_Trigger_Media

@dynamic indexPathComponentsArray, indexPathComponentsArray_Count;

typedef struct NetworkAPI_Action_API_Trigger_Media__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *indexPathComponentsArray;
} NetworkAPI_Action_API_Trigger_Media__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indexPathComponentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Media_FieldNumber_IndexPathComponentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Media__storage_, indexPathComponentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_Media class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_Media__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Trigger_VideoInput

@implementation NetworkAPI_Action_API_Trigger_VideoInput

@dynamic hasVideoInputId, videoInputId;

typedef struct NetworkAPI_Action_API_Trigger_VideoInput__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *videoInputId;
} NetworkAPI_Action_API_Trigger_VideoInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoInputId",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_VideoInput_FieldNumber_VideoInputId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_VideoInput__storage_, videoInputId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_VideoInput class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_VideoInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Trigger_Audio

@implementation NetworkAPI_Action_API_Trigger_Audio

@dynamic indexPathComponentsArray, indexPathComponentsArray_Count;

typedef struct NetworkAPI_Action_API_Trigger_Audio__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *indexPathComponentsArray;
} NetworkAPI_Action_API_Trigger_Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indexPathComponentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Trigger_Audio_FieldNumber_IndexPathComponentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Trigger_Audio__storage_, indexPathComponentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Trigger_Audio class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Trigger_Audio__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Trigger)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Transport

@implementation NetworkAPI_Action_API_Transport

@dynamic transportActionOneOfCase;
@dynamic layer;
@dynamic play;
@dynamic pause;
@dynamic skipBackward;
@dynamic skipForward;
@dynamic goToEnd;

typedef struct NetworkAPI_Action_API_Transport__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Transport_TransportLayer layer;
  NetworkAPI_Action_API_Transport_Play *play;
  NetworkAPI_Action_API_Transport_Pause *pause;
  NetworkAPI_Action_API_Transport_SkipBackward *skipBackward;
  NetworkAPI_Action_API_Transport_SkipForward *skipForward;
  NetworkAPI_Action_API_Transport_GoToEnd *goToEnd;
} NetworkAPI_Action_API_Transport__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layer",
        .dataTypeSpecific.enumDescFunc = NetworkAPI_Action_API_Transport_TransportLayer_EnumDescriptor,
        .number = NetworkAPI_Action_API_Transport_FieldNumber_Layer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, layer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "play",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport_Play),
        .number = NetworkAPI_Action_API_Transport_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pause",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport_Pause),
        .number = NetworkAPI_Action_API_Transport_FieldNumber_Pause,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, pause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skipBackward",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport_SkipBackward),
        .number = NetworkAPI_Action_API_Transport_FieldNumber_SkipBackward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, skipBackward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "skipForward",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport_SkipForward),
        .number = NetworkAPI_Action_API_Transport_FieldNumber_SkipForward,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, skipForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goToEnd",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Transport_GoToEnd),
        .number = NetworkAPI_Action_API_Transport_FieldNumber_GoToEnd,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport__storage_, goToEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "transportAction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NetworkAPI_Action_API_Transport_Layer_RawValue(NetworkAPI_Action_API_Transport *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Transport descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_Action_API_Transport_FieldNumber_Layer];
  return GPBGetMessageRawEnumField(message, field);
}

void SetNetworkAPI_Action_API_Transport_Layer_RawValue(NetworkAPI_Action_API_Transport *message, int32_t value) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Transport descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NetworkAPI_Action_API_Transport_FieldNumber_Layer];
  GPBSetMessageRawEnumField(message, field, value);
}

void NetworkAPI_Action_API_Transport_ClearTransportActionOneOfCase(NetworkAPI_Action_API_Transport *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Transport descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum NetworkAPI_Action_API_Transport_TransportLayer

GPBEnumDescriptor *NetworkAPI_Action_API_Transport_TransportLayer_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TransportLayerUnknown\000TransportLayerPres"
        "entation\000TransportLayerAnnouncement\000Tran"
        "sportLayerAudio\000";
    static const int32_t values[] = {
        NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerUnknown,
        NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerPresentation,
        NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerAnnouncement,
        NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NetworkAPI_Action_API_Transport_TransportLayer)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NetworkAPI_Action_API_Transport_TransportLayer_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NetworkAPI_Action_API_Transport_TransportLayer_IsValidValue(int32_t value__) {
  switch (value__) {
    case NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerUnknown:
    case NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerPresentation:
    case NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerAnnouncement:
    case NetworkAPI_Action_API_Transport_TransportLayer_TransportLayerAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NetworkAPI_Action_API_Transport_Play

@implementation NetworkAPI_Action_API_Transport_Play


typedef struct NetworkAPI_Action_API_Transport_Play__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_API_Transport_Play__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport_Play class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport_Play__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Transport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Transport_Pause

@implementation NetworkAPI_Action_API_Transport_Pause


typedef struct NetworkAPI_Action_API_Transport_Pause__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_API_Transport_Pause__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport_Pause class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport_Pause__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Transport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Transport_SkipBackward

@implementation NetworkAPI_Action_API_Transport_SkipBackward

@dynamic seconds;

typedef struct NetworkAPI_Action_API_Transport_SkipBackward__storage_ {
  uint32_t _has_storage_[1];
  int32_t seconds;
} NetworkAPI_Action_API_Transport_SkipBackward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seconds",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Action_API_Transport_SkipBackward_FieldNumber_Seconds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport_SkipBackward__storage_, seconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport_SkipBackward class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport_SkipBackward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Transport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Transport_SkipForward

@implementation NetworkAPI_Action_API_Transport_SkipForward

@dynamic seconds;

typedef struct NetworkAPI_Action_API_Transport_SkipForward__storage_ {
  uint32_t _has_storage_[1];
  int32_t seconds;
} NetworkAPI_Action_API_Transport_SkipForward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seconds",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Action_API_Transport_SkipForward_FieldNumber_Seconds,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport_SkipForward__storage_, seconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport_SkipForward class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport_SkipForward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Transport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Transport_GoToEnd

@implementation NetworkAPI_Action_API_Transport_GoToEnd

@dynamic secondsToEnd;

typedef struct NetworkAPI_Action_API_Transport_GoToEnd__storage_ {
  uint32_t _has_storage_[1];
  int32_t secondsToEnd;
} NetworkAPI_Action_API_Transport_GoToEnd__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "secondsToEnd",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Action_API_Transport_GoToEnd_FieldNumber_SecondsToEnd,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Transport_GoToEnd__storage_, secondsToEnd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Transport_GoToEnd class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Transport_GoToEnd__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Transport)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Prop

@implementation NetworkAPI_Action_API_Prop

@dynamic propActionOneOfCase;
@dynamic trigger;
@dynamic clear_p;

typedef struct NetworkAPI_Action_API_Prop__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Prop_TriggerProp *trigger;
  NetworkAPI_Action_API_Prop_ClearProp *clear_p;
} NetworkAPI_Action_API_Prop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trigger",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Prop_TriggerProp),
        .number = NetworkAPI_Action_API_Prop_FieldNumber_Trigger,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Prop__storage_, trigger),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clear_p",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Prop_ClearProp),
        .number = NetworkAPI_Action_API_Prop_FieldNumber_Clear_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Prop__storage_, clear_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Prop class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Prop__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "propAction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Prop_ClearPropActionOneOfCase(NetworkAPI_Action_API_Prop *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Prop descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Prop_TriggerProp

@implementation NetworkAPI_Action_API_Prop_TriggerProp

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Prop_TriggerProp__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Prop_TriggerProp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Prop_TriggerProp_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Prop_TriggerProp__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Prop_TriggerProp class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Prop_TriggerProp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Prop)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Prop_ClearProp

@implementation NetworkAPI_Action_API_Prop_ClearProp

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Prop_ClearProp__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Prop_ClearProp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Prop_ClearProp_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Prop_ClearProp__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Prop_ClearProp class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Prop_ClearProp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Prop)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Timer

@implementation NetworkAPI_Action_API_Timer

@dynamic timerActionOneOfCase;
@dynamic start;
@dynamic stop;
@dynamic reset;
@dynamic configure;

typedef struct NetworkAPI_Action_API_Timer__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Timer_StartTimer *start;
  NetworkAPI_Action_API_Timer_StopTimer *stop;
  NetworkAPI_Action_API_Timer_ResetTimer *reset;
  NetworkAPI_Action_API_Timer_ConfigureTimer *configure;
} NetworkAPI_Action_API_Timer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Timer_StartTimer),
        .number = NetworkAPI_Action_API_Timer_FieldNumber_Start,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stop",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Timer_StopTimer),
        .number = NetworkAPI_Action_API_Timer_FieldNumber_Stop,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer__storage_, stop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reset",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Timer_ResetTimer),
        .number = NetworkAPI_Action_API_Timer_FieldNumber_Reset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer__storage_, reset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configure",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Timer_ConfigureTimer),
        .number = NetworkAPI_Action_API_Timer_FieldNumber_Configure,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer__storage_, configure),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Timer class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Timer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "timerAction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Timer_ClearTimerActionOneOfCase(NetworkAPI_Action_API_Timer *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Timer descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Timer_StartTimer

@implementation NetworkAPI_Action_API_Timer_StartTimer

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Timer_StartTimer__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Timer_StartTimer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Timer_StartTimer_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer_StartTimer__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Timer_StartTimer class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Timer_StartTimer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Timer)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Timer_StopTimer

@implementation NetworkAPI_Action_API_Timer_StopTimer

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Timer_StopTimer__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Timer_StopTimer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Timer_StopTimer_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer_StopTimer__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Timer_StopTimer class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Timer_StopTimer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Timer)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Timer_ResetTimer

@implementation NetworkAPI_Action_API_Timer_ResetTimer

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Timer_ResetTimer__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Timer_ResetTimer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Timer_ResetTimer_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer_ResetTimer__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Timer_ResetTimer class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Timer_ResetTimer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Timer)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Timer_ConfigureTimer

@implementation NetworkAPI_Action_API_Timer_ConfigureTimer

@dynamic hasIdentifier, identifier;
@dynamic hasConfiguration, configuration;

typedef struct NetworkAPI_Action_API_Timer_ConfigureTimer__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
  Timer_Configuration *configuration;
} NetworkAPI_Action_API_Timer_ConfigureTimer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Timer_ConfigureTimer_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer_ConfigureTimer__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configuration",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Configuration),
        .number = NetworkAPI_Action_API_Timer_ConfigureTimer_FieldNumber_Configuration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Timer_ConfigureTimer__storage_, configuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Timer_ConfigureTimer class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Timer_ConfigureTimer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Timer)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Message

@implementation NetworkAPI_Action_API_Message

@dynamic messageActionOneOfCase;
@dynamic trigger;
@dynamic clear_p;

typedef struct NetworkAPI_Action_API_Message__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Message_TriggerMessage *trigger;
  NetworkAPI_Action_API_Message_ClearMessage *clear_p;
} NetworkAPI_Action_API_Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trigger",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Message_TriggerMessage),
        .number = NetworkAPI_Action_API_Message_FieldNumber_Trigger,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Message__storage_, trigger),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clear_p",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Message_ClearMessage),
        .number = NetworkAPI_Action_API_Message_FieldNumber_Clear_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Message__storage_, clear_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Message class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Message__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "messageAction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Message_ClearMessageActionOneOfCase(NetworkAPI_Action_API_Message *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Message_TriggerMessage

@implementation NetworkAPI_Action_API_Message_TriggerMessage

@dynamic hasIdentifier, identifier;
@dynamic tokenValuesArray, tokenValuesArray_Count;

typedef struct NetworkAPI_Action_API_Message_TriggerMessage__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
  NSMutableArray *tokenValuesArray;
} NetworkAPI_Action_API_Message_TriggerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Message_TriggerMessage_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Message_TriggerMessage__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tokenValuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Message_TokenValue),
        .number = NetworkAPI_Action_API_Message_TriggerMessage_FieldNumber_TokenValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Message_TriggerMessage__storage_, tokenValuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Message_TriggerMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Message_TriggerMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Message)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Message_ClearMessage

@implementation NetworkAPI_Action_API_Message_ClearMessage

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Message_ClearMessage__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Message_ClearMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Message_ClearMessage_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Message_ClearMessage__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Message_ClearMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Message_ClearMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Message)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Macro

@implementation NetworkAPI_Action_API_Macro

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Macro__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Macro__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Macro_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Macro__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Macro class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Macro__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Look

@implementation NetworkAPI_Action_API_Look

@dynamic hasIdentifier, identifier;

typedef struct NetworkAPI_Action_API_Look__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *identifier;
} NetworkAPI_Action_API_Look__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_Action_API_Look_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Look__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Look class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Look__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Stage

@implementation NetworkAPI_Action_API_Stage

@dynamic stageActionOneOfCase;
@dynamic layouts;
@dynamic message;

typedef struct NetworkAPI_Action_API_Stage__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Stage_StageLayouts *layouts;
  NetworkAPI_Action_API_Stage_StageMessage *message;
} NetworkAPI_Action_API_Stage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layouts",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage_StageLayouts),
        .number = NetworkAPI_Action_API_Stage_FieldNumber_Layouts,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage__storage_, layouts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage),
        .number = NetworkAPI_Action_API_Stage_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "stageAction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Stage_ClearStageActionOneOfCase(NetworkAPI_Action_API_Stage *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Stage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Stage_StageLayouts

@implementation NetworkAPI_Action_API_Stage_StageLayouts

@dynamic layoutsArray, layoutsArray_Count;

typedef struct NetworkAPI_Action_API_Stage_StageLayouts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *layoutsArray;
} NetworkAPI_Action_API_Stage_StageLayouts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layoutsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifierPair),
        .number = NetworkAPI_Action_API_Stage_StageLayouts_FieldNumber_LayoutsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage_StageLayouts__storage_, layoutsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage_StageLayouts class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage_StageLayouts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Stage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Stage_StageMessage

@implementation NetworkAPI_Action_API_Stage_StageMessage

@dynamic actionOneOfCase;
@dynamic showMessage;
@dynamic clearMessage;
@dynamic hideMessage;

typedef struct NetworkAPI_Action_API_Stage_StageMessage__storage_ {
  uint32_t _has_storage_[2];
  NetworkAPI_Action_API_Stage_StageMessage_ShowMessage *showMessage;
  NetworkAPI_Action_API_Stage_StageMessage_ClearMessage *clearMessage;
  NetworkAPI_Action_API_Stage_StageMessage_HideMessage *hideMessage;
} NetworkAPI_Action_API_Stage_StageMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage_ShowMessage),
        .number = NetworkAPI_Action_API_Stage_StageMessage_FieldNumber_ShowMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage_StageMessage__storage_, showMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clearMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage_ClearMessage),
        .number = NetworkAPI_Action_API_Stage_StageMessage_FieldNumber_ClearMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage_StageMessage__storage_, clearMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hideMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage_HideMessage),
        .number = NetworkAPI_Action_API_Stage_StageMessage_FieldNumber_HideMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage_StageMessage__storage_, hideMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage_StageMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage_StageMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "action",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Stage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_Action_API_Stage_StageMessage_ClearActionOneOfCase(NetworkAPI_Action_API_Stage_StageMessage *message) {
  GPBDescriptor *descriptor = [NetworkAPI_Action_API_Stage_StageMessage descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_Action_API_Stage_StageMessage_ShowMessage

@implementation NetworkAPI_Action_API_Stage_StageMessage_ShowMessage

@dynamic message;

typedef struct NetworkAPI_Action_API_Stage_StageMessage_ShowMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} NetworkAPI_Action_API_Stage_StageMessage_ShowMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_Action_API_Stage_StageMessage_ShowMessage_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_Stage_StageMessage_ShowMessage__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage_StageMessage_ShowMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage_StageMessage_ShowMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Stage_StageMessage_ClearMessage

@implementation NetworkAPI_Action_API_Stage_StageMessage_ClearMessage


typedef struct NetworkAPI_Action_API_Stage_StageMessage_ClearMessage__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_API_Stage_StageMessage_ClearMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage_StageMessage_ClearMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage_StageMessage_ClearMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Stage_StageMessage_HideMessage

@implementation NetworkAPI_Action_API_Stage_StageMessage_HideMessage


typedef struct NetworkAPI_Action_API_Stage_StageMessage_HideMessage__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_API_Stage_StageMessage_HideMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Stage_StageMessage_HideMessage class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_API_Stage_StageMessage_HideMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action_API_Stage_StageMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_StatusRequest

@implementation NetworkAPI_Action_StatusRequest


typedef struct NetworkAPI_Action_StatusRequest__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_StatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_StatusRequest class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_StatusRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_Status

@implementation NetworkAPI_Action_API_Status


typedef struct NetworkAPI_Action_API_Status__storage_ {
  uint32_t _has_storage_[1];
} NetworkAPI_Action_API_Status__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_Status class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkAPI_Action_API_Status__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_Action_API_StatusResponse

@implementation NetworkAPI_Action_API_StatusResponse

@dynamic hasGroupDefinition, groupDefinition;
@dynamic hasStatus, status;

typedef struct NetworkAPI_Action_API_StatusResponse__storage_ {
  uint32_t _has_storage_[1];
  ProLink_GroupDefinition *groupDefinition;
  ProLink_MemberStatus *status;
} NetworkAPI_Action_API_StatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupDefinition",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_GroupDefinition),
        .number = NetworkAPI_Action_API_StatusResponse_FieldNumber_GroupDefinition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_StatusResponse__storage_, groupDefinition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = GPBObjCClass(ProLink_MemberStatus),
        .number = NetworkAPI_Action_API_StatusResponse_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_Action_API_StatusResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_Action_API_StatusResponse class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_Action_API_StatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI_Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkAPI_IndexOrNameIdentifier

@implementation NetworkAPI_IndexOrNameIdentifier

@dynamic componentOneOfCase;
@dynamic index;
@dynamic name;

typedef struct NetworkAPI_IndexOrNameIdentifier__storage_ {
  uint32_t _has_storage_[2];
  int32_t index;
  NSString *name;
} NetworkAPI_IndexOrNameIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_IndexOrNameIdentifier_FieldNumber_Index,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_IndexOrNameIdentifier__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = NetworkAPI_IndexOrNameIdentifier_FieldNumber_Name,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NetworkAPI_IndexOrNameIdentifier__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_IndexOrNameIdentifier class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_IndexOrNameIdentifier__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "component",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NetworkAPI_IndexOrNameIdentifier_ClearComponentOneOfCase(NetworkAPI_IndexOrNameIdentifier *message) {
  GPBDescriptor *descriptor = [NetworkAPI_IndexOrNameIdentifier descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - NetworkAPI_IndexOrNameIdentifierPair

@implementation NetworkAPI_IndexOrNameIdentifierPair

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct NetworkAPI_IndexOrNameIdentifierPair__storage_ {
  uint32_t _has_storage_[1];
  NetworkAPI_IndexOrNameIdentifier *key;
  NetworkAPI_IndexOrNameIdentifier *value;
} NetworkAPI_IndexOrNameIdentifierPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_IndexOrNameIdentifierPair_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkAPI_IndexOrNameIdentifierPair__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(NetworkAPI_IndexOrNameIdentifier),
        .number = NetworkAPI_IndexOrNameIdentifierPair_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkAPI_IndexOrNameIdentifierPair__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkAPI_IndexOrNameIdentifierPair class]
                                     rootClass:[ProApiRoot class]
                                          file:ProApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkAPI_IndexOrNameIdentifierPair__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(NetworkAPI)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
