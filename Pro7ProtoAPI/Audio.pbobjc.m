// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Audio.pbobjc.h"
#import "BasicTypes.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Audio);
GPBObjCClassDeclaration(Audio_Device);
GPBObjCClassDeclaration(Audio_Device_Format);
GPBObjCClassDeclaration(Audio_LogicalChannel);
GPBObjCClassDeclaration(Audio_LogicalChannel_OutputChannel);
GPBObjCClassDeclaration(Audio_OutputSetup);
GPBObjCClassDeclaration(Audio_PhysicalChannel);
GPBObjCClassDeclaration(UUID);

#pragma mark - AudioRoot

@implementation AudioRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - AudioRoot_FileDescriptor

static GPBFileDescriptor *AudioRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Audio

@implementation Audio


typedef struct Audio__storage_ {
  uint32_t _has_storage_[1];
} Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Audio__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_SettingsDocument

@implementation Audio_SettingsDocument

@dynamic hasOutputSetup, outputSetup;
@dynamic hasMonitorDevice, monitorDevice;
@dynamic monitorOnMains;

typedef struct Audio_SettingsDocument__storage_ {
  uint32_t _has_storage_[1];
  Audio_OutputSetup *outputSetup;
  Audio_Device *monitorDevice;
} Audio_SettingsDocument__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputSetup",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_OutputSetup),
        .number = Audio_SettingsDocument_FieldNumber_OutputSetup,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_SettingsDocument__storage_, outputSetup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "monitorDevice",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_Device),
        .number = Audio_SettingsDocument_FieldNumber_MonitorDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Audio_SettingsDocument__storage_, monitorDevice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "monitorOnMains",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_SettingsDocument_FieldNumber_MonitorOnMains,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_SettingsDocument class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_SettingsDocument__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_OutputSetup

@implementation Audio_OutputSetup

@dynamic hasUuid, uuid;
@dynamic hasAudioDevice, audioDevice;
@dynamic logicalChannelsArray, logicalChannelsArray_Count;
@dynamic audioDelay;
@dynamic masterLevel;
@dynamic physicalChanelsArray, physicalChanelsArray_Count;

typedef struct Audio_OutputSetup__storage_ {
  uint32_t _has_storage_[1];
  UUID *uuid;
  Audio_Device *audioDevice;
  NSMutableArray *logicalChannelsArray;
  NSMutableArray *physicalChanelsArray;
  double audioDelay;
  double masterLevel;
} Audio_OutputSetup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Audio_OutputSetup_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioDevice",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_Device),
        .number = Audio_OutputSetup_FieldNumber_AudioDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, audioDevice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logicalChannelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_LogicalChannel),
        .number = Audio_OutputSetup_FieldNumber_LogicalChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, logicalChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioDelay",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_OutputSetup_FieldNumber_AudioDelay,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, audioDelay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "masterLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_OutputSetup_FieldNumber_MasterLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, masterLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "physicalChanelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_PhysicalChannel),
        .number = Audio_OutputSetup_FieldNumber_PhysicalChanelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Audio_OutputSetup__storage_, physicalChanelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_OutputSetup class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_OutputSetup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_Device

@implementation Audio_Device

@dynamic name;
@dynamic renderId;
@dynamic inputChannelCount;
@dynamic outputChannelCount;
@dynamic formatsArray, formatsArray_Count;

typedef struct Audio_Device__storage_ {
  uint32_t _has_storage_[1];
  uint32_t inputChannelCount;
  uint32_t outputChannelCount;
  NSString *name;
  NSString *renderId;
  NSMutableArray *formatsArray;
} Audio_Device__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_Device__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "renderId",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_FieldNumber_RenderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Audio_Device__storage_, renderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputChannelCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_FieldNumber_InputChannelCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Audio_Device__storage_, inputChannelCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "outputChannelCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_FieldNumber_OutputChannelCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Audio_Device__storage_, outputChannelCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "formatsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_Device_Format),
        .number = Audio_Device_FieldNumber_FormatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Audio_Device__storage_, formatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_Device class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_Device__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_Device_Format

@implementation Audio_Device_Format

@dynamic sampleRate;
@dynamic bitDepth;
@dynamic type;

typedef struct Audio_Device_Format__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sampleRate;
  uint32_t bitDepth;
  Audio_Device_Format_Type type;
} Audio_Device_Format__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_Format_FieldNumber_SampleRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_Device_Format__storage_, sampleRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitDepth",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_Device_Format_FieldNumber_BitDepth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Audio_Device_Format__storage_, bitDepth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Audio_Device_Format_Type_EnumDescriptor,
        .number = Audio_Device_Format_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Audio_Device_Format__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_Device_Format class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_Device_Format__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio_Device)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Audio_Device_Format_Type_RawValue(Audio_Device_Format *message) {
  GPBDescriptor *descriptor = [Audio_Device_Format descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Audio_Device_Format_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAudio_Device_Format_Type_RawValue(Audio_Device_Format *message, int32_t value) {
  GPBDescriptor *descriptor = [Audio_Device_Format descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Audio_Device_Format_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Audio_Device_Format_Type

GPBEnumDescriptor *Audio_Device_Format_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeInt\000TypeFloat\000";
    static const int32_t values[] = {
        Audio_Device_Format_Type_TypeInt,
        Audio_Device_Format_Type_TypeFloat,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Audio_Device_Format_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Audio_Device_Format_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Audio_Device_Format_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Audio_Device_Format_Type_TypeInt:
    case Audio_Device_Format_Type_TypeFloat:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Audio_LogicalChannel

@implementation Audio_LogicalChannel

@dynamic hasUuid, uuid;
@dynamic name;
@dynamic index;
@dynamic muted;
@dynamic physicalAudioChannelsArray, physicalAudioChannelsArray_Count;
@dynamic solo;
@dynamic testTone;

typedef struct Audio_LogicalChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  UUID *uuid;
  NSString *name;
  NSMutableArray *physicalAudioChannelsArray;
} Audio_LogicalChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Audio_LogicalChannel_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_LogicalChannel__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Audio_LogicalChannel__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Audio_LogicalChannel__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "muted",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_FieldNumber_Muted,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "physicalAudioChannelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Audio_LogicalChannel_OutputChannel),
        .number = Audio_LogicalChannel_FieldNumber_PhysicalAudioChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Audio_LogicalChannel__storage_, physicalAudioChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "solo",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_FieldNumber_Solo,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "testTone",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_FieldNumber_TestTone,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_LogicalChannel class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_LogicalChannel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_LogicalChannel_OutputChannel

@implementation Audio_LogicalChannel_OutputChannel

@dynamic index;
@dynamic muted;
@dynamic solo;
@dynamic testTone;

typedef struct Audio_LogicalChannel_OutputChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
} Audio_LogicalChannel_OutputChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_OutputChannel_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_LogicalChannel_OutputChannel__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "muted",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_OutputChannel_FieldNumber_Muted,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "solo",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_OutputChannel_FieldNumber_Solo,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "testTone",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_LogicalChannel_OutputChannel_FieldNumber_TestTone,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_LogicalChannel_OutputChannel class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_LogicalChannel_OutputChannel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio_LogicalChannel)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Audio_PhysicalChannel

@implementation Audio_PhysicalChannel

@dynamic index;
@dynamic muteEnable;
@dynamic soloEnable;
@dynamic toneEnable;

typedef struct Audio_PhysicalChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
} Audio_PhysicalChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_PhysicalChannel_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Audio_PhysicalChannel__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "muteEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_PhysicalChannel_FieldNumber_MuteEnable,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "soloEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_PhysicalChannel_FieldNumber_SoloEnable,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "toneEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Audio_PhysicalChannel_FieldNumber_ToneEnable,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Audio_PhysicalChannel class]
                                     rootClass:[AudioRoot class]
                                          file:AudioRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Audio_PhysicalChannel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
