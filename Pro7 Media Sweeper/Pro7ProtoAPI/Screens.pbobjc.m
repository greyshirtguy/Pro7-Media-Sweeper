// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: screens.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Screens.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "GraphicsData.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(CornerValues);
GPBObjCClassDeclaration(DisplayMode);
GPBObjCClassDeclaration(EdgeBlend);
GPBObjCClassDeclaration(EdgeBlend_Screen);
GPBObjCClassDeclaration(Graphics_Point);
GPBObjCClassDeclaration(Graphics_Rect);
GPBObjCClassDeclaration(OutputDisplay);
GPBObjCClassDeclaration(OutputDisplay_BlackmagicAlphaKeySettings);
GPBObjCClassDeclaration(Screen);
GPBObjCClassDeclaration(Screen_BlendCompensation);
GPBObjCClassDeclaration(Screen_ColorAdjustment);
GPBObjCClassDeclaration(UUID);

#pragma mark - ScreensRoot

@implementation ScreensRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ScreensRoot_FileDescriptor

static GPBFileDescriptor *ScreensRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Screen

@implementation Screen

@dynamic hasUuid, uuid;
@dynamic name;
@dynamic hasColor, color;
@dynamic hasBounds, bounds;
@dynamic aspectRatioLocked;
@dynamic outputBoundsAspectRatioLocked;
@dynamic cornerPinningEnabled;
@dynamic hasSubscreenUnitRect, subscreenUnitRect;
@dynamic rotation;
@dynamic gamma;
@dynamic blackLevel;
@dynamic blendedEdges;
@dynamic hasCornerValues, cornerValues;
@dynamic hasOutputDisplay, outputDisplay;
@dynamic colorEnabled;
@dynamic hasColorAdjustment, colorAdjustment;
@dynamic hasBlendCompensation, blendCompensation;

typedef struct Screen__storage_ {
  uint32_t _has_storage_[1];
  uint32_t blendedEdges;
  UUID *uuid;
  NSString *name;
  Color *color;
  Graphics_Rect *bounds;
  Graphics_Rect *subscreenUnitRect;
  CornerValues *cornerValues;
  OutputDisplay *outputDisplay;
  Screen_ColorAdjustment *colorAdjustment;
  Screen_BlendCompensation *blendCompensation;
  double rotation;
  double gamma;
  double blackLevel;
} Screen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Screen_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Screen__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Screen__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Screen_FieldNumber_Color,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Screen__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Rect),
        .number = Screen_FieldNumber_Bounds,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Screen__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aspectRatioLocked",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_AspectRatioLocked,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "outputBoundsAspectRatioLocked",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_OutputBoundsAspectRatioLocked,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cornerPinningEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_CornerPinningEnabled,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "subscreenUnitRect",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Rect),
        .number = Screen_FieldNumber_SubscreenUnitRect,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Screen__storage_, subscreenUnitRect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rotation",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_Rotation,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Screen__storage_, rotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gamma",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_Gamma,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Screen__storage_, gamma),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blackLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_BlackLevel,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Screen__storage_, blackLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blendedEdges",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_BlendedEdges,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Screen__storage_, blendedEdges),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cornerValues",
        .dataTypeSpecific.clazz = GPBObjCClass(CornerValues),
        .number = Screen_FieldNumber_CornerValues,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Screen__storage_, cornerValues),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputDisplay",
        .dataTypeSpecific.clazz = GPBObjCClass(OutputDisplay),
        .number = Screen_FieldNumber_OutputDisplay,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Screen__storage_, outputDisplay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "colorEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_FieldNumber_ColorEnabled,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "colorAdjustment",
        .dataTypeSpecific.clazz = GPBObjCClass(Screen_ColorAdjustment),
        .number = Screen_FieldNumber_ColorAdjustment,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Screen__storage_, colorAdjustment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blendCompensation",
        .dataTypeSpecific.clazz = GPBObjCClass(Screen_BlendCompensation),
        .number = Screen_FieldNumber_BlendCompensation,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Screen__storage_, blendCompensation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Screen class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Screen__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Screen_ColorAdjustment

@implementation Screen_ColorAdjustment

@dynamic gamma;
@dynamic blackLevel;
@dynamic redLevel;
@dynamic greenLevel;
@dynamic blueLevel;
@dynamic brightness;
@dynamic contrast;

typedef struct Screen_ColorAdjustment__storage_ {
  uint32_t _has_storage_[1];
  double gamma;
  double blackLevel;
  double redLevel;
  double greenLevel;
  double blueLevel;
  double brightness;
  double contrast;
} Screen_ColorAdjustment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gamma",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_Gamma,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, gamma),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blackLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_BlackLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, blackLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "redLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_RedLevel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, redLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "greenLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_GreenLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, greenLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blueLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_BlueLevel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, blueLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "brightness",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_Brightness,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, brightness),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "contrast",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_ColorAdjustment_FieldNumber_Contrast,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Screen_ColorAdjustment__storage_, contrast),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Screen_ColorAdjustment class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Screen_ColorAdjustment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Screen)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Screen_BlendCompensation

@implementation Screen_BlendCompensation

@dynamic blackLevel;

typedef struct Screen_BlendCompensation__storage_ {
  uint32_t _has_storage_[1];
  double blackLevel;
} Screen_BlendCompensation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blackLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Screen_BlendCompensation_FieldNumber_BlackLevel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Screen_BlendCompensation__storage_, blackLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Screen_BlendCompensation class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Screen_BlendCompensation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Screen)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CornerValues

@implementation CornerValues

@dynamic hasTopLeft, topLeft;
@dynamic hasTopRight, topRight;
@dynamic hasBottomLeft, bottomLeft;
@dynamic hasBottomRight, bottomRight;

typedef struct CornerValues__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Point *topLeft;
  Graphics_Point *topRight;
  Graphics_Point *bottomLeft;
  Graphics_Point *bottomRight;
} CornerValues__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topLeft",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = CornerValues_FieldNumber_TopLeft,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CornerValues__storage_, topLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topRight",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = CornerValues_FieldNumber_TopRight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CornerValues__storage_, topRight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bottomLeft",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = CornerValues_FieldNumber_BottomLeft,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CornerValues__storage_, bottomLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bottomRight",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = CornerValues_FieldNumber_BottomRight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CornerValues__storage_, bottomRight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CornerValues class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CornerValues__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisplayMode

@implementation DisplayMode

@dynamic name;
@dynamic width;
@dynamic height;
@dynamic refreshRate;
@dynamic interlaced;

typedef struct DisplayMode__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
  NSString *name;
  double refreshRate;
} DisplayMode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayMode_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisplayMode__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayMode_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisplayMode__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayMode_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DisplayMode__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "refreshRate",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayMode_FieldNumber_RefreshRate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DisplayMode__storage_, refreshRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "interlaced",
        .dataTypeSpecific.clazz = Nil,
        .number = DisplayMode_FieldNumber_Interlaced,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisplayMode class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisplayMode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OutputDisplay

@implementation OutputDisplay

@dynamic alphaKeySettingsOneOfCase;
@dynamic name;
@dynamic model;
@dynamic serial;
@dynamic deviceName;
@dynamic vendor;
@dynamic modeIndex;
@dynamic hasBounds, bounds;
@dynamic type;
@dynamic hasMode, mode;
@dynamic renderId;
@dynamic blackMagicAlphaKeySettings;

typedef struct OutputDisplay__storage_ {
  uint32_t _has_storage_[2];
  uint32_t modeIndex;
  OutputDisplay_Type type;
  NSString *name;
  NSString *model;
  NSString *serial;
  NSString *deviceName;
  NSString *vendor;
  Graphics_Rect *bounds;
  DisplayMode *mode;
  NSString *renderId;
  OutputDisplay_BlackmagicAlphaKeySettings *blackMagicAlphaKeySettings;
} OutputDisplay__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_Model,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, model),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serial",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_Serial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, serial),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_DeviceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vendor",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_Vendor,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, vendor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modeIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_ModeIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, modeIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Rect),
        .number = OutputDisplay_FieldNumber_Bounds,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = OutputDisplay_Type_EnumDescriptor,
        .number = OutputDisplay_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mode",
        .dataTypeSpecific.clazz = GPBObjCClass(DisplayMode),
        .number = OutputDisplay_FieldNumber_Mode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, mode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "renderId",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_FieldNumber_RenderId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, renderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blackMagicAlphaKeySettings",
        .dataTypeSpecific.clazz = GPBObjCClass(OutputDisplay_BlackmagicAlphaKeySettings),
        .number = OutputDisplay_FieldNumber_BlackMagicAlphaKeySettings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutputDisplay__storage_, blackMagicAlphaKeySettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutputDisplay class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutputDisplay__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "alphaKeySettings",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\n\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OutputDisplay_Type_RawValue(OutputDisplay *message) {
  GPBDescriptor *descriptor = [OutputDisplay descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutputDisplay_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOutputDisplay_Type_RawValue(OutputDisplay *message, int32_t value) {
  GPBDescriptor *descriptor = [OutputDisplay descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutputDisplay_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void OutputDisplay_ClearAlphaKeySettingsOneOfCase(OutputDisplay *message) {
  GPBDescriptor *descriptor = [OutputDisplay descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum OutputDisplay_Type

GPBEnumDescriptor *OutputDisplay_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeUnknown\000TypeScreen\000TypeCard\000TypeNdi\000"
        "TypeSyphon\000TypeCustom\000";
    static const int32_t values[] = {
        OutputDisplay_Type_TypeUnknown,
        OutputDisplay_Type_TypeScreen,
        OutputDisplay_Type_TypeCard,
        OutputDisplay_Type_TypeNdi,
        OutputDisplay_Type_TypeSyphon,
        OutputDisplay_Type_TypeCustom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OutputDisplay_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OutputDisplay_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OutputDisplay_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case OutputDisplay_Type_TypeUnknown:
    case OutputDisplay_Type_TypeScreen:
    case OutputDisplay_Type_TypeCard:
    case OutputDisplay_Type_TypeNdi:
    case OutputDisplay_Type_TypeSyphon:
    case OutputDisplay_Type_TypeCustom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - OutputDisplay_BlackmagicAlphaKeySettings

@implementation OutputDisplay_BlackmagicAlphaKeySettings

@dynamic enabled;
@dynamic keyMode;
@dynamic blendValue;

typedef struct OutputDisplay_BlackmagicAlphaKeySettings__storage_ {
  uint32_t _has_storage_[1];
  OutputDisplay_BlackmagicAlphaKeySettings_KeyMode keyMode;
  double blendValue;
} OutputDisplay_BlackmagicAlphaKeySettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enabled",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_BlackmagicAlphaKeySettings_FieldNumber_Enabled,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "keyMode",
        .dataTypeSpecific.enumDescFunc = OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_EnumDescriptor,
        .number = OutputDisplay_BlackmagicAlphaKeySettings_FieldNumber_KeyMode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OutputDisplay_BlackmagicAlphaKeySettings__storage_, keyMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blendValue",
        .dataTypeSpecific.clazz = Nil,
        .number = OutputDisplay_BlackmagicAlphaKeySettings_FieldNumber_BlendValue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OutputDisplay_BlackmagicAlphaKeySettings__storage_, blendValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutputDisplay_BlackmagicAlphaKeySettings class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutputDisplay_BlackmagicAlphaKeySettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(OutputDisplay)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_RawValue(OutputDisplay_BlackmagicAlphaKeySettings *message) {
  GPBDescriptor *descriptor = [OutputDisplay_BlackmagicAlphaKeySettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutputDisplay_BlackmagicAlphaKeySettings_FieldNumber_KeyMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOutputDisplay_BlackmagicAlphaKeySettings_KeyMode_RawValue(OutputDisplay_BlackmagicAlphaKeySettings *message, int32_t value) {
  GPBDescriptor *descriptor = [OutputDisplay_BlackmagicAlphaKeySettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutputDisplay_BlackmagicAlphaKeySettings_FieldNumber_KeyMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum OutputDisplay_BlackmagicAlphaKeySettings_KeyMode

GPBEnumDescriptor *OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "KeyModeInternal\000KeyModeExternal\000";
    static const int32_t values[] = {
        OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_KeyModeInternal,
        OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_KeyModeExternal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OutputDisplay_BlackmagicAlphaKeySettings_KeyMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_KeyModeInternal:
    case OutputDisplay_BlackmagicAlphaKeySettings_KeyMode_KeyModeExternal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EdgeBlend

@implementation EdgeBlend

@dynamic hasUuid, uuid;
@dynamic radius;
@dynamic intensity;
@dynamic mode;
@dynamic hasFirstScreen, firstScreen;
@dynamic hasSecondScreen, secondScreen;
@dynamic hasLeftScreen, leftScreen;
@dynamic hasRightScreen, rightScreen;
@dynamic hasTopScreen, topScreen;
@dynamic hasBottomScreen, bottomScreen;

typedef struct EdgeBlend__storage_ {
  uint32_t _has_storage_[1];
  EdgeBlend_Mode mode;
  UUID *uuid;
  EdgeBlend_Screen *firstScreen;
  EdgeBlend_Screen *secondScreen;
  EdgeBlend_Screen *leftScreen;
  EdgeBlend_Screen *rightScreen;
  EdgeBlend_Screen *topScreen;
  EdgeBlend_Screen *bottomScreen;
  double radius;
  double intensity;
} EdgeBlend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = EdgeBlend_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "radius",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_FieldNumber_Radius,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, radius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "intensity",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_FieldNumber_Intensity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, intensity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = EdgeBlend_Mode_EnumDescriptor,
        .number = EdgeBlend_FieldNumber_Mode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "firstScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_FirstScreen,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, firstScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secondScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_SecondScreen,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, secondScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leftScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_LeftScreen,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, leftScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rightScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_RightScreen,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, rightScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_TopScreen,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, topScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bottomScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(EdgeBlend_Screen),
        .number = EdgeBlend_FieldNumber_BottomScreen,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EdgeBlend__storage_, bottomScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EdgeBlend class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EdgeBlend__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EdgeBlend_Mode_RawValue(EdgeBlend *message) {
  GPBDescriptor *descriptor = [EdgeBlend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEdgeBlend_Mode_RawValue(EdgeBlend *message, int32_t value) {
  GPBDescriptor *descriptor = [EdgeBlend descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum EdgeBlend_Mode

GPBEnumDescriptor *EdgeBlend_Mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ModeLinear\000ModeCubic\000ModeQuadratic\000";
    static const int32_t values[] = {
        EdgeBlend_Mode_ModeLinear,
        EdgeBlend_Mode_ModeCubic,
        EdgeBlend_Mode_ModeQuadratic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EdgeBlend_Mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EdgeBlend_Mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EdgeBlend_Mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case EdgeBlend_Mode_ModeLinear:
    case EdgeBlend_Mode_ModeCubic:
    case EdgeBlend_Mode_ModeQuadratic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EdgeBlend_Screen

@implementation EdgeBlend_Screen

@dynamic hasUuid, uuid;
@dynamic edge;
@dynamic gamma;
@dynamic blackLevel;
@dynamic mode;
@dynamic radius;
@dynamic intensity;

typedef struct EdgeBlend_Screen__storage_ {
  uint32_t _has_storage_[1];
  EdgeBlend_Screen_Edge edge;
  EdgeBlend_Screen_Mode mode;
  UUID *uuid;
  double gamma;
  double blackLevel;
  double radius;
  double intensity;
} EdgeBlend_Screen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = EdgeBlend_Screen_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edge",
        .dataTypeSpecific.enumDescFunc = EdgeBlend_Screen_Edge_EnumDescriptor,
        .number = EdgeBlend_Screen_FieldNumber_Edge,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, edge),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "gamma",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_Screen_FieldNumber_Gamma,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, gamma),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blackLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_Screen_FieldNumber_BlackLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, blackLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = EdgeBlend_Screen_Mode_EnumDescriptor,
        .number = EdgeBlend_Screen_FieldNumber_Mode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "radius",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_Screen_FieldNumber_Radius,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, radius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "intensity",
        .dataTypeSpecific.clazz = Nil,
        .number = EdgeBlend_Screen_FieldNumber_Intensity,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EdgeBlend_Screen__storage_, intensity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EdgeBlend_Screen class]
                                     rootClass:[ScreensRoot class]
                                          file:ScreensRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EdgeBlend_Screen__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(EdgeBlend)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EdgeBlend_Screen_Edge_RawValue(EdgeBlend_Screen *message) {
  GPBDescriptor *descriptor = [EdgeBlend_Screen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_Screen_FieldNumber_Edge];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEdgeBlend_Screen_Edge_RawValue(EdgeBlend_Screen *message, int32_t value) {
  GPBDescriptor *descriptor = [EdgeBlend_Screen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_Screen_FieldNumber_Edge];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t EdgeBlend_Screen_Mode_RawValue(EdgeBlend_Screen *message) {
  GPBDescriptor *descriptor = [EdgeBlend_Screen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_Screen_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetEdgeBlend_Screen_Mode_RawValue(EdgeBlend_Screen *message, int32_t value) {
  GPBDescriptor *descriptor = [EdgeBlend_Screen descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EdgeBlend_Screen_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum EdgeBlend_Screen_Edge

GPBEnumDescriptor *EdgeBlend_Screen_Edge_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EdgeUnknown\000EdgeLeft\000EdgeRight\000EdgeTop\000E"
        "dgeBottom\000";
    static const int32_t values[] = {
        EdgeBlend_Screen_Edge_EdgeUnknown,
        EdgeBlend_Screen_Edge_EdgeLeft,
        EdgeBlend_Screen_Edge_EdgeRight,
        EdgeBlend_Screen_Edge_EdgeTop,
        EdgeBlend_Screen_Edge_EdgeBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EdgeBlend_Screen_Edge)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EdgeBlend_Screen_Edge_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EdgeBlend_Screen_Edge_IsValidValue(int32_t value__) {
  switch (value__) {
    case EdgeBlend_Screen_Edge_EdgeUnknown:
    case EdgeBlend_Screen_Edge_EdgeLeft:
    case EdgeBlend_Screen_Edge_EdgeRight:
    case EdgeBlend_Screen_Edge_EdgeTop:
    case EdgeBlend_Screen_Edge_EdgeBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EdgeBlend_Screen_Mode

GPBEnumDescriptor *EdgeBlend_Screen_Mode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ModeLinear\000ModeCubic\000ModeQuadratic\000";
    static const int32_t values[] = {
        EdgeBlend_Screen_Mode_ModeLinear,
        EdgeBlend_Screen_Mode_ModeCubic,
        EdgeBlend_Screen_Mode_ModeQuadratic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EdgeBlend_Screen_Mode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EdgeBlend_Screen_Mode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EdgeBlend_Screen_Mode_IsValidValue(int32_t value__) {
  switch (value__) {
    case EdgeBlend_Screen_Mode_ModeLinear:
    case EdgeBlend_Screen_Mode_ModeCubic:
    case EdgeBlend_Screen_Mode_ModeQuadratic:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
