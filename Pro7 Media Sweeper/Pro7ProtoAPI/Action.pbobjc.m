// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: action.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Action.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "Layers.pbobjc.h"
#import "Effects.pbobjc.h"
#import "GraphicsData.pbobjc.h"
#import "Background.pbobjc.h"
#import "Template.pbobjc.h"
#import "PresentationSlide.pbobjc.h"
#import "PropSlide.pbobjc.h"
#import "Timers.pbobjc.h"
#import "Messages.pbobjc.h"
#import "Stage.pbobjc.h"
#import "Input.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Action);
GPBObjCClassDeclaration(Action_AudienceLookType);
GPBObjCClassDeclaration(Action_AudioInputType);
GPBObjCClassDeclaration(Action_BackgroundType);
GPBObjCClassDeclaration(Action_BlendModeType);
GPBObjCClassDeclaration(Action_ClearGroupType);
GPBObjCClassDeclaration(Action_ClearType);
GPBObjCClassDeclaration(Action_CommunicationType);
GPBObjCClassDeclaration(Action_CommunicationType_Command);
GPBObjCClassDeclaration(Action_CommunicationType_GVG100Command);
GPBObjCClassDeclaration(Action_CommunicationType_GlobalCacheCommand);
GPBObjCClassDeclaration(Action_CommunicationType_MIDICommand);
GPBObjCClassDeclaration(Action_CommunicationType_SonyBVSCommand);
GPBObjCClassDeclaration(Action_DocumentType);
GPBObjCClassDeclaration(Action_DoubleType);
GPBObjCClassDeclaration(Action_EffectsType);
GPBObjCClassDeclaration(Action_ExternalPresentationType);
GPBObjCClassDeclaration(Action_Label);
GPBObjCClassDeclaration(Action_LayerIdentification);
GPBObjCClassDeclaration(Action_MacroType);
GPBObjCClassDeclaration(Action_MaskType);
GPBObjCClassDeclaration(Action_MediaType);
GPBObjCClassDeclaration(Action_MediaType_Audio);
GPBObjCClassDeclaration(Action_MediaType_Image);
GPBObjCClassDeclaration(Action_MediaType_LiveVideo);
GPBObjCClassDeclaration(Action_MediaType_Video);
GPBObjCClassDeclaration(Action_MessageType);
GPBObjCClassDeclaration(Action_MultiScreenType);
GPBObjCClassDeclaration(Action_OldType);
GPBObjCClassDeclaration(Action_PlaylistItemType);
GPBObjCClassDeclaration(Action_PropType);
GPBObjCClassDeclaration(Action_SlideDestinationType);
GPBObjCClassDeclaration(Action_SlideType);
GPBObjCClassDeclaration(Action_SocialMediaType);
GPBObjCClassDeclaration(Action_StageLayoutType);
GPBObjCClassDeclaration(Action_TimerType);
GPBObjCClassDeclaration(Action_TransitionType);
GPBObjCClassDeclaration(AudioInput_BehaviorMode);
GPBObjCClassDeclaration(Background);
GPBObjCClassDeclaration(CollectionElementType);
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(Effect);
GPBObjCClassDeclaration(IntRange);
GPBObjCClassDeclaration(Layer_Blending);
GPBObjCClassDeclaration(Media);
GPBObjCClassDeclaration(Message_TokenValue);
GPBObjCClassDeclaration(PresentationSlide);
GPBObjCClassDeclaration(PropSlide);
GPBObjCClassDeclaration(Stage_ScreenAssignment);
GPBObjCClassDeclaration(Template_Slide);
GPBObjCClassDeclaration(Timer_Configuration);
GPBObjCClassDeclaration(Transition);
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(UUID);

#pragma mark - ActionRoot

@implementation ActionRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ActionRoot_FileDescriptor

static GPBFileDescriptor *ActionRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Action

@implementation Action

@dynamic actionTypeDataOneOfCase;
@dynamic hasUuid, uuid;
@dynamic name;
@dynamic hasLabel, label;
@dynamic delayTime;
@dynamic hasOldType, oldType;
@dynamic isEnabled;
@dynamic hasLayerIdentification, layerIdentification;
@dynamic duration;
@dynamic type;
@dynamic collectionElement;
@dynamic playlistItem;
@dynamic blendMode;
@dynamic transition;
@dynamic media;
@dynamic doubleItem;
@dynamic effects;
@dynamic slide;
@dynamic background;
@dynamic timer;
@dynamic clear_p;
@dynamic stage;
@dynamic prop;
@dynamic mask;
@dynamic message;
@dynamic socialMedia;
@dynamic communication;
@dynamic multiScreen;
@dynamic presentationDocument;
@dynamic externalPresentation;
@dynamic audienceLook;
@dynamic audioInput;
@dynamic slideDestination;
@dynamic macro;
@dynamic clearGroup;

typedef struct Action__storage_ {
  uint32_t _has_storage_[2];
  Action_ActionType type;
  UUID *uuid;
  NSString *name;
  Action_Label *label;
  Action_OldType *oldType;
  Action_LayerIdentification *layerIdentification;
  CollectionElementType *collectionElement;
  Action_PlaylistItemType *playlistItem;
  Action_BlendModeType *blendMode;
  Action_TransitionType *transition;
  Action_MediaType *media;
  Action_DoubleType *doubleItem;
  Action_EffectsType *effects;
  Action_SlideType *slide;
  Action_BackgroundType *background;
  Action_TimerType *timer;
  Action_ClearType *clear_p;
  Action_StageLayoutType *stage;
  Action_PropType *prop;
  Action_MaskType *mask;
  Action_MessageType *message;
  Action_SocialMediaType *socialMedia;
  Action_CommunicationType *communication;
  Action_MultiScreenType *multiScreen;
  Action_DocumentType *presentationDocument;
  Action_ExternalPresentationType *externalPresentation;
  Action_AudienceLookType *audienceLook;
  Action_AudioInputType *audioInput;
  Action_SlideDestinationType *slideDestination;
  Action_MacroType *macro;
  Action_ClearGroupType *clearGroup;
  double delayTime;
  double duration;
} Action__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_Label),
        .number = Action_FieldNumber_Label,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "delayTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_FieldNumber_DelayTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action__storage_, delayTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "oldType",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_OldType),
        .number = Action_FieldNumber_OldType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Action__storage_, oldType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_FieldNumber_IsEnabled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "layerIdentification",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_LayerIdentification),
        .number = Action_FieldNumber_LayerIdentification,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Action__storage_, layerIdentification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_FieldNumber_Duration,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Action__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Action_ActionType_EnumDescriptor,
        .number = Action_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Action__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "collectionElement",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_FieldNumber_CollectionElement,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, collectionElement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playlistItem",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_PlaylistItemType),
        .number = Action_FieldNumber_PlaylistItem,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, playlistItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blendMode",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_BlendModeType),
        .number = Action_FieldNumber_BlendMode,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, blendMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transition",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_TransitionType),
        .number = Action_FieldNumber_Transition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MediaType),
        .number = Action_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "doubleItem",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_DoubleType),
        .number = Action_FieldNumber_DoubleItem,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, doubleItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effects",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_EffectsType),
        .number = Action_FieldNumber_Effects,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, effects),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slide",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_SlideType),
        .number = Action_FieldNumber_Slide,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, slide),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "background",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_BackgroundType),
        .number = Action_FieldNumber_Background,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, background),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timer",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_TimerType),
        .number = Action_FieldNumber_Timer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, timer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clear_p",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_ClearType),
        .number = Action_FieldNumber_Clear_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, clear_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stage",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_StageLayoutType),
        .number = Action_FieldNumber_Stage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, stage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prop",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_PropType),
        .number = Action_FieldNumber_Prop,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, prop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mask",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MaskType),
        .number = Action_FieldNumber_Mask,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, mask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MessageType),
        .number = Action_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "socialMedia",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_SocialMediaType),
        .number = Action_FieldNumber_SocialMedia,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, socialMedia),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "communication",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType),
        .number = Action_FieldNumber_Communication,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, communication),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MultiScreenType),
        .number = Action_FieldNumber_MultiScreen,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, multiScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "presentationDocument",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_DocumentType),
        .number = Action_FieldNumber_PresentationDocument,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, presentationDocument),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "externalPresentation",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_ExternalPresentationType),
        .number = Action_FieldNumber_ExternalPresentation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, externalPresentation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audienceLook",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_AudienceLookType),
        .number = Action_FieldNumber_AudienceLook,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, audienceLook),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioInput",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_AudioInputType),
        .number = Action_FieldNumber_AudioInput,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, audioInput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideDestination",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_SlideDestinationType),
        .number = Action_FieldNumber_SlideDestination,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, slideDestination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "macro",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MacroType),
        .number = Action_FieldNumber_Macro,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, macro),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clearGroup",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_ClearGroupType),
        .number = Action_FieldNumber_ClearGroup,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action__storage_, clearGroup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "actionTypeData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_Type_RawValue(Action *message) {
  GPBDescriptor *descriptor = [Action descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_Type_RawValue(Action *message, int32_t value) {
  GPBDescriptor *descriptor = [Action descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void Action_ClearActionTypeDataOneOfCase(Action *message) {
  GPBDescriptor *descriptor = [Action descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Action_ActionType

GPBEnumDescriptor *Action_ActionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ActionTypeUnknown\000ActionTypeStageLayout\000"
        "ActionTypeMedia\000ActionTypeTimer\000ActionTy"
        "peCommunication\000ActionTypeClear\000ActionTy"
        "peProp\000ActionTypeMask\000ActionTypeMessage\000"
        "ActionTypeSocialMedia\000ActionTypeMultiscr"
        "een\000ActionTypePresentationSlide\000ActionTy"
        "peForegroundMedia\000ActionTypeBackgroundMe"
        "dia\000ActionTypePresentationDocument\000Actio"
        "nTypePropSlide\000ActionTypeExternalPresent"
        "ation\000ActionTypeAudienceLook\000ActionTypeA"
        "udioInput\000ActionTypeAudioBinPlaylist\000Act"
        "ionTypeMediaBinPlaylist\000ActionTypeSlideD"
        "estination\000ActionTypeMacro\000ActionTypeCle"
        "arGroup\000";
    static const int32_t values[] = {
        Action_ActionType_ActionTypeUnknown,
        Action_ActionType_ActionTypeStageLayout,
        Action_ActionType_ActionTypeMedia,
        Action_ActionType_ActionTypeTimer,
        Action_ActionType_ActionTypeCommunication,
        Action_ActionType_ActionTypeClear,
        Action_ActionType_ActionTypeProp,
        Action_ActionType_ActionTypeMask,
        Action_ActionType_ActionTypeMessage,
        Action_ActionType_ActionTypeSocialMedia,
        Action_ActionType_ActionTypeMultiscreen,
        Action_ActionType_ActionTypePresentationSlide,
        Action_ActionType_ActionTypeForegroundMedia,
        Action_ActionType_ActionTypeBackgroundMedia,
        Action_ActionType_ActionTypePresentationDocument,
        Action_ActionType_ActionTypePropSlide,
        Action_ActionType_ActionTypeExternalPresentation,
        Action_ActionType_ActionTypeAudienceLook,
        Action_ActionType_ActionTypeAudioInput,
        Action_ActionType_ActionTypeAudioBinPlaylist,
        Action_ActionType_ActionTypeMediaBinPlaylist,
        Action_ActionType_ActionTypeSlideDestination,
        Action_ActionType_ActionTypeMacro,
        Action_ActionType_ActionTypeClearGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_ActionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_ActionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_ActionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_ActionType_ActionTypeUnknown:
    case Action_ActionType_ActionTypeStageLayout:
    case Action_ActionType_ActionTypeMedia:
    case Action_ActionType_ActionTypeTimer:
    case Action_ActionType_ActionTypeCommunication:
    case Action_ActionType_ActionTypeClear:
    case Action_ActionType_ActionTypeProp:
    case Action_ActionType_ActionTypeMask:
    case Action_ActionType_ActionTypeMessage:
    case Action_ActionType_ActionTypeSocialMedia:
    case Action_ActionType_ActionTypeMultiscreen:
    case Action_ActionType_ActionTypePresentationSlide:
    case Action_ActionType_ActionTypeForegroundMedia:
    case Action_ActionType_ActionTypeBackgroundMedia:
    case Action_ActionType_ActionTypePresentationDocument:
    case Action_ActionType_ActionTypePropSlide:
    case Action_ActionType_ActionTypeExternalPresentation:
    case Action_ActionType_ActionTypeAudienceLook:
    case Action_ActionType_ActionTypeAudioInput:
    case Action_ActionType_ActionTypeAudioBinPlaylist:
    case Action_ActionType_ActionTypeMediaBinPlaylist:
    case Action_ActionType_ActionTypeSlideDestination:
    case Action_ActionType_ActionTypeMacro:
    case Action_ActionType_ActionTypeClearGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_OldType

@implementation Action_OldType

@dynamic category;
@dynamic applicationType;

typedef struct Action_OldType__storage_ {
  uint32_t _has_storage_[1];
  Action_OldType_Category category;
  int32_t applicationType;
} Action_OldType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.enumDescFunc = Action_OldType_Category_EnumDescriptor,
        .number = Action_OldType_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_OldType__storage_, category),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "applicationType",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_OldType_FieldNumber_ApplicationType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_OldType__storage_, applicationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_OldType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_OldType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_OldType_Category_RawValue(Action_OldType *message) {
  GPBDescriptor *descriptor = [Action_OldType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_OldType_FieldNumber_Category];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_OldType_Category_RawValue(Action_OldType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_OldType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_OldType_FieldNumber_Category];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_OldType_Category

GPBEnumDescriptor *Action_OldType_Category_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CategoryUnknown\000CategoryMedia\000CategoryAp"
        "plication\000";
    static const int32_t values[] = {
        Action_OldType_Category_CategoryUnknown,
        Action_OldType_Category_CategoryMedia,
        Action_OldType_Category_CategoryApplication,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_OldType_Category)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_OldType_Category_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_OldType_Category_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_OldType_Category_CategoryUnknown:
    case Action_OldType_Category_CategoryMedia:
    case Action_OldType_Category_CategoryApplication:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_Label

@implementation Action_Label

@dynamic text;
@dynamic hasColor, color;

typedef struct Action_Label__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  Color *color;
} Action_Label__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_Label_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_Label__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Action_Label_FieldNumber_Color,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_Label__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_Label class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_Label__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_LayerIdentification

@implementation Action_LayerIdentification

@dynamic hasUuid, uuid;
@dynamic name;

typedef struct Action_LayerIdentification__storage_ {
  uint32_t _has_storage_[1];
  UUID *uuid;
  NSString *name;
} Action_LayerIdentification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_LayerIdentification_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_LayerIdentification__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_LayerIdentification_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_LayerIdentification__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_LayerIdentification class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_LayerIdentification__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_PlaylistItemType

@implementation Action_PlaylistItemType

@dynamic hasPlaylistUuid, playlistUuid;
@dynamic playlistName;
@dynamic hasItemUuid, itemUuid;
@dynamic itemName;
@dynamic selectPlaylist;
@dynamic alwaysRetrigger;

typedef struct Action_PlaylistItemType__storage_ {
  uint32_t _has_storage_[1];
  UUID *playlistUuid;
  NSString *playlistName;
  UUID *itemUuid;
  NSString *itemName;
} Action_PlaylistItemType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playlistUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_PlaylistItemType_FieldNumber_PlaylistUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_PlaylistItemType__storage_, playlistUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playlistName",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_PlaylistItemType_FieldNumber_PlaylistName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_PlaylistItemType__storage_, playlistName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_PlaylistItemType_FieldNumber_ItemUuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_PlaylistItemType__storage_, itemUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemName",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_PlaylistItemType_FieldNumber_ItemName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_PlaylistItemType__storage_, itemName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selectPlaylist",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_PlaylistItemType_FieldNumber_SelectPlaylist,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "alwaysRetrigger",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_PlaylistItemType_FieldNumber_AlwaysRetrigger,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_PlaylistItemType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_PlaylistItemType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_BlendModeType

@implementation Action_BlendModeType

@dynamic blendMode;
@dynamic hasBlend, blend;

typedef struct Action_BlendModeType__storage_ {
  uint32_t _has_storage_[1];
  Action_BlendModeType_BlendMode blendMode;
  Layer_Blending *blend;
} Action_BlendModeType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blendMode",
        .dataTypeSpecific.enumDescFunc = Action_BlendModeType_BlendMode_EnumDescriptor,
        .number = Action_BlendModeType_FieldNumber_BlendMode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_BlendModeType__storage_, blendMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blend",
        .dataTypeSpecific.clazz = GPBObjCClass(Layer_Blending),
        .number = Action_BlendModeType_FieldNumber_Blend,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_BlendModeType__storage_, blend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_BlendModeType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_BlendModeType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_BlendModeType_BlendMode_RawValue(Action_BlendModeType *message) {
  GPBDescriptor *descriptor = [Action_BlendModeType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_BlendModeType_FieldNumber_BlendMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_BlendModeType_BlendMode_RawValue(Action_BlendModeType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_BlendModeType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_BlendModeType_FieldNumber_BlendMode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_BlendModeType_BlendMode

GPBEnumDescriptor *Action_BlendModeType_BlendMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BlendModeNormal\000BlendModeDissolve\000BlendM"
        "odeDarken\000BlendModeMultiply\000BlendModeCol"
        "orBurn\000BlendModeLinearBurn\000BlendModeDark"
        "erColor\000BlendModeLighten\000BlendModeScreen"
        "\000BlendModeColorDodge\000BlendModeLinearDodg"
        "e\000BlendModeLighterColor\000BlendModeOverlay"
        "\000BlendModeSoftLight\000BlendModeHardLight\000B"
        "lendModeVividLight\000BlendModeLinearLight\000"
        "BlendModePinLight\000BlendModeHardMix\000Blend"
        "ModeDifference\000BlendModeExclusion\000BlendM"
        "odeSubtract\000BlendModeDivide\000BlendModeHue"
        "\000BlendModeSaturation\000BlendModeColor\000Blen"
        "dModeLuminosity\000";
    static const int32_t values[] = {
        Action_BlendModeType_BlendMode_BlendModeNormal,
        Action_BlendModeType_BlendMode_BlendModeDissolve,
        Action_BlendModeType_BlendMode_BlendModeDarken,
        Action_BlendModeType_BlendMode_BlendModeMultiply,
        Action_BlendModeType_BlendMode_BlendModeColorBurn,
        Action_BlendModeType_BlendMode_BlendModeLinearBurn,
        Action_BlendModeType_BlendMode_BlendModeDarkerColor,
        Action_BlendModeType_BlendMode_BlendModeLighten,
        Action_BlendModeType_BlendMode_BlendModeScreen,
        Action_BlendModeType_BlendMode_BlendModeColorDodge,
        Action_BlendModeType_BlendMode_BlendModeLinearDodge,
        Action_BlendModeType_BlendMode_BlendModeLighterColor,
        Action_BlendModeType_BlendMode_BlendModeOverlay,
        Action_BlendModeType_BlendMode_BlendModeSoftLight,
        Action_BlendModeType_BlendMode_BlendModeHardLight,
        Action_BlendModeType_BlendMode_BlendModeVividLight,
        Action_BlendModeType_BlendMode_BlendModeLinearLight,
        Action_BlendModeType_BlendMode_BlendModePinLight,
        Action_BlendModeType_BlendMode_BlendModeHardMix,
        Action_BlendModeType_BlendMode_BlendModeDifference,
        Action_BlendModeType_BlendMode_BlendModeExclusion,
        Action_BlendModeType_BlendMode_BlendModeSubtract,
        Action_BlendModeType_BlendMode_BlendModeDivide,
        Action_BlendModeType_BlendMode_BlendModeHue,
        Action_BlendModeType_BlendMode_BlendModeSaturation,
        Action_BlendModeType_BlendMode_BlendModeColor,
        Action_BlendModeType_BlendMode_BlendModeLuminosity,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_BlendModeType_BlendMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_BlendModeType_BlendMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_BlendModeType_BlendMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_BlendModeType_BlendMode_BlendModeNormal:
    case Action_BlendModeType_BlendMode_BlendModeDissolve:
    case Action_BlendModeType_BlendMode_BlendModeDarken:
    case Action_BlendModeType_BlendMode_BlendModeMultiply:
    case Action_BlendModeType_BlendMode_BlendModeColorBurn:
    case Action_BlendModeType_BlendMode_BlendModeLinearBurn:
    case Action_BlendModeType_BlendMode_BlendModeDarkerColor:
    case Action_BlendModeType_BlendMode_BlendModeLighten:
    case Action_BlendModeType_BlendMode_BlendModeScreen:
    case Action_BlendModeType_BlendMode_BlendModeColorDodge:
    case Action_BlendModeType_BlendMode_BlendModeLinearDodge:
    case Action_BlendModeType_BlendMode_BlendModeLighterColor:
    case Action_BlendModeType_BlendMode_BlendModeOverlay:
    case Action_BlendModeType_BlendMode_BlendModeSoftLight:
    case Action_BlendModeType_BlendMode_BlendModeHardLight:
    case Action_BlendModeType_BlendMode_BlendModeVividLight:
    case Action_BlendModeType_BlendMode_BlendModeLinearLight:
    case Action_BlendModeType_BlendMode_BlendModePinLight:
    case Action_BlendModeType_BlendMode_BlendModeHardMix:
    case Action_BlendModeType_BlendMode_BlendModeDifference:
    case Action_BlendModeType_BlendMode_BlendModeExclusion:
    case Action_BlendModeType_BlendMode_BlendModeSubtract:
    case Action_BlendModeType_BlendMode_BlendModeDivide:
    case Action_BlendModeType_BlendMode_BlendModeHue:
    case Action_BlendModeType_BlendMode_BlendModeSaturation:
    case Action_BlendModeType_BlendMode_BlendModeColor:
    case Action_BlendModeType_BlendMode_BlendModeLuminosity:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_TransitionType

@implementation Action_TransitionType

@dynamic transitionName;
@dynamic hasTransition, transition;

typedef struct Action_TransitionType__storage_ {
  uint32_t _has_storage_[1];
  NSString *transitionName;
  Transition *transition;
} Action_TransitionType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transitionName",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_TransitionType_FieldNumber_TransitionName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_TransitionType__storage_, transitionName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transition",
        .dataTypeSpecific.clazz = GPBObjCClass(Transition),
        .number = Action_TransitionType_FieldNumber_Transition,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_TransitionType__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_TransitionType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_TransitionType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_DoubleType

@implementation Action_DoubleType

@dynamic value;

typedef struct Action_DoubleType__storage_ {
  uint32_t _has_storage_[1];
  double value;
} Action_DoubleType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_DoubleType_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_DoubleType__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_DoubleType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_DoubleType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_EffectsType

@implementation Action_EffectsType

@dynamic effectsArray, effectsArray_Count;

typedef struct Action_EffectsType__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *effectsArray;
} Action_EffectsType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "effectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = Action_EffectsType_FieldNumber_EffectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_EffectsType__storage_, effectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_EffectsType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_EffectsType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_MediaType

@implementation Action_MediaType

@dynamic mediaTypeOneOfCase;
@dynamic transitionDuration;
@dynamic hasSelectedEffectPresetUuid, selectedEffectPresetUuid;
@dynamic hasTransition, transition;
@dynamic effectsArray, effectsArray_Count;
@dynamic hasElement, element;
@dynamic layerType;
@dynamic alwaysRetrigger;
@dynamic image;
@dynamic video;
@dynamic audio;
@dynamic liveVideo;

typedef struct Action_MediaType__storage_ {
  uint32_t _has_storage_[2];
  Action_MediaType_LayerType layerType;
  UUID *selectedEffectPresetUuid;
  Transition *transition;
  NSMutableArray *effectsArray;
  Media *element;
  Action_MediaType_Image *image;
  Action_MediaType_Video *video;
  Action_MediaType_Audio *audio;
  Action_MediaType_LiveVideo *liveVideo;
  double transitionDuration;
} Action_MediaType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transitionDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_FieldNumber_TransitionDuration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, transitionDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "selectedEffectPresetUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_MediaType_FieldNumber_SelectedEffectPresetUuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, selectedEffectPresetUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transition",
        .dataTypeSpecific.clazz = GPBObjCClass(Transition),
        .number = Action_MediaType_FieldNumber_Transition,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = Action_MediaType_FieldNumber_EffectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, effectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "element",
        .dataTypeSpecific.clazz = GPBObjCClass(Media),
        .number = Action_MediaType_FieldNumber_Element,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, element),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MediaType_Image),
        .number = Action_MediaType_FieldNumber_Image,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MediaType_Video),
        .number = Action_MediaType_FieldNumber_Video,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MediaType_Audio),
        .number = Action_MediaType_FieldNumber_Audio,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_MediaType_LiveVideo),
        .number = Action_MediaType_FieldNumber_LiveVideo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, liveVideo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "layerType",
        .dataTypeSpecific.enumDescFunc = Action_MediaType_LayerType_EnumDescriptor,
        .number = Action_MediaType_FieldNumber_LayerType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Action_MediaType__storage_, layerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "alwaysRetrigger",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_FieldNumber_AlwaysRetrigger,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MediaType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MediaType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "mediaType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_MediaType_LayerType_RawValue(Action_MediaType *message) {
  GPBDescriptor *descriptor = [Action_MediaType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_FieldNumber_LayerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_MediaType_LayerType_RawValue(Action_MediaType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_MediaType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_FieldNumber_LayerType];
  GPBSetMessageRawEnumField(message, field, value);
}

void Action_MediaType_ClearMediaTypeOneOfCase(Action_MediaType *message) {
  GPBDescriptor *descriptor = [Action_MediaType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Action_MediaType_LayerType

GPBEnumDescriptor *Action_MediaType_LayerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LayerTypeBackground\000LayerTypeForeground\000"
        "LayerTypeFill\000LayerTypeInput\000";
    static const int32_t values[] = {
        Action_MediaType_LayerType_LayerTypeBackground,
        Action_MediaType_LayerType_LayerTypeForeground,
        Action_MediaType_LayerType_LayerTypeFill,
        Action_MediaType_LayerType_LayerTypeInput,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_MediaType_LayerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_MediaType_LayerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_MediaType_LayerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_MediaType_LayerType_LayerTypeBackground:
    case Action_MediaType_LayerType_LayerTypeForeground:
    case Action_MediaType_LayerType_LayerTypeFill:
    case Action_MediaType_LayerType_LayerTypeInput:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_MediaType_Image

@implementation Action_MediaType_Image


typedef struct Action_MediaType_Image__storage_ {
  uint32_t _has_storage_[1];
} Action_MediaType_Image__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MediaType_Image class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Action_MediaType_Image__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_MediaType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_MediaType_Video

@implementation Action_MediaType_Video

@dynamic playbackBehavior;
@dynamic endBehavior;
@dynamic loopTime;
@dynamic timesToLoop;
@dynamic softLoop;
@dynamic softLoopDuration;

typedef struct Action_MediaType_Video__storage_ {
  uint32_t _has_storage_[1];
  Action_MediaType_Video_PlaybackBehavior playbackBehavior;
  Action_MediaType_Video_EndBehavior endBehavior;
  uint32_t timesToLoop;
  double loopTime;
  double softLoopDuration;
} Action_MediaType_Video__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playbackBehavior",
        .dataTypeSpecific.enumDescFunc = Action_MediaType_Video_PlaybackBehavior_EnumDescriptor,
        .number = Action_MediaType_Video_FieldNumber_PlaybackBehavior,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MediaType_Video__storage_, playbackBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endBehavior",
        .dataTypeSpecific.enumDescFunc = Action_MediaType_Video_EndBehavior_EnumDescriptor,
        .number = Action_MediaType_Video_FieldNumber_EndBehavior,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_MediaType_Video__storage_, endBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "loopTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Video_FieldNumber_LoopTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_MediaType_Video__storage_, loopTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timesToLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Video_FieldNumber_TimesToLoop,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_MediaType_Video__storage_, timesToLoop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "softLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Video_FieldNumber_SoftLoop,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "softLoopDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Video_FieldNumber_SoftLoopDuration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Action_MediaType_Video__storage_, softLoopDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MediaType_Video class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MediaType_Video__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_MediaType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_MediaType_Video_PlaybackBehavior_RawValue(Action_MediaType_Video *message) {
  GPBDescriptor *descriptor = [Action_MediaType_Video descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Video_FieldNumber_PlaybackBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_MediaType_Video_PlaybackBehavior_RawValue(Action_MediaType_Video *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_MediaType_Video descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Video_FieldNumber_PlaybackBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Action_MediaType_Video_EndBehavior_RawValue(Action_MediaType_Video *message) {
  GPBDescriptor *descriptor = [Action_MediaType_Video descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Video_FieldNumber_EndBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_MediaType_Video_EndBehavior_RawValue(Action_MediaType_Video *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_MediaType_Video descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Video_FieldNumber_EndBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_MediaType_Video_PlaybackBehavior

GPBEnumDescriptor *Action_MediaType_Video_PlaybackBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaybackBehaviorStop\000PlaybackBehaviorLoo"
        "p\000PlaybackBehaviorLoopForCount\000PlaybackB"
        "ehaviorLoopForTime\000";
    static const int32_t values[] = {
        Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorStop,
        Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoop,
        Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoopForCount,
        Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoopForTime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_MediaType_Video_PlaybackBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_MediaType_Video_PlaybackBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_MediaType_Video_PlaybackBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorStop:
    case Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoop:
    case Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoopForCount:
    case Action_MediaType_Video_PlaybackBehavior_PlaybackBehaviorLoopForTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Action_MediaType_Video_EndBehavior

GPBEnumDescriptor *Action_MediaType_Video_EndBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EndBehaviorStop\000EndBehaviorStopOnBlack\000E"
        "ndBehaviorStopOnClear\000EndBehaviorFadeToB"
        "lack\000EndBehaviorFadeToClear\000";
    static const int32_t values[] = {
        Action_MediaType_Video_EndBehavior_EndBehaviorStop,
        Action_MediaType_Video_EndBehavior_EndBehaviorStopOnBlack,
        Action_MediaType_Video_EndBehavior_EndBehaviorStopOnClear,
        Action_MediaType_Video_EndBehavior_EndBehaviorFadeToBlack,
        Action_MediaType_Video_EndBehavior_EndBehaviorFadeToClear,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_MediaType_Video_EndBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_MediaType_Video_EndBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_MediaType_Video_EndBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_MediaType_Video_EndBehavior_EndBehaviorStop:
    case Action_MediaType_Video_EndBehavior_EndBehaviorStopOnBlack:
    case Action_MediaType_Video_EndBehavior_EndBehaviorStopOnClear:
    case Action_MediaType_Video_EndBehavior_EndBehaviorFadeToBlack:
    case Action_MediaType_Video_EndBehavior_EndBehaviorFadeToClear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_MediaType_Audio

@implementation Action_MediaType_Audio

@dynamic playbackBehavior;
@dynamic loopTime;
@dynamic timesToLoop;
@dynamic audioType;

typedef struct Action_MediaType_Audio__storage_ {
  uint32_t _has_storage_[1];
  Action_MediaType_Audio_PlaybackBehavior playbackBehavior;
  uint32_t timesToLoop;
  Action_MediaType_Audio_MediaActionAudioType audioType;
  double loopTime;
} Action_MediaType_Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playbackBehavior",
        .dataTypeSpecific.enumDescFunc = Action_MediaType_Audio_PlaybackBehavior_EnumDescriptor,
        .number = Action_MediaType_Audio_FieldNumber_PlaybackBehavior,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MediaType_Audio__storage_, playbackBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "loopTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Audio_FieldNumber_LoopTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_MediaType_Audio__storage_, loopTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timesToLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_MediaType_Audio_FieldNumber_TimesToLoop,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_MediaType_Audio__storage_, timesToLoop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "audioType",
        .dataTypeSpecific.enumDescFunc = Action_MediaType_Audio_MediaActionAudioType_EnumDescriptor,
        .number = Action_MediaType_Audio_FieldNumber_AudioType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_MediaType_Audio__storage_, audioType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MediaType_Audio class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MediaType_Audio__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_MediaType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_MediaType_Audio_PlaybackBehavior_RawValue(Action_MediaType_Audio *message) {
  GPBDescriptor *descriptor = [Action_MediaType_Audio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Audio_FieldNumber_PlaybackBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_MediaType_Audio_PlaybackBehavior_RawValue(Action_MediaType_Audio *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_MediaType_Audio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Audio_FieldNumber_PlaybackBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Action_MediaType_Audio_AudioType_RawValue(Action_MediaType_Audio *message) {
  GPBDescriptor *descriptor = [Action_MediaType_Audio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Audio_FieldNumber_AudioType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_MediaType_Audio_AudioType_RawValue(Action_MediaType_Audio *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_MediaType_Audio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_MediaType_Audio_FieldNumber_AudioType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_MediaType_Audio_PlaybackBehavior

GPBEnumDescriptor *Action_MediaType_Audio_PlaybackBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaybackBehaviorStop\000PlaybackBehaviorLoo"
        "p\000PlaybackBehaviorLoopForCount\000PlaybackB"
        "ehaviorLoopForTime\000";
    static const int32_t values[] = {
        Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorStop,
        Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoop,
        Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoopForCount,
        Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoopForTime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_MediaType_Audio_PlaybackBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_MediaType_Audio_PlaybackBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_MediaType_Audio_PlaybackBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorStop:
    case Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoop:
    case Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoopForCount:
    case Action_MediaType_Audio_PlaybackBehavior_PlaybackBehaviorLoopForTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Action_MediaType_Audio_MediaActionAudioType

GPBEnumDescriptor *Action_MediaType_Audio_MediaActionAudioType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MediaActionAudioTypeTune\000MediaActionAudi"
        "oTypeSound\000";
    static const int32_t values[] = {
        Action_MediaType_Audio_MediaActionAudioType_MediaActionAudioTypeTune,
        Action_MediaType_Audio_MediaActionAudioType_MediaActionAudioTypeSound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_MediaType_Audio_MediaActionAudioType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_MediaType_Audio_MediaActionAudioType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_MediaType_Audio_MediaActionAudioType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_MediaType_Audio_MediaActionAudioType_MediaActionAudioTypeTune:
    case Action_MediaType_Audio_MediaActionAudioType_MediaActionAudioTypeSound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_MediaType_LiveVideo

@implementation Action_MediaType_LiveVideo


typedef struct Action_MediaType_LiveVideo__storage_ {
  uint32_t _has_storage_[1];
} Action_MediaType_LiveVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MediaType_LiveVideo class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Action_MediaType_LiveVideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_MediaType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_SlideType

@implementation Action_SlideType

@dynamic slideOneOfCase;
@dynamic template_p;
@dynamic presentation;
@dynamic prop;

typedef struct Action_SlideType__storage_ {
  uint32_t _has_storage_[2];
  Template_Slide *template_p;
  PresentationSlide *presentation;
  PropSlide *prop;
} Action_SlideType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "template_p",
        .dataTypeSpecific.clazz = GPBObjCClass(Template_Slide),
        .number = Action_SlideType_FieldNumber_Template_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_SlideType__storage_, template_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "presentation",
        .dataTypeSpecific.clazz = GPBObjCClass(PresentationSlide),
        .number = Action_SlideType_FieldNumber_Presentation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_SlideType__storage_, presentation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prop",
        .dataTypeSpecific.clazz = GPBObjCClass(PropSlide),
        .number = Action_SlideType_FieldNumber_Prop,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_SlideType__storage_, prop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_SlideType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_SlideType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "slide",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Action_SlideType_ClearSlideOneOfCase(Action_SlideType *message) {
  GPBDescriptor *descriptor = [Action_SlideType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Action_BackgroundType

@implementation Action_BackgroundType

@dynamic hasElement, element;

typedef struct Action_BackgroundType__storage_ {
  uint32_t _has_storage_[1];
  Background *element;
} Action_BackgroundType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "element",
        .dataTypeSpecific.clazz = GPBObjCClass(Background),
        .number = Action_BackgroundType_FieldNumber_Element,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_BackgroundType__storage_, element),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_BackgroundType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_BackgroundType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_TimerType

@implementation Action_TimerType

@dynamic actionType;
@dynamic hasTimerIdentification, timerIdentification;
@dynamic hasTimerConfiguration, timerConfiguration;

typedef struct Action_TimerType__storage_ {
  uint32_t _has_storage_[1];
  Action_TimerType_TimerAction actionType;
  CollectionElementType *timerIdentification;
  Timer_Configuration *timerConfiguration;
} Action_TimerType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionType",
        .dataTypeSpecific.enumDescFunc = Action_TimerType_TimerAction_EnumDescriptor,
        .number = Action_TimerType_FieldNumber_ActionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_TimerType__storage_, actionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timerIdentification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_TimerType_FieldNumber_TimerIdentification,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_TimerType__storage_, timerIdentification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerConfiguration",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Configuration),
        .number = Action_TimerType_FieldNumber_TimerConfiguration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_TimerType__storage_, timerConfiguration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_TimerType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_TimerType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_TimerType_ActionType_RawValue(Action_TimerType *message) {
  GPBDescriptor *descriptor = [Action_TimerType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_TimerType_FieldNumber_ActionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_TimerType_ActionType_RawValue(Action_TimerType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_TimerType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_TimerType_FieldNumber_ActionType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_TimerType_TimerAction

GPBEnumDescriptor *Action_TimerType_TimerAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ActionStart\000ActionStop\000ActionReset\000Actio"
        "nResetAndStart\000ActionStopAndReset\000";
    static const int32_t values[] = {
        Action_TimerType_TimerAction_ActionStart,
        Action_TimerType_TimerAction_ActionStop,
        Action_TimerType_TimerAction_ActionReset,
        Action_TimerType_TimerAction_ActionResetAndStart,
        Action_TimerType_TimerAction_ActionStopAndReset,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_TimerType_TimerAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_TimerType_TimerAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_TimerType_TimerAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_TimerType_TimerAction_ActionStart:
    case Action_TimerType_TimerAction_ActionStop:
    case Action_TimerType_TimerAction_ActionReset:
    case Action_TimerType_TimerAction_ActionResetAndStart:
    case Action_TimerType_TimerAction_ActionStopAndReset:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_ClearType

@implementation Action_ClearType

@dynamic targetLayer;
@dynamic contentDestination;

typedef struct Action_ClearType__storage_ {
  uint32_t _has_storage_[1];
  Action_ClearType_ClearTargetLayer targetLayer;
  Action_ClearType_ContentDestination contentDestination;
} Action_ClearType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetLayer",
        .dataTypeSpecific.enumDescFunc = Action_ClearType_ClearTargetLayer_EnumDescriptor,
        .number = Action_ClearType_FieldNumber_TargetLayer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_ClearType__storage_, targetLayer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contentDestination",
        .dataTypeSpecific.enumDescFunc = Action_ClearType_ContentDestination_EnumDescriptor,
        .number = Action_ClearType_FieldNumber_ContentDestination,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_ClearType__storage_, contentDestination),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_ClearType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_ClearType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_ClearType_TargetLayer_RawValue(Action_ClearType *message) {
  GPBDescriptor *descriptor = [Action_ClearType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_ClearType_FieldNumber_TargetLayer];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_ClearType_TargetLayer_RawValue(Action_ClearType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_ClearType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_ClearType_FieldNumber_TargetLayer];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Action_ClearType_ContentDestination_RawValue(Action_ClearType *message) {
  GPBDescriptor *descriptor = [Action_ClearType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_ClearType_FieldNumber_ContentDestination];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_ClearType_ContentDestination_RawValue(Action_ClearType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_ClearType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_ClearType_FieldNumber_ContentDestination];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_ClearType_ClearTargetLayer

GPBEnumDescriptor *Action_ClearType_ClearTargetLayer_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClearTargetLayerAll\000ClearTargetLayerAudi"
        "o\000ClearTargetLayerBackground\000ClearTarget"
        "LayerLiveVideo\000ClearTargetLayerProp\000Clea"
        "rTargetLayerSlide\000ClearTargetLayerLogo\000C"
        "learTargetLayerMessages\000ClearTargetLayer"
        "AudioEffects\000";
    static const int32_t values[] = {
        Action_ClearType_ClearTargetLayer_ClearTargetLayerAll,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerAudio,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerBackground,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerLiveVideo,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerProp,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerSlide,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerLogo,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerMessages,
        Action_ClearType_ClearTargetLayer_ClearTargetLayerAudioEffects,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_ClearType_ClearTargetLayer)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_ClearType_ClearTargetLayer_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_ClearType_ClearTargetLayer_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerAll:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerAudio:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerBackground:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerLiveVideo:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerProp:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerSlide:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerLogo:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerMessages:
    case Action_ClearType_ClearTargetLayer_ClearTargetLayerAudioEffects:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Action_ClearType_ContentDestination

GPBEnumDescriptor *Action_ClearType_ContentDestination_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentDestinationGlobal\000ContentDestinat"
        "ionAnnouncements\000";
    static const int32_t values[] = {
        Action_ClearType_ContentDestination_ContentDestinationGlobal,
        Action_ClearType_ContentDestination_ContentDestinationAnnouncements,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_ClearType_ContentDestination)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_ClearType_ContentDestination_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_ClearType_ContentDestination_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_ClearType_ContentDestination_ContentDestinationGlobal:
    case Action_ClearType_ContentDestination_ContentDestinationAnnouncements:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_ClearGroupType

@implementation Action_ClearGroupType

@dynamic hasIdentification, identification;

typedef struct Action_ClearGroupType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_ClearGroupType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_ClearGroupType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_ClearGroupType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_ClearGroupType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_ClearGroupType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_StageLayoutType

@implementation Action_StageLayoutType

@dynamic stageScreenAssignmentsArray, stageScreenAssignmentsArray_Count;
@dynamic slideTarget;

typedef struct Action_StageLayoutType__storage_ {
  uint32_t _has_storage_[1];
  Action_StageLayoutType_SlideTarget slideTarget;
  NSMutableArray *stageScreenAssignmentsArray;
} Action_StageLayoutType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stageScreenAssignmentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Stage_ScreenAssignment),
        .number = Action_StageLayoutType_FieldNumber_StageScreenAssignmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_StageLayoutType__storage_, stageScreenAssignmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideTarget",
        .dataTypeSpecific.enumDescFunc = Action_StageLayoutType_SlideTarget_EnumDescriptor,
        .number = Action_StageLayoutType_FieldNumber_SlideTarget,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_StageLayoutType__storage_, slideTarget),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_StageLayoutType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_StageLayoutType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_StageLayoutType_SlideTarget_RawValue(Action_StageLayoutType *message) {
  GPBDescriptor *descriptor = [Action_StageLayoutType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_StageLayoutType_FieldNumber_SlideTarget];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_StageLayoutType_SlideTarget_RawValue(Action_StageLayoutType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_StageLayoutType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_StageLayoutType_FieldNumber_SlideTarget];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_StageLayoutType_SlideTarget

GPBEnumDescriptor *Action_StageLayoutType_SlideTarget_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideTargetNoChange\000SlideTargetStageOnly"
        "\000SlideTargetAll\000";
    static const int32_t values[] = {
        Action_StageLayoutType_SlideTarget_SlideTargetNoChange,
        Action_StageLayoutType_SlideTarget_SlideTargetStageOnly,
        Action_StageLayoutType_SlideTarget_SlideTargetAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_StageLayoutType_SlideTarget)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_StageLayoutType_SlideTarget_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_StageLayoutType_SlideTarget_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_StageLayoutType_SlideTarget_SlideTargetNoChange:
    case Action_StageLayoutType_SlideTarget_SlideTargetStageOnly:
    case Action_StageLayoutType_SlideTarget_SlideTargetAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_SlideDestinationType

@implementation Action_SlideDestinationType

@dynamic slideTarget;

typedef struct Action_SlideDestinationType__storage_ {
  uint32_t _has_storage_[1];
  Action_SlideDestinationType_SlideTarget slideTarget;
} Action_SlideDestinationType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slideTarget",
        .dataTypeSpecific.enumDescFunc = Action_SlideDestinationType_SlideTarget_EnumDescriptor,
        .number = Action_SlideDestinationType_FieldNumber_SlideTarget,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_SlideDestinationType__storage_, slideTarget),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_SlideDestinationType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_SlideDestinationType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_SlideDestinationType_SlideTarget_RawValue(Action_SlideDestinationType *message) {
  GPBDescriptor *descriptor = [Action_SlideDestinationType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_SlideDestinationType_FieldNumber_SlideTarget];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_SlideDestinationType_SlideTarget_RawValue(Action_SlideDestinationType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_SlideDestinationType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_SlideDestinationType_FieldNumber_SlideTarget];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_SlideDestinationType_SlideTarget

GPBEnumDescriptor *Action_SlideDestinationType_SlideTarget_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideTargetNoChange\000SlideTargetStageOnly"
        "\000SlideTargetAll\000";
    static const int32_t values[] = {
        Action_SlideDestinationType_SlideTarget_SlideTargetNoChange,
        Action_SlideDestinationType_SlideTarget_SlideTargetStageOnly,
        Action_SlideDestinationType_SlideTarget_SlideTargetAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_SlideDestinationType_SlideTarget)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_SlideDestinationType_SlideTarget_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_SlideDestinationType_SlideTarget_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_SlideDestinationType_SlideTarget_SlideTargetNoChange:
    case Action_SlideDestinationType_SlideTarget_SlideTargetStageOnly:
    case Action_SlideDestinationType_SlideTarget_SlideTargetAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_PropType

@implementation Action_PropType

@dynamic hasIdentification, identification;

typedef struct Action_PropType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_PropType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_PropType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_PropType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_PropType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_PropType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_MaskType

@implementation Action_MaskType

@dynamic hasIdentification, identification;

typedef struct Action_MaskType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_MaskType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_MaskType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MaskType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MaskType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MaskType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_MessageType

@implementation Action_MessageType

@dynamic hasMessageIdentificaton, messageIdentificaton;
@dynamic contentArray, contentArray_Count;

typedef struct Action_MessageType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *messageIdentificaton;
  NSMutableArray *contentArray;
} Action_MessageType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageIdentificaton",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_MessageType_FieldNumber_MessageIdentificaton,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MessageType__storage_, messageIdentificaton),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Message_TokenValue),
        .number = Action_MessageType_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_MessageType__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MessageType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MessageType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_SocialMediaType

@implementation Action_SocialMediaType

@dynamic actionType;
@dynamic duration;

typedef struct Action_SocialMediaType__storage_ {
  uint32_t _has_storage_[1];
  Action_SocialMediaType_SocialMediaAction actionType;
  double duration;
} Action_SocialMediaType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionType",
        .dataTypeSpecific.enumDescFunc = Action_SocialMediaType_SocialMediaAction_EnumDescriptor,
        .number = Action_SocialMediaType_FieldNumber_ActionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_SocialMediaType__storage_, actionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_SocialMediaType_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_SocialMediaType__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_SocialMediaType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_SocialMediaType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_SocialMediaType_ActionType_RawValue(Action_SocialMediaType *message) {
  GPBDescriptor *descriptor = [Action_SocialMediaType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_SocialMediaType_FieldNumber_ActionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_SocialMediaType_ActionType_RawValue(Action_SocialMediaType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_SocialMediaType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_SocialMediaType_FieldNumber_ActionType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_SocialMediaType_SocialMediaAction

GPBEnumDescriptor *Action_SocialMediaType_SocialMediaAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SocialMediaActionLengthOfGotoNextTimer\000S"
        "ocialMediaActionSpecifiedTime\000";
    static const int32_t values[] = {
        Action_SocialMediaType_SocialMediaAction_SocialMediaActionLengthOfGotoNextTimer,
        Action_SocialMediaType_SocialMediaAction_SocialMediaActionSpecifiedTime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_SocialMediaType_SocialMediaAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_SocialMediaType_SocialMediaAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_SocialMediaType_SocialMediaAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_SocialMediaType_SocialMediaAction_SocialMediaActionLengthOfGotoNextTimer:
    case Action_SocialMediaType_SocialMediaAction_SocialMediaActionSpecifiedTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_CommunicationType

@implementation Action_CommunicationType

@dynamic commandTypeDataOneOfCase;
@dynamic hasDeviceIdentification, deviceIdentification;
@dynamic format;
@dynamic description_p;
@dynamic commandsArray, commandsArray_Count;
@dynamic midiCommand;
@dynamic globalCacheCommand;
@dynamic gvg100Command;
@dynamic sonyBvsCommand;

typedef struct Action_CommunicationType__storage_ {
  uint32_t _has_storage_[2];
  CollectionElementType *deviceIdentification;
  NSString *format;
  NSString *description_p;
  NSMutableArray *commandsArray;
  Action_CommunicationType_MIDICommand *midiCommand;
  Action_CommunicationType_GlobalCacheCommand *globalCacheCommand;
  Action_CommunicationType_GVG100Command *gvg100Command;
  Action_CommunicationType_SonyBVSCommand *sonyBvsCommand;
} Action_CommunicationType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceIdentification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_CommunicationType_FieldNumber_DeviceIdentification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, deviceIdentification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, format),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "commandsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType_Command),
        .number = Action_CommunicationType_FieldNumber_CommandsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, commandsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "midiCommand",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType_MIDICommand),
        .number = Action_CommunicationType_FieldNumber_MidiCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, midiCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "globalCacheCommand",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType_GlobalCacheCommand),
        .number = Action_CommunicationType_FieldNumber_GlobalCacheCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, globalCacheCommand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gvg100Command",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType_GVG100Command),
        .number = Action_CommunicationType_FieldNumber_Gvg100Command,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, gvg100Command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sonyBvsCommand",
        .dataTypeSpecific.clazz = GPBObjCClass(Action_CommunicationType_SonyBVSCommand),
        .number = Action_CommunicationType_FieldNumber_SonyBvsCommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Action_CommunicationType__storage_, sonyBvsCommand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "commandTypeData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\004\343\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Action_CommunicationType_ClearCommandTypeDataOneOfCase(Action_CommunicationType *message) {
  GPBDescriptor *descriptor = [Action_CommunicationType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Action_CommunicationType_Command

@implementation Action_CommunicationType_Command

@dynamic name;
@dynamic value;
@dynamic hasReplacementRange, replacementRange;
@dynamic possibleValuesArray, possibleValuesArray_Count;

typedef struct Action_CommunicationType_Command__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
  IntRange *replacementRange;
  NSMutableArray *possibleValuesArray;
} Action_CommunicationType_Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_Command_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType_Command__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_Command_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_CommunicationType_Command__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "replacementRange",
        .dataTypeSpecific.clazz = GPBObjCClass(IntRange),
        .number = Action_CommunicationType_Command_FieldNumber_ReplacementRange,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_CommunicationType_Command__storage_, replacementRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "possibleValuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_Command_FieldNumber_PossibleValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Action_CommunicationType_Command__storage_, possibleValuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType_Command class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType_Command__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_CommunicationType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_CommunicationType_MIDICommand

@implementation Action_CommunicationType_MIDICommand

@dynamic state;
@dynamic channel;
@dynamic note;
@dynamic intensity;

typedef struct Action_CommunicationType_MIDICommand__storage_ {
  uint32_t _has_storage_[1];
  Action_CommunicationType_MIDICommand_State state;
  uint32_t channel;
  uint32_t note;
  uint32_t intensity;
} Action_CommunicationType_MIDICommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = Action_CommunicationType_MIDICommand_State_EnumDescriptor,
        .number = Action_CommunicationType_MIDICommand_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType_MIDICommand__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "channel",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_MIDICommand_FieldNumber_Channel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_CommunicationType_MIDICommand__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "note",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_MIDICommand_FieldNumber_Note,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_CommunicationType_MIDICommand__storage_, note),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "intensity",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_MIDICommand_FieldNumber_Intensity,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_CommunicationType_MIDICommand__storage_, intensity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType_MIDICommand class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType_MIDICommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_CommunicationType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_CommunicationType_MIDICommand_State_RawValue(Action_CommunicationType_MIDICommand *message) {
  GPBDescriptor *descriptor = [Action_CommunicationType_MIDICommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_MIDICommand_FieldNumber_State];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_CommunicationType_MIDICommand_State_RawValue(Action_CommunicationType_MIDICommand *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_CommunicationType_MIDICommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_MIDICommand_FieldNumber_State];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_CommunicationType_MIDICommand_State

GPBEnumDescriptor *Action_CommunicationType_MIDICommand_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StateOn\000StateOff\000";
    static const int32_t values[] = {
        Action_CommunicationType_MIDICommand_State_StateOn,
        Action_CommunicationType_MIDICommand_State_StateOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_CommunicationType_MIDICommand_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_CommunicationType_MIDICommand_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_CommunicationType_MIDICommand_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_CommunicationType_MIDICommand_State_StateOn:
    case Action_CommunicationType_MIDICommand_State_StateOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_CommunicationType_GlobalCacheCommand

@implementation Action_CommunicationType_GlobalCacheCommand

@dynamic commandAction;
@dynamic output;
@dynamic interval;

typedef struct Action_CommunicationType_GlobalCacheCommand__storage_ {
  uint32_t _has_storage_[1];
  Action_CommunicationType_GlobalCacheCommand_CommandAction commandAction;
  uint32_t output;
  uint32_t interval;
} Action_CommunicationType_GlobalCacheCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commandAction",
        .dataTypeSpecific.enumDescFunc = Action_CommunicationType_GlobalCacheCommand_CommandAction_EnumDescriptor,
        .number = Action_CommunicationType_GlobalCacheCommand_FieldNumber_CommandAction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType_GlobalCacheCommand__storage_, commandAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "output",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_GlobalCacheCommand_FieldNumber_Output,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_CommunicationType_GlobalCacheCommand__storage_, output),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "interval",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_CommunicationType_GlobalCacheCommand_FieldNumber_Interval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_CommunicationType_GlobalCacheCommand__storage_, interval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType_GlobalCacheCommand class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType_GlobalCacheCommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_CommunicationType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_CommunicationType_GlobalCacheCommand_CommandAction_RawValue(Action_CommunicationType_GlobalCacheCommand *message) {
  GPBDescriptor *descriptor = [Action_CommunicationType_GlobalCacheCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_GlobalCacheCommand_FieldNumber_CommandAction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_CommunicationType_GlobalCacheCommand_CommandAction_RawValue(Action_CommunicationType_GlobalCacheCommand *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_CommunicationType_GlobalCacheCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_GlobalCacheCommand_FieldNumber_CommandAction];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_CommunicationType_GlobalCacheCommand_CommandAction

GPBEnumDescriptor *Action_CommunicationType_GlobalCacheCommand_CommandAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CommandActionOn\000CommandActionOff\000Command"
        "ActionOnOffWithInterval\000CommandActionOff"
        "OnWithInterval\000";
    static const int32_t values[] = {
        Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOn,
        Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOff,
        Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOnOffWithInterval,
        Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOffOnWithInterval,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_CommunicationType_GlobalCacheCommand_CommandAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_CommunicationType_GlobalCacheCommand_CommandAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_CommunicationType_GlobalCacheCommand_CommandAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOn:
    case Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOff:
    case Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOnOffWithInterval:
    case Action_CommunicationType_GlobalCacheCommand_CommandAction_CommandActionOffOnWithInterval:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_CommunicationType_GVG100Command

@implementation Action_CommunicationType_GVG100Command

@dynamic commandAction;

typedef struct Action_CommunicationType_GVG100Command__storage_ {
  uint32_t _has_storage_[1];
  Action_CommunicationType_GVG100Command_CommandAction commandAction;
} Action_CommunicationType_GVG100Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commandAction",
        .dataTypeSpecific.enumDescFunc = Action_CommunicationType_GVG100Command_CommandAction_EnumDescriptor,
        .number = Action_CommunicationType_GVG100Command_FieldNumber_CommandAction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType_GVG100Command__storage_, commandAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType_GVG100Command class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType_GVG100Command__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_CommunicationType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_CommunicationType_GVG100Command_CommandAction_RawValue(Action_CommunicationType_GVG100Command *message) {
  GPBDescriptor *descriptor = [Action_CommunicationType_GVG100Command descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_GVG100Command_FieldNumber_CommandAction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_CommunicationType_GVG100Command_CommandAction_RawValue(Action_CommunicationType_GVG100Command *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_CommunicationType_GVG100Command descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_GVG100Command_FieldNumber_CommandAction];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_CommunicationType_GVG100Command_CommandAction

GPBEnumDescriptor *Action_CommunicationType_GVG100Command_CommandAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CommandActionFadeToBlack\000CommandActionDs"
        "kToggle\000";
    static const int32_t values[] = {
        Action_CommunicationType_GVG100Command_CommandAction_CommandActionFadeToBlack,
        Action_CommunicationType_GVG100Command_CommandAction_CommandActionDskToggle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_CommunicationType_GVG100Command_CommandAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_CommunicationType_GVG100Command_CommandAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_CommunicationType_GVG100Command_CommandAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_CommunicationType_GVG100Command_CommandAction_CommandActionFadeToBlack:
    case Action_CommunicationType_GVG100Command_CommandAction_CommandActionDskToggle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_CommunicationType_SonyBVSCommand

@implementation Action_CommunicationType_SonyBVSCommand

@dynamic commandAction;

typedef struct Action_CommunicationType_SonyBVSCommand__storage_ {
  uint32_t _has_storage_[1];
  Action_CommunicationType_SonyBVSCommand_CommandAction commandAction;
} Action_CommunicationType_SonyBVSCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commandAction",
        .dataTypeSpecific.enumDescFunc = Action_CommunicationType_SonyBVSCommand_CommandAction_EnumDescriptor,
        .number = Action_CommunicationType_SonyBVSCommand_FieldNumber_CommandAction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_CommunicationType_SonyBVSCommand__storage_, commandAction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_CommunicationType_SonyBVSCommand class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_CommunicationType_SonyBVSCommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action_CommunicationType)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_CommunicationType_SonyBVSCommand_CommandAction_RawValue(Action_CommunicationType_SonyBVSCommand *message) {
  GPBDescriptor *descriptor = [Action_CommunicationType_SonyBVSCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_SonyBVSCommand_FieldNumber_CommandAction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_CommunicationType_SonyBVSCommand_CommandAction_RawValue(Action_CommunicationType_SonyBVSCommand *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_CommunicationType_SonyBVSCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_CommunicationType_SonyBVSCommand_FieldNumber_CommandAction];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_CommunicationType_SonyBVSCommand_CommandAction

GPBEnumDescriptor *Action_CommunicationType_SonyBVSCommand_CommandAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CommandActionFadeToBlack\000CommandActionKe"
        "yOn\000CommandActionKeyOff\000CommandActionDsk"
        "On\000CommandActionDskOff\000";
    static const int32_t values[] = {
        Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionFadeToBlack,
        Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionKeyOn,
        Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionKeyOff,
        Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionDskOn,
        Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionDskOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_CommunicationType_SonyBVSCommand_CommandAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_CommunicationType_SonyBVSCommand_CommandAction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_CommunicationType_SonyBVSCommand_CommandAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionFadeToBlack:
    case Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionKeyOn:
    case Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionKeyOff:
    case Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionDskOn:
    case Action_CommunicationType_SonyBVSCommand_CommandAction_CommandActionDskOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_MultiScreenType

@implementation Action_MultiScreenType

@dynamic hasIdentification, identification;

typedef struct Action_MultiScreenType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_MultiScreenType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_MultiScreenType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MultiScreenType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MultiScreenType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MultiScreenType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_DocumentType

@implementation Action_DocumentType

@dynamic hasIdentification, identification;
@dynamic hasSelectedArrangement, selectedArrangement;
@dynamic contentDestination;

typedef struct Action_DocumentType__storage_ {
  uint32_t _has_storage_[1];
  Action_DocumentType_ContentDestination contentDestination;
  CollectionElementType *identification;
  UUID *selectedArrangement;
} Action_DocumentType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_DocumentType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_DocumentType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectedArrangement",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Action_DocumentType_FieldNumber_SelectedArrangement,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Action_DocumentType__storage_, selectedArrangement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentDestination",
        .dataTypeSpecific.enumDescFunc = Action_DocumentType_ContentDestination_EnumDescriptor,
        .number = Action_DocumentType_FieldNumber_ContentDestination,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Action_DocumentType__storage_, contentDestination),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_DocumentType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_DocumentType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Action_DocumentType_ContentDestination_RawValue(Action_DocumentType *message) {
  GPBDescriptor *descriptor = [Action_DocumentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_DocumentType_FieldNumber_ContentDestination];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAction_DocumentType_ContentDestination_RawValue(Action_DocumentType *message, int32_t value) {
  GPBDescriptor *descriptor = [Action_DocumentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Action_DocumentType_FieldNumber_ContentDestination];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Action_DocumentType_ContentDestination

GPBEnumDescriptor *Action_DocumentType_ContentDestination_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentDestinationGlobal\000ContentDestinat"
        "ionAnnouncements\000";
    static const int32_t values[] = {
        Action_DocumentType_ContentDestination_ContentDestinationGlobal,
        Action_DocumentType_ContentDestination_ContentDestinationAnnouncements,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action_DocumentType_ContentDestination)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_DocumentType_ContentDestination_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_DocumentType_ContentDestination_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_DocumentType_ContentDestination_ContentDestinationGlobal:
    case Action_DocumentType_ContentDestination_ContentDestinationAnnouncements:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Action_ExternalPresentationType

@implementation Action_ExternalPresentationType

@dynamic hasURL, URL;

typedef struct Action_ExternalPresentationType__storage_ {
  uint32_t _has_storage_[1];
  URL *URL;
} Action_ExternalPresentationType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Action_ExternalPresentationType_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_ExternalPresentationType__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_ExternalPresentationType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_ExternalPresentationType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_AudienceLookType

@implementation Action_AudienceLookType

@dynamic hasIdentification, identification;

typedef struct Action_AudienceLookType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_AudienceLookType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_AudienceLookType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_AudienceLookType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_AudienceLookType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_AudienceLookType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_AudioInputType

@implementation Action_AudioInputType

@dynamic index;
@dynamic overrideMode;
@dynamic hasBehaviorMode, behaviorMode;
@dynamic overrideVolume;
@dynamic volume;

typedef struct Action_AudioInputType__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  AudioInput_BehaviorMode *behaviorMode;
  double volume;
} Action_AudioInputType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_AudioInputType_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_AudioInputType__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "overrideMode",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_AudioInputType_FieldNumber_OverrideMode,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "behaviorMode",
        .dataTypeSpecific.clazz = GPBObjCClass(AudioInput_BehaviorMode),
        .number = Action_AudioInputType_FieldNumber_BehaviorMode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Action_AudioInputType__storage_, behaviorMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "overrideVolume",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_AudioInputType_FieldNumber_OverrideVolume,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = Action_AudioInputType_FieldNumber_Volume,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Action_AudioInputType__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_AudioInputType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_AudioInputType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Action_MacroType

@implementation Action_MacroType

@dynamic hasIdentification, identification;

typedef struct Action_MacroType__storage_ {
  uint32_t _has_storage_[1];
  CollectionElementType *identification;
} Action_MacroType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identification",
        .dataTypeSpecific.clazz = GPBObjCClass(CollectionElementType),
        .number = Action_MacroType_FieldNumber_Identification,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Action_MacroType__storage_, identification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Action_MacroType class]
                                     rootClass:[ActionRoot class]
                                          file:ActionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Action_MacroType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Action)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
