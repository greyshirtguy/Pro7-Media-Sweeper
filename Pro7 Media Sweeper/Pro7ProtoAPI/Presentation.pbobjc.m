// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: presentation.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Presentation.pbobjc.h"
#import "Action.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "Cue.pbobjc.h"
#import "Timestamp.pbobjc.h"
#import "Background.pbobjc.h"
#import "Effects.pbobjc.h"
#import "Groups.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Action);
GPBObjCClassDeclaration(ApplicationInfo);
GPBObjCClassDeclaration(Background);
GPBObjCClassDeclaration(Cue);
GPBObjCClassDeclaration(Group);
GPBObjCClassDeclaration(IntRange);
GPBObjCClassDeclaration(Presentation);
GPBObjCClassDeclaration(Presentation_Arrangement);
GPBObjCClassDeclaration(Presentation_BibleReference);
GPBObjCClassDeclaration(Presentation_CCLI);
GPBObjCClassDeclaration(Presentation_CueGroup);
GPBObjCClassDeclaration(Presentation_SocialMedia);
GPBObjCClassDeclaration(Presentation_Timeline);
GPBObjCClassDeclaration(Presentation_Timeline_Cue);
GPBObjCClassDeclaration(Timestamp);
GPBObjCClassDeclaration(Transition);
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(UUID);

#pragma mark - PresentationRoot

@implementation PresentationRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PresentationRoot_FileDescriptor

static GPBFileDescriptor *PresentationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Presentation

@implementation Presentation

@dynamic slideShowOneOfCase;
@dynamic hasApplicationInfo, applicationInfo;
@dynamic hasUuid, uuid;
@dynamic name;
@dynamic hasLastDateUsed, lastDateUsed;
@dynamic hasLastModifiedDate, lastModifiedDate;
@dynamic category;
@dynamic notes;
@dynamic hasBackground, background;
@dynamic hasChordChart, chordChart;
@dynamic hasSelectedArrangement, selectedArrangement;
@dynamic arrangementsArray, arrangementsArray_Count;
@dynamic cueGroupsArray, cueGroupsArray_Count;
@dynamic cuesArray, cuesArray_Count;
@dynamic hasCcli, ccli;
@dynamic hasBibleReference, bibleReference;
@dynamic hasSocialMedia, socialMedia;
@dynamic hasTimeline, timeline;
@dynamic hasTransition, transition;
@dynamic contentDestination;
@dynamic slideShowDuration;

typedef struct Presentation__storage_ {
  uint32_t _has_storage_[2];
  Presentation_ContentDestination contentDestination;
  ApplicationInfo *applicationInfo;
  UUID *uuid;
  NSString *name;
  Timestamp *lastDateUsed;
  Timestamp *lastModifiedDate;
  NSString *category;
  NSString *notes;
  Background *background;
  URL *chordChart;
  UUID *selectedArrangement;
  NSMutableArray *arrangementsArray;
  NSMutableArray *cueGroupsArray;
  NSMutableArray *cuesArray;
  Presentation_CCLI *ccli;
  Presentation_BibleReference *bibleReference;
  Presentation_SocialMedia *socialMedia;
  Presentation_Timeline *timeline;
  Transition *transition;
  double slideShowDuration;
} Presentation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applicationInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ApplicationInfo),
        .number = Presentation_FieldNumber_ApplicationInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation__storage_, applicationInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Presentation__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastDateUsed",
        .dataTypeSpecific.clazz = GPBObjCClass(Timestamp),
        .number = Presentation_FieldNumber_LastDateUsed,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Presentation__storage_, lastDateUsed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastModifiedDate",
        .dataTypeSpecific.clazz = GPBObjCClass(Timestamp),
        .number = Presentation_FieldNumber_LastModifiedDate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Presentation__storage_, lastModifiedDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "category",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_FieldNumber_Category,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Presentation__storage_, category),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notes",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_FieldNumber_Notes,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Presentation__storage_, notes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "background",
        .dataTypeSpecific.clazz = GPBObjCClass(Background),
        .number = Presentation_FieldNumber_Background,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Presentation__storage_, background),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chordChart",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Presentation_FieldNumber_ChordChart,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Presentation__storage_, chordChart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selectedArrangement",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_FieldNumber_SelectedArrangement,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Presentation__storage_, selectedArrangement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "arrangementsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_Arrangement),
        .number = Presentation_FieldNumber_ArrangementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation__storage_, arrangementsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cueGroupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_CueGroup),
        .number = Presentation_FieldNumber_CueGroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation__storage_, cueGroupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Cue),
        .number = Presentation_FieldNumber_CuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation__storage_, cuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ccli",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_CCLI),
        .number = Presentation_FieldNumber_Ccli,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Presentation__storage_, ccli),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bibleReference",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_BibleReference),
        .number = Presentation_FieldNumber_BibleReference,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Presentation__storage_, bibleReference),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "socialMedia",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_SocialMedia),
        .number = Presentation_FieldNumber_SocialMedia,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Presentation__storage_, socialMedia),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeline",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_Timeline),
        .number = Presentation_FieldNumber_Timeline,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Presentation__storage_, timeline),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transition",
        .dataTypeSpecific.clazz = GPBObjCClass(Transition),
        .number = Presentation_FieldNumber_Transition,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Presentation__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentDestination",
        .dataTypeSpecific.enumDescFunc = Presentation_ContentDestination_EnumDescriptor,
        .number = Presentation_FieldNumber_ContentDestination,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Presentation__storage_, contentDestination),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "slideShowDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_FieldNumber_SlideShowDuration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Presentation__storage_, slideShowDuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "slideShow",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Presentation_ContentDestination_RawValue(Presentation *message) {
  GPBDescriptor *descriptor = [Presentation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Presentation_FieldNumber_ContentDestination];
  return GPBGetMessageRawEnumField(message, field);
}

void SetPresentation_ContentDestination_RawValue(Presentation *message, int32_t value) {
  GPBDescriptor *descriptor = [Presentation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Presentation_FieldNumber_ContentDestination];
  GPBSetMessageRawEnumField(message, field, value);
}

void Presentation_ClearSlideShowOneOfCase(Presentation *message) {
  GPBDescriptor *descriptor = [Presentation descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Presentation_ContentDestination

GPBEnumDescriptor *Presentation_ContentDestination_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentDestinationGlobal\000ContentDestinat"
        "ionAnnouncements\000";
    static const int32_t values[] = {
        Presentation_ContentDestination_ContentDestinationGlobal,
        Presentation_ContentDestination_ContentDestinationAnnouncements,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Presentation_ContentDestination)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Presentation_ContentDestination_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Presentation_ContentDestination_IsValidValue(int32_t value__) {
  switch (value__) {
    case Presentation_ContentDestination_ContentDestinationGlobal:
    case Presentation_ContentDestination_ContentDestinationAnnouncements:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Presentation_CCLI

@implementation Presentation_CCLI

@dynamic author;
@dynamic artistCredits;
@dynamic songTitle;
@dynamic publisher;
@dynamic copyrightYear;
@dynamic songNumber;
@dynamic display;

typedef struct Presentation_CCLI__storage_ {
  uint32_t _has_storage_[1];
  uint32_t copyrightYear;
  uint32_t songNumber;
  NSString *author;
  NSString *artistCredits;
  NSString *songTitle;
  NSString *publisher;
} Presentation_CCLI__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "author",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_Author,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, author),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "artistCredits",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_ArtistCredits,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, artistCredits),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "songTitle",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_SongTitle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, songTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publisher",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_Publisher,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, publisher),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "copyrightYear",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_CopyrightYear,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, copyrightYear),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "songNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_SongNumber,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Presentation_CCLI__storage_, songNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "display",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_CCLI_FieldNumber_Display,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_CCLI class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_CCLI__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Presentation_BibleReference

@implementation Presentation_BibleReference

@dynamic bookIndex;
@dynamic bookName;
@dynamic hasChapterRange, chapterRange;
@dynamic hasVerseRange, verseRange;
@dynamic translationName;
@dynamic translationDisplayAbbreviation;
@dynamic translationInternalAbbreviation;
@dynamic bookKey;

typedef struct Presentation_BibleReference__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bookIndex;
  NSString *bookName;
  IntRange *chapterRange;
  IntRange *verseRange;
  NSString *translationName;
  NSString *translationDisplayAbbreviation;
  NSString *translationInternalAbbreviation;
  NSString *bookKey;
} Presentation_BibleReference__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bookIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_BookIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, bookIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bookName",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_BookName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, bookName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chapterRange",
        .dataTypeSpecific.clazz = GPBObjCClass(IntRange),
        .number = Presentation_BibleReference_FieldNumber_ChapterRange,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, chapterRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verseRange",
        .dataTypeSpecific.clazz = GPBObjCClass(IntRange),
        .number = Presentation_BibleReference_FieldNumber_VerseRange,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, verseRange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "translationName",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_TranslationName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, translationName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "translationDisplayAbbreviation",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_TranslationDisplayAbbreviation,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, translationDisplayAbbreviation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "translationInternalAbbreviation",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_TranslationInternalAbbreviation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, translationInternalAbbreviation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bookKey",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_BibleReference_FieldNumber_BookKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Presentation_BibleReference__storage_, bookKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_BibleReference class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_BibleReference__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Presentation_SocialMedia

@implementation Presentation_SocialMedia

@dynamic term;
@dynamic hasTime, time;

typedef struct Presentation_SocialMedia__storage_ {
  uint32_t _has_storage_[1];
  NSString *term;
  Timestamp *time;
} Presentation_SocialMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "term",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_SocialMedia_FieldNumber_Term,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_SocialMedia__storage_, term),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(Timestamp),
        .number = Presentation_SocialMedia_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation_SocialMedia__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_SocialMedia class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_SocialMedia__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Presentation_Timeline

@implementation Presentation_Timeline

@dynamic cuesArray, cuesArray_Count;
@dynamic duration;
@dynamic loop;
@dynamic hasAudioAction, audioAction;

typedef struct Presentation_Timeline__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cuesArray;
  Action *audioAction;
  double duration;
} Presentation_Timeline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Presentation_Timeline_Cue),
        .number = Presentation_Timeline_FieldNumber_CuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation_Timeline__storage_, cuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_Timeline_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_Timeline__storage_, duration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "loop",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_Timeline_FieldNumber_Loop,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "audioAction",
        .dataTypeSpecific.clazz = GPBObjCClass(Action),
        .number = Presentation_Timeline_FieldNumber_AudioAction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Presentation_Timeline__storage_, audioAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_Timeline class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_Timeline__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Presentation_Timeline_Cue

@implementation Presentation_Timeline_Cue

@dynamic triggerInfoOneOfCase;
@dynamic triggerTime;
@dynamic name;
@dynamic cueId;
@dynamic mediaAction;

typedef struct Presentation_Timeline_Cue__storage_ {
  uint32_t _has_storage_[2];
  UUID *cueId;
  NSString *name;
  Action *mediaAction;
  double triggerTime;
} Presentation_Timeline_Cue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_Timeline_Cue_FieldNumber_TriggerTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_Timeline_Cue__storage_, triggerTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "cueId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_Timeline_Cue_FieldNumber_CueId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Presentation_Timeline_Cue__storage_, cueId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_Timeline_Cue_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation_Timeline_Cue__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaAction",
        .dataTypeSpecific.clazz = GPBObjCClass(Action),
        .number = Presentation_Timeline_Cue_FieldNumber_MediaAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Presentation_Timeline_Cue__storage_, mediaAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_Timeline_Cue class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_Timeline_Cue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "triggerInfo",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation_Timeline)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Presentation_Timeline_Cue_ClearTriggerInfoOneOfCase(Presentation_Timeline_Cue *message) {
  GPBDescriptor *descriptor = [Presentation_Timeline_Cue descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Presentation_Arrangement

@implementation Presentation_Arrangement

@dynamic hasUuid, uuid;
@dynamic name;
@dynamic groupIdentifiersArray, groupIdentifiersArray_Count;

typedef struct Presentation_Arrangement__storage_ {
  uint32_t _has_storage_[1];
  UUID *uuid;
  NSString *name;
  NSMutableArray *groupIdentifiersArray;
} Presentation_Arrangement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_Arrangement_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_Arrangement__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Presentation_Arrangement_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Presentation_Arrangement__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupIdentifiersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_Arrangement_FieldNumber_GroupIdentifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation_Arrangement__storage_, groupIdentifiersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_Arrangement class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_Arrangement__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Presentation_CueGroup

@implementation Presentation_CueGroup

@dynamic hasGroup, group;
@dynamic cueIdentifiersArray, cueIdentifiersArray_Count;

typedef struct Presentation_CueGroup__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
  NSMutableArray *cueIdentifiersArray;
} Presentation_CueGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.clazz = GPBObjCClass(Group),
        .number = Presentation_CueGroup_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Presentation_CueGroup__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cueIdentifiersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Presentation_CueGroup_FieldNumber_CueIdentifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Presentation_CueGroup__storage_, cueIdentifiersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Presentation_CueGroup class]
                                     rootClass:[PresentationRoot class]
                                          file:PresentationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Presentation_CueGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Presentation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
