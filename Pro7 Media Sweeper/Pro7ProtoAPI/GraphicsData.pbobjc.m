// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: graphicsData.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "GraphicsData.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "Effects.pbobjc.h"
#import "DigitalAudio.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(DigitalAudio_Device_Routing);
GPBObjCClassDeclaration(Effect);
GPBObjCClassDeclaration(Graphics);
GPBObjCClassDeclaration(Graphics_EdgeInsets);
GPBObjCClassDeclaration(Graphics_Feather);
GPBObjCClassDeclaration(Graphics_Fill);
GPBObjCClassDeclaration(Graphics_Gradient);
GPBObjCClassDeclaration(Graphics_Gradient_ColorStop);
GPBObjCClassDeclaration(Graphics_Path);
GPBObjCClassDeclaration(Graphics_Path_BezierPoint);
GPBObjCClassDeclaration(Graphics_Path_Shape);
GPBObjCClassDeclaration(Graphics_Path_Shape_Arrow);
GPBObjCClassDeclaration(Graphics_Path_Shape_Polygon);
GPBObjCClassDeclaration(Graphics_Path_Shape_RoundedRectangle);
GPBObjCClassDeclaration(Graphics_Path_Shape_Star);
GPBObjCClassDeclaration(Graphics_Point);
GPBObjCClassDeclaration(Graphics_Rect);
GPBObjCClassDeclaration(Graphics_Shadow);
GPBObjCClassDeclaration(Graphics_Size);
GPBObjCClassDeclaration(Graphics_Stroke);
GPBObjCClassDeclaration(Graphics_Text);
GPBObjCClassDeclaration(Graphics_Text_Attributes);
GPBObjCClassDeclaration(Graphics_Text_Attributes_CustomAttribute);
GPBObjCClassDeclaration(Graphics_Text_Attributes_Font);
GPBObjCClassDeclaration(Graphics_Text_Attributes_Paragraph);
GPBObjCClassDeclaration(Graphics_Text_Attributes_Paragraph_TabStop);
GPBObjCClassDeclaration(Graphics_Text_Attributes_Paragraph_TextList);
GPBObjCClassDeclaration(Graphics_Text_Attributes_Underline);
GPBObjCClassDeclaration(Graphics_Text_GradientFill);
GPBObjCClassDeclaration(Graphics_Text_LineFillMask);
GPBObjCClassDeclaration(IntRange);
GPBObjCClassDeclaration(Media);
GPBObjCClassDeclaration(Media_Audio);
GPBObjCClassDeclaration(Media_AudioDevice);
GPBObjCClassDeclaration(Media_AudioProperties);
GPBObjCClassDeclaration(Media_AudioTypeProperties);
GPBObjCClassDeclaration(Media_Audio_Channel);
GPBObjCClassDeclaration(Media_Audio_Channel_Output);
GPBObjCClassDeclaration(Media_DrawingProperties);
GPBObjCClassDeclaration(Media_ImageTypeProperties);
GPBObjCClassDeclaration(Media_LiveVideoProperties);
GPBObjCClassDeclaration(Media_LiveVideoTypeProperties);
GPBObjCClassDeclaration(Media_Metadata);
GPBObjCClassDeclaration(Media_TransportProperties);
GPBObjCClassDeclaration(Media_VideoDevice);
GPBObjCClassDeclaration(Media_VideoProperties);
GPBObjCClassDeclaration(Media_VideoTypeProperties);
GPBObjCClassDeclaration(Media_WebContentTypeProperties);
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(UUID);

#pragma mark - GraphicsDataRoot

@implementation GraphicsDataRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - GraphicsDataRoot_FileDescriptor

static GPBFileDescriptor *GraphicsDataRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Graphics

@implementation Graphics


typedef struct Graphics__storage_ {
  uint32_t _has_storage_[1];
} Graphics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Graphics__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Element

@implementation Graphics_Element

@dynamic maskOneOfCase;
@dynamic hasUuid, uuid;
@dynamic name;
@dynamic hasBounds, bounds;
@dynamic rotation;
@dynamic opacity;
@dynamic locked;
@dynamic aspectRatioLocked;
@dynamic hasPath, path;
@dynamic hasFill, fill;
@dynamic hasStroke, stroke;
@dynamic hasShadow, shadow;
@dynamic hasFeather, feather;
@dynamic hasText, text;
@dynamic flipMode;
@dynamic hidden;
@dynamic textLineMask;

typedef struct Graphics_Element__storage_ {
  uint32_t _has_storage_[2];
  Graphics_Element_FlipMode flipMode;
  UUID *uuid;
  NSString *name;
  Graphics_Rect *bounds;
  Graphics_Path *path;
  Graphics_Fill *fill;
  Graphics_Stroke *stroke;
  Graphics_Shadow *shadow;
  Graphics_Feather *feather;
  Graphics_Text *text;
  Graphics_Text_LineFillMask *textLineMask;
  double rotation;
  double opacity;
} Graphics_Element__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Graphics_Element_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Rect),
        .number = Graphics_Element_FieldNumber_Bounds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rotation",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_Rotation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, rotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "opacity",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_Opacity,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, opacity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "locked",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_Locked,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "aspectRatioLocked",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_AspectRatioLocked,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path),
        .number = Graphics_Element_FieldNumber_Path,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fill",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Fill),
        .number = Graphics_Element_FieldNumber_Fill,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, fill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stroke",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Stroke),
        .number = Graphics_Element_FieldNumber_Stroke,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, stroke),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shadow",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Shadow),
        .number = Graphics_Element_FieldNumber_Shadow,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, shadow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "feather",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Feather),
        .number = Graphics_Element_FieldNumber_Feather,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, feather),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text),
        .number = Graphics_Element_FieldNumber_Text,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textLineMask",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_LineFillMask),
        .number = Graphics_Element_FieldNumber_TextLineMask,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, textLineMask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flipMode",
        .dataTypeSpecific.enumDescFunc = Graphics_Element_FlipMode_EnumDescriptor,
        .number = Graphics_Element_FieldNumber_FlipMode,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Graphics_Element__storage_, flipMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Element_FieldNumber_Hidden,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Element class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Element__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "mask",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\017\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Element_FlipMode_RawValue(Graphics_Element *message) {
  GPBDescriptor *descriptor = [Graphics_Element descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Element_FieldNumber_FlipMode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Element_FlipMode_RawValue(Graphics_Element *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Element descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Element_FieldNumber_FlipMode];
  GPBSetMessageRawEnumField(message, field, value);
}

void Graphics_Element_ClearMaskOneOfCase(Graphics_Element *message) {
  GPBDescriptor *descriptor = [Graphics_Element descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Graphics_Element_FlipMode

GPBEnumDescriptor *Graphics_Element_FlipMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FlipModeNone\000FlipModeVertical\000FlipModeHo"
        "rizontal\000FlipModeBoth\000";
    static const int32_t values[] = {
        Graphics_Element_FlipMode_FlipModeNone,
        Graphics_Element_FlipMode_FlipModeVertical,
        Graphics_Element_FlipMode_FlipModeHorizontal,
        Graphics_Element_FlipMode_FlipModeBoth,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Element_FlipMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Element_FlipMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Element_FlipMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Element_FlipMode_FlipModeNone:
    case Graphics_Element_FlipMode_FlipModeVertical:
    case Graphics_Element_FlipMode_FlipModeHorizontal:
    case Graphics_Element_FlipMode_FlipModeBoth:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Rect

@implementation Graphics_Rect

@dynamic hasOrigin, origin;
@dynamic hasSize, size;

typedef struct Graphics_Rect__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Point *origin;
  Graphics_Size *size;
} Graphics_Rect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = Graphics_Rect_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Rect__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Size),
        .number = Graphics_Rect_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Rect__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Rect class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Rect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Point

@implementation Graphics_Point

@dynamic x;
@dynamic y;

typedef struct Graphics_Point__storage_ {
  uint32_t _has_storage_[1];
  double x;
  double y;
} Graphics_Point__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Point_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Point__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Point_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Point__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Point class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Point__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Size

@implementation Graphics_Size

@dynamic width;
@dynamic height;

typedef struct Graphics_Size__storage_ {
  uint32_t _has_storage_[1];
  double width;
  double height;
} Graphics_Size__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Size_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Size__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Size_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Size__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Size class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Size__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_EdgeInsets

@implementation Graphics_EdgeInsets

@dynamic left;
@dynamic right;
@dynamic top;
@dynamic bottom;

typedef struct Graphics_EdgeInsets__storage_ {
  uint32_t _has_storage_[1];
  double left;
  double right;
  double top;
  double bottom;
} Graphics_EdgeInsets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "left",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_EdgeInsets_FieldNumber_Left,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_EdgeInsets__storage_, left),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "right",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_EdgeInsets_FieldNumber_Right,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_EdgeInsets__storage_, right),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "top",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_EdgeInsets_FieldNumber_Top,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_EdgeInsets__storage_, top),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bottom",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_EdgeInsets_FieldNumber_Bottom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_EdgeInsets__storage_, bottom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_EdgeInsets class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_EdgeInsets__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path

@implementation Graphics_Path

@dynamic closed;
@dynamic pointsArray, pointsArray_Count;
@dynamic hasShape, shape;

typedef struct Graphics_Path__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pointsArray;
  Graphics_Path_Shape *shape;
} Graphics_Path__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closed",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_FieldNumber_Closed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pointsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_BezierPoint),
        .number = Graphics_Path_FieldNumber_PointsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Path__storage_, pointsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shape",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_Shape),
        .number = Graphics_Path_FieldNumber_Shape,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Path__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path_BezierPoint

@implementation Graphics_Path_BezierPoint

@dynamic hasPoint, point;
@dynamic hasQ0, q0;
@dynamic hasQ1, q1;
@dynamic curved;

typedef struct Graphics_Path_BezierPoint__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Point *point;
  Graphics_Point *q0;
  Graphics_Point *q1;
} Graphics_Path_BezierPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "point",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = Graphics_Path_BezierPoint_FieldNumber_Point,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_BezierPoint__storage_, point),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "q0",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = Graphics_Path_BezierPoint_FieldNumber_Q0,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Path_BezierPoint__storage_, q0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "q1",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = Graphics_Path_BezierPoint_FieldNumber_Q1,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Path_BezierPoint__storage_, q1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "curved",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_BezierPoint_FieldNumber_Curved,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_BezierPoint class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_BezierPoint__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path_Shape

@implementation Graphics_Path_Shape

@dynamic additionalDataOneOfCase;
@dynamic type;
@dynamic roundedRectangle;
@dynamic polygon;
@dynamic star;
@dynamic arrow;

typedef struct Graphics_Path_Shape__storage_ {
  uint32_t _has_storage_[2];
  Graphics_Path_Shape_Type type;
  Graphics_Path_Shape_RoundedRectangle *roundedRectangle;
  Graphics_Path_Shape_Polygon *polygon;
  Graphics_Path_Shape_Star *star;
  Graphics_Path_Shape_Arrow *arrow;
} Graphics_Path_Shape__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Graphics_Path_Shape_Type_EnumDescriptor,
        .number = Graphics_Path_Shape_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "roundedRectangle",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_Shape_RoundedRectangle),
        .number = Graphics_Path_Shape_FieldNumber_RoundedRectangle,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape__storage_, roundedRectangle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "polygon",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_Shape_Polygon),
        .number = Graphics_Path_Shape_FieldNumber_Polygon,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape__storage_, polygon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "star",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_Shape_Star),
        .number = Graphics_Path_Shape_FieldNumber_Star,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape__storage_, star),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "arrow",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Path_Shape_Arrow),
        .number = Graphics_Path_Shape_FieldNumber_Arrow,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape__storage_, arrow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_Shape class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_Shape__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "additionalData",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Path_Shape_Type_RawValue(Graphics_Path_Shape *message) {
  GPBDescriptor *descriptor = [Graphics_Path_Shape descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Path_Shape_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Path_Shape_Type_RawValue(Graphics_Path_Shape *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Path_Shape descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Path_Shape_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void Graphics_Path_Shape_ClearAdditionalDataOneOfCase(Graphics_Path_Shape *message) {
  GPBDescriptor *descriptor = [Graphics_Path_Shape descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Graphics_Path_Shape_Type

GPBEnumDescriptor *Graphics_Path_Shape_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeUnknown\000TypeRectangle\000TypeEllipse\000Ty"
        "peIsoscelesTriangle\000TypeRightTriangle\000Ty"
        "peRhombus\000TypeStar\000TypePolygon\000TypeCusto"
        "m\000TypeRightArrow\000TypeDoubleArrow\000TypeRou"
        "ndedRectangle\000";
    static const int32_t values[] = {
        Graphics_Path_Shape_Type_TypeUnknown,
        Graphics_Path_Shape_Type_TypeRectangle,
        Graphics_Path_Shape_Type_TypeEllipse,
        Graphics_Path_Shape_Type_TypeIsoscelesTriangle,
        Graphics_Path_Shape_Type_TypeRightTriangle,
        Graphics_Path_Shape_Type_TypeRhombus,
        Graphics_Path_Shape_Type_TypeStar,
        Graphics_Path_Shape_Type_TypePolygon,
        Graphics_Path_Shape_Type_TypeCustom,
        Graphics_Path_Shape_Type_TypeRightArrow,
        Graphics_Path_Shape_Type_TypeDoubleArrow,
        Graphics_Path_Shape_Type_TypeRoundedRectangle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Path_Shape_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Path_Shape_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Path_Shape_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Path_Shape_Type_TypeUnknown:
    case Graphics_Path_Shape_Type_TypeRectangle:
    case Graphics_Path_Shape_Type_TypeEllipse:
    case Graphics_Path_Shape_Type_TypeIsoscelesTriangle:
    case Graphics_Path_Shape_Type_TypeRightTriangle:
    case Graphics_Path_Shape_Type_TypeRhombus:
    case Graphics_Path_Shape_Type_TypeStar:
    case Graphics_Path_Shape_Type_TypePolygon:
    case Graphics_Path_Shape_Type_TypeCustom:
    case Graphics_Path_Shape_Type_TypeRightArrow:
    case Graphics_Path_Shape_Type_TypeDoubleArrow:
    case Graphics_Path_Shape_Type_TypeRoundedRectangle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Path_Shape_RoundedRectangle

@implementation Graphics_Path_Shape_RoundedRectangle

@dynamic roundness;

typedef struct Graphics_Path_Shape_RoundedRectangle__storage_ {
  uint32_t _has_storage_[1];
  double roundness;
} Graphics_Path_Shape_RoundedRectangle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roundness",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_Shape_RoundedRectangle_FieldNumber_Roundness,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape_RoundedRectangle__storage_, roundness),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_Shape_RoundedRectangle class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_Shape_RoundedRectangle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path_Shape)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path_Shape_Arrow

@implementation Graphics_Path_Shape_Arrow

@dynamic hasCorner, corner;

typedef struct Graphics_Path_Shape_Arrow__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Point *corner;
} Graphics_Path_Shape_Arrow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "corner",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Point),
        .number = Graphics_Path_Shape_Arrow_FieldNumber_Corner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape_Arrow__storage_, corner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_Shape_Arrow class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_Shape_Arrow__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path_Shape)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path_Shape_Polygon

@implementation Graphics_Path_Shape_Polygon

@dynamic numberSides;

typedef struct Graphics_Path_Shape_Polygon__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numberSides;
} Graphics_Path_Shape_Polygon__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numberSides",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_Shape_Polygon_FieldNumber_NumberSides,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape_Polygon__storage_, numberSides),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_Shape_Polygon class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_Shape_Polygon__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path_Shape)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Path_Shape_Star

@implementation Graphics_Path_Shape_Star

@dynamic innerRadius;
@dynamic numberPoints;

typedef struct Graphics_Path_Shape_Star__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numberPoints;
  double innerRadius;
} Graphics_Path_Shape_Star__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "innerRadius",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_Shape_Star_FieldNumber_InnerRadius,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape_Star__storage_, innerRadius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "numberPoints",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Path_Shape_Star_FieldNumber_NumberPoints,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Path_Shape_Star__storage_, numberPoints),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Path_Shape_Star class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Path_Shape_Star__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Path_Shape)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Fill

@implementation Graphics_Fill

@dynamic fillTypeOneOfCase;
@dynamic enable;
@dynamic color;
@dynamic gradient;
@dynamic media;

typedef struct Graphics_Fill__storage_ {
  uint32_t _has_storage_[2];
  Color *color;
  Graphics_Gradient *gradient;
  Media *media;
} Graphics_Fill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Fill_FieldNumber_Color,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Fill__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gradient",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Gradient),
        .number = Graphics_Fill_FieldNumber_Gradient,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Fill__storage_, gradient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(Media),
        .number = Graphics_Fill_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Fill__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enable",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Fill_FieldNumber_Enable,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Fill class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Fill__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "fillType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Graphics_Fill_ClearFillTypeOneOfCase(Graphics_Fill *message) {
  GPBDescriptor *descriptor = [Graphics_Fill descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Graphics_Gradient

@implementation Graphics_Gradient

@dynamic type;
@dynamic angle;
@dynamic length;
@dynamic stopsArray, stopsArray_Count;

typedef struct Graphics_Gradient__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Gradient_Type type;
  NSMutableArray *stopsArray;
  double angle;
  double length;
} Graphics_Gradient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Graphics_Gradient_Type_EnumDescriptor,
        .number = Graphics_Gradient_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Gradient__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "angle",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Gradient_FieldNumber_Angle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Gradient__storage_, angle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "length",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Gradient_FieldNumber_Length,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Gradient__storage_, length),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stopsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Gradient_ColorStop),
        .number = Graphics_Gradient_FieldNumber_StopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Gradient__storage_, stopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Gradient class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Gradient__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Gradient_Type_RawValue(Graphics_Gradient *message) {
  GPBDescriptor *descriptor = [Graphics_Gradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Gradient_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Gradient_Type_RawValue(Graphics_Gradient *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Gradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Gradient_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Gradient_Type

GPBEnumDescriptor *Graphics_Gradient_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeLinear\000TypeRadial\000TypeAngle\000";
    static const int32_t values[] = {
        Graphics_Gradient_Type_TypeLinear,
        Graphics_Gradient_Type_TypeRadial,
        Graphics_Gradient_Type_TypeAngle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Gradient_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Gradient_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Gradient_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Gradient_Type_TypeLinear:
    case Graphics_Gradient_Type_TypeRadial:
    case Graphics_Gradient_Type_TypeAngle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Gradient_ColorStop

@implementation Graphics_Gradient_ColorStop

@dynamic hasColor, color;
@dynamic position;
@dynamic blendPoint;

typedef struct Graphics_Gradient_ColorStop__storage_ {
  uint32_t _has_storage_[1];
  Color *color;
  double position;
  double blendPoint;
} Graphics_Gradient_ColorStop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Gradient_ColorStop_FieldNumber_Color,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Gradient_ColorStop__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Gradient_ColorStop_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Gradient_ColorStop__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "blendPoint",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Gradient_ColorStop_FieldNumber_BlendPoint,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Gradient_ColorStop__storage_, blendPoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Gradient_ColorStop class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Gradient_ColorStop__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Gradient)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Shadow

@implementation Graphics_Shadow

@dynamic style;
@dynamic angle;
@dynamic offset;
@dynamic radius;
@dynamic hasColor, color;
@dynamic opacity;
@dynamic enable;

typedef struct Graphics_Shadow__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Shadow_Style style;
  Color *color;
  double angle;
  double offset;
  double radius;
  double opacity;
} Graphics_Shadow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = Graphics_Shadow_Style_EnumDescriptor,
        .number = Graphics_Shadow_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "angle",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Shadow_FieldNumber_Angle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, angle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Shadow_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "radius",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Shadow_FieldNumber_Radius,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, radius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Shadow_FieldNumber_Color,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opacity",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Shadow_FieldNumber_Opacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Shadow__storage_, opacity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "enable",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Shadow_FieldNumber_Enable,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Shadow class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Shadow__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Shadow_Style_RawValue(Graphics_Shadow *message) {
  GPBDescriptor *descriptor = [Graphics_Shadow descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Shadow_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Shadow_Style_RawValue(Graphics_Shadow *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Shadow descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Shadow_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Shadow_Style

GPBEnumDescriptor *Graphics_Shadow_Style_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StyleDrop\000";
    static const int32_t values[] = {
        Graphics_Shadow_Style_StyleDrop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Shadow_Style)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Shadow_Style_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Shadow_Style_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Shadow_Style_StyleDrop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Stroke

@implementation Graphics_Stroke

@dynamic style;
@dynamic width;
@dynamic hasColor, color;
@dynamic patternArray, patternArray_Count;
@dynamic enable;

typedef struct Graphics_Stroke__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Stroke_Style style;
  Color *color;
  GPBDoubleArray *patternArray;
  double width;
} Graphics_Stroke__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = Graphics_Stroke_Style_EnumDescriptor,
        .number = Graphics_Stroke_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Stroke__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Stroke_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Stroke__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Stroke_FieldNumber_Color,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Stroke__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "patternArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Stroke_FieldNumber_PatternArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Stroke__storage_, patternArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "enable",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Stroke_FieldNumber_Enable,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Stroke class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Stroke__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Stroke_Style_RawValue(Graphics_Stroke *message) {
  GPBDescriptor *descriptor = [Graphics_Stroke descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Stroke_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Stroke_Style_RawValue(Graphics_Stroke *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Stroke descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Stroke_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Stroke_Style

GPBEnumDescriptor *Graphics_Stroke_Style_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StyleSolidLine\000StyleSquareDash\000StyleShor"
        "tDash\000StyleLongDash\000";
    static const int32_t values[] = {
        Graphics_Stroke_Style_StyleSolidLine,
        Graphics_Stroke_Style_StyleSquareDash,
        Graphics_Stroke_Style_StyleShortDash,
        Graphics_Stroke_Style_StyleLongDash,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Stroke_Style)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Stroke_Style_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Stroke_Style_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Stroke_Style_StyleSolidLine:
    case Graphics_Stroke_Style_StyleSquareDash:
    case Graphics_Stroke_Style_StyleShortDash:
    case Graphics_Stroke_Style_StyleLongDash:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Feather

@implementation Graphics_Feather

@dynamic style;
@dynamic radius;
@dynamic enable;

typedef struct Graphics_Feather__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Feather_Style style;
  double radius;
} Graphics_Feather__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = Graphics_Feather_Style_EnumDescriptor,
        .number = Graphics_Feather_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Feather__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "radius",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Feather_FieldNumber_Radius,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Feather__storage_, radius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "enable",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Feather_FieldNumber_Enable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Feather class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Feather__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Feather_Style_RawValue(Graphics_Feather *message) {
  GPBDescriptor *descriptor = [Graphics_Feather descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Feather_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Feather_Style_RawValue(Graphics_Feather *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Feather descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Feather_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Feather_Style

GPBEnumDescriptor *Graphics_Feather_Style_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StyleInside\000StyleCenter\000StyleOutside\000";
    static const int32_t values[] = {
        Graphics_Feather_Style_StyleInside,
        Graphics_Feather_Style_StyleCenter,
        Graphics_Feather_Style_StyleOutside,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Feather_Style)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Feather_Style_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Feather_Style_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Feather_Style_StyleInside:
    case Graphics_Feather_Style_StyleCenter:
    case Graphics_Feather_Style_StyleOutside:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text

@implementation Graphics_Text

@dynamic hasAttributes, attributes;
@dynamic hasShadow, shadow;
@dynamic rtfData;
@dynamic verticalAlignment;
@dynamic scaleBehavior;
@dynamic hasMargins, margins;
@dynamic isSuperscriptStandardized;
@dynamic transform;
@dynamic transformDelimiter;

typedef struct Graphics_Text__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_VerticalAlignment verticalAlignment;
  Graphics_Text_ScaleBehavior scaleBehavior;
  Graphics_Text_Transform transform;
  Graphics_Text_Attributes *attributes;
  Graphics_Shadow *shadow;
  NSData *rtfData;
  Graphics_EdgeInsets *margins;
  NSString *transformDelimiter;
} Graphics_Text__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributes",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes),
        .number = Graphics_Text_FieldNumber_Attributes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shadow",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Shadow),
        .number = Graphics_Text_FieldNumber_Shadow,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, shadow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rtfData",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_FieldNumber_RtfData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, rtfData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "verticalAlignment",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_VerticalAlignment_EnumDescriptor,
        .number = Graphics_Text_FieldNumber_VerticalAlignment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, verticalAlignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "scaleBehavior",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_ScaleBehavior_EnumDescriptor,
        .number = Graphics_Text_FieldNumber_ScaleBehavior,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, scaleBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "margins",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_EdgeInsets),
        .number = Graphics_Text_FieldNumber_Margins,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, margins),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isSuperscriptStandardized",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_FieldNumber_IsSuperscriptStandardized,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "transform",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Transform_EnumDescriptor,
        .number = Graphics_Text_FieldNumber_Transform,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, transform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transformDelimiter",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_FieldNumber_TransformDelimiter,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Graphics_Text__storage_, transformDelimiter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\013\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_VerticalAlignment_RawValue(Graphics_Text *message) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_VerticalAlignment];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_VerticalAlignment_RawValue(Graphics_Text *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_VerticalAlignment];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Graphics_Text_ScaleBehavior_RawValue(Graphics_Text *message) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_ScaleBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_ScaleBehavior_RawValue(Graphics_Text *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_ScaleBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Graphics_Text_Transform_RawValue(Graphics_Text *message) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_Transform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Transform_RawValue(Graphics_Text *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_FieldNumber_Transform];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_VerticalAlignment

GPBEnumDescriptor *Graphics_Text_VerticalAlignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VerticalAlignmentTop\000VerticalAlignmentMi"
        "ddle\000VerticalAlignmentBottom\000";
    static const int32_t values[] = {
        Graphics_Text_VerticalAlignment_VerticalAlignmentTop,
        Graphics_Text_VerticalAlignment_VerticalAlignmentMiddle,
        Graphics_Text_VerticalAlignment_VerticalAlignmentBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_VerticalAlignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_VerticalAlignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_VerticalAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_VerticalAlignment_VerticalAlignmentTop:
    case Graphics_Text_VerticalAlignment_VerticalAlignmentMiddle:
    case Graphics_Text_VerticalAlignment_VerticalAlignmentBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Graphics_Text_ScaleBehavior

GPBEnumDescriptor *Graphics_Text_ScaleBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleBehaviorNone\000ScaleBehaviorAdjustCon"
        "tainerHeight\000ScaleBehaviorScaleFontDown\000"
        "ScaleBehaviorScaleFontUp\000ScaleBehaviorSc"
        "aleFontUpDown\000";
    static const int32_t values[] = {
        Graphics_Text_ScaleBehavior_ScaleBehaviorNone,
        Graphics_Text_ScaleBehavior_ScaleBehaviorAdjustContainerHeight,
        Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontDown,
        Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontUp,
        Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontUpDown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_ScaleBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_ScaleBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_ScaleBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_ScaleBehavior_ScaleBehaviorNone:
    case Graphics_Text_ScaleBehavior_ScaleBehaviorAdjustContainerHeight:
    case Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontDown:
    case Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontUp:
    case Graphics_Text_ScaleBehavior_ScaleBehaviorScaleFontUpDown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Graphics_Text_Transform

GPBEnumDescriptor *Graphics_Text_Transform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TransformNone\000TransformSingleLine\000Transf"
        "ormOneWordPerLine\000TransformOneCharacterP"
        "erLine\000TransformReplaceLineReturns\000";
    static const int32_t values[] = {
        Graphics_Text_Transform_TransformNone,
        Graphics_Text_Transform_TransformSingleLine,
        Graphics_Text_Transform_TransformOneWordPerLine,
        Graphics_Text_Transform_TransformOneCharacterPerLine,
        Graphics_Text_Transform_TransformReplaceLineReturns,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Transform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Transform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Transform_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Transform_TransformNone:
    case Graphics_Text_Transform_TransformSingleLine:
    case Graphics_Text_Transform_TransformOneWordPerLine:
    case Graphics_Text_Transform_TransformOneCharacterPerLine:
    case Graphics_Text_Transform_TransformReplaceLineReturns:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_LineFillMask

@implementation Graphics_Text_LineFillMask

@dynamic enabled;
@dynamic heightOffset;
@dynamic verticalOffset;
@dynamic maskStyle;
@dynamic widthOffset;
@dynamic horizontalOffset;

typedef struct Graphics_Text_LineFillMask__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_LineFillMask_LineMaskStyle maskStyle;
  double heightOffset;
  double verticalOffset;
  double widthOffset;
  double horizontalOffset;
} Graphics_Text_LineFillMask__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_LineFillMask_FieldNumber_Enabled,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "heightOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_LineFillMask_FieldNumber_HeightOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Text_LineFillMask__storage_, heightOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "verticalOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_LineFillMask_FieldNumber_VerticalOffset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Text_LineFillMask__storage_, verticalOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maskStyle",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_LineFillMask_LineMaskStyle_EnumDescriptor,
        .number = Graphics_Text_LineFillMask_FieldNumber_MaskStyle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Text_LineFillMask__storage_, maskStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "widthOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_LineFillMask_FieldNumber_WidthOffset,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Text_LineFillMask__storage_, widthOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "horizontalOffset",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_LineFillMask_FieldNumber_HorizontalOffset,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Graphics_Text_LineFillMask__storage_, horizontalOffset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_LineFillMask class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_LineFillMask__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_LineFillMask_MaskStyle_RawValue(Graphics_Text_LineFillMask *message) {
  GPBDescriptor *descriptor = [Graphics_Text_LineFillMask descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_LineFillMask_FieldNumber_MaskStyle];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_LineFillMask_MaskStyle_RawValue(Graphics_Text_LineFillMask *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_LineFillMask descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_LineFillMask_FieldNumber_MaskStyle];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_LineFillMask_LineMaskStyle

GPBEnumDescriptor *Graphics_Text_LineFillMask_LineMaskStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LineMaskStyleFullWidth\000LineMaskStyleLine"
        "Width\000LineMaskStyleMaxLineWidth\000";
    static const int32_t values[] = {
        Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleFullWidth,
        Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleLineWidth,
        Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleMaxLineWidth,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_LineFillMask_LineMaskStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_LineFillMask_LineMaskStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_LineFillMask_LineMaskStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleFullWidth:
    case Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleLineWidth:
    case Graphics_Text_LineFillMask_LineMaskStyle_LineMaskStyleMaxLineWidth:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_GradientFill

@implementation Graphics_Text_GradientFill

@dynamic hasGradient, gradient;
@dynamic stretchToDocumentBounds;

typedef struct Graphics_Text_GradientFill__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Gradient *gradient;
} Graphics_Text_GradientFill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gradient",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Gradient),
        .number = Graphics_Text_GradientFill_FieldNumber_Gradient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_GradientFill__storage_, gradient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stretchToDocumentBounds",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_GradientFill_FieldNumber_StretchToDocumentBounds,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_GradientFill class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_GradientFill__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Text_Attributes

@implementation Graphics_Text_Attributes

@dynamic fillOneOfCase;
@dynamic hasFont, font;
@dynamic capitalization;
@dynamic hasUnderlineStyle, underlineStyle;
@dynamic hasUnderlineColor, underlineColor;
@dynamic hasParagraphStyle, paragraphStyle;
@dynamic kerning;
@dynamic superscript;
@dynamic hasStrikethroughStyle, strikethroughStyle;
@dynamic hasStrikethroughColor, strikethroughColor;
@dynamic strokeWidth;
@dynamic hasStrokeColor, strokeColor;
@dynamic customAttributesArray, customAttributesArray_Count;
@dynamic hasBackgroundColor, backgroundColor;
@dynamic textSolidFill;
@dynamic textGradientFill;

typedef struct Graphics_Text_Attributes__storage_ {
  uint32_t _has_storage_[2];
  Graphics_Text_Attributes_Capitalization capitalization;
  int32_t superscript;
  Graphics_Text_Attributes_Font *font;
  Color *textSolidFill;
  Graphics_Text_Attributes_Underline *underlineStyle;
  Color *underlineColor;
  Graphics_Text_Attributes_Paragraph *paragraphStyle;
  Graphics_Text_Attributes_Underline *strikethroughStyle;
  Color *strikethroughColor;
  Color *strokeColor;
  NSMutableArray *customAttributesArray;
  Graphics_Text_GradientFill *textGradientFill;
  Color *backgroundColor;
  double kerning;
  double strokeWidth;
} Graphics_Text_Attributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "font",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Font),
        .number = Graphics_Text_Attributes_FieldNumber_Font,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, font),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "capitalization",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Capitalization_EnumDescriptor,
        .number = Graphics_Text_Attributes_FieldNumber_Capitalization,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, capitalization),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "textSolidFill",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Text_Attributes_FieldNumber_TextSolidFill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, textSolidFill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "underlineStyle",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Underline),
        .number = Graphics_Text_Attributes_FieldNumber_UnderlineStyle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, underlineStyle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "underlineColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Text_Attributes_FieldNumber_UnderlineColor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, underlineColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paragraphStyle",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Paragraph),
        .number = Graphics_Text_Attributes_FieldNumber_ParagraphStyle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, paragraphStyle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "kerning",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_FieldNumber_Kerning,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, kerning),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "superscript",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_FieldNumber_Superscript,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, superscript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "strikethroughStyle",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Underline),
        .number = Graphics_Text_Attributes_FieldNumber_StrikethroughStyle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, strikethroughStyle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strikethroughColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Text_Attributes_FieldNumber_StrikethroughColor,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, strikethroughColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strokeWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_FieldNumber_StrokeWidth,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, strokeWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "strokeColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Text_Attributes_FieldNumber_StrokeColor,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, strokeColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customAttributesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_CustomAttribute),
        .number = Graphics_Text_Attributes_FieldNumber_CustomAttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, customAttributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textGradientFill",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_GradientFill),
        .number = Graphics_Text_Attributes_FieldNumber_TextGradientFill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, textGradientFill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Graphics_Text_Attributes_FieldNumber_BackgroundColor,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes__storage_, backgroundColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "fill",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_Capitalization_RawValue(Graphics_Text_Attributes *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_FieldNumber_Capitalization];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Capitalization_RawValue(Graphics_Text_Attributes *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_FieldNumber_Capitalization];
  GPBSetMessageRawEnumField(message, field, value);
}

void Graphics_Text_Attributes_ClearFillOneOfCase(Graphics_Text_Attributes *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Graphics_Text_Attributes_Capitalization

GPBEnumDescriptor *Graphics_Text_Attributes_Capitalization_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CapitalizationNone\000CapitalizationAllCaps"
        "\000CapitalizationSmallCaps\000CapitalizationT"
        "itleCase\000CapitalizationStartCase\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Capitalization_CapitalizationNone,
        Graphics_Text_Attributes_Capitalization_CapitalizationAllCaps,
        Graphics_Text_Attributes_Capitalization_CapitalizationSmallCaps,
        Graphics_Text_Attributes_Capitalization_CapitalizationTitleCase,
        Graphics_Text_Attributes_Capitalization_CapitalizationStartCase,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Capitalization)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Capitalization_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Capitalization_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Capitalization_CapitalizationNone:
    case Graphics_Text_Attributes_Capitalization_CapitalizationAllCaps:
    case Graphics_Text_Attributes_Capitalization_CapitalizationSmallCaps:
    case Graphics_Text_Attributes_Capitalization_CapitalizationTitleCase:
    case Graphics_Text_Attributes_Capitalization_CapitalizationStartCase:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_Attributes_Font

@implementation Graphics_Text_Attributes_Font

@dynamic name;
@dynamic size;
@dynamic italic;
@dynamic bold;
@dynamic family;
@dynamic face;

typedef struct Graphics_Text_Attributes_Font__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *family;
  NSString *face;
  double size;
} Graphics_Text_Attributes_Font__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Font__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Font__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "italic",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Italic,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bold",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Bold,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "family",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Family,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Font__storage_, family),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "face",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Font_FieldNumber_Face,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Font__storage_, face),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_Font class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_Font__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Graphics_Text_Attributes_Underline

@implementation Graphics_Text_Attributes_Underline

@dynamic style;
@dynamic pattern;
@dynamic byWord;

typedef struct Graphics_Text_Attributes_Underline__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_Attributes_Underline_Style style;
  Graphics_Text_Attributes_Underline_Pattern pattern;
} Graphics_Text_Attributes_Underline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "style",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Underline_Style_EnumDescriptor,
        .number = Graphics_Text_Attributes_Underline_FieldNumber_Style,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Underline__storage_, style),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pattern",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Underline_Pattern_EnumDescriptor,
        .number = Graphics_Text_Attributes_Underline_FieldNumber_Pattern,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Underline__storage_, pattern),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "byWord",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Underline_FieldNumber_ByWord,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_Underline class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_Underline__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_Underline_Style_RawValue(Graphics_Text_Attributes_Underline *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Underline descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Underline_FieldNumber_Style];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Underline_Style_RawValue(Graphics_Text_Attributes_Underline *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Underline descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Underline_FieldNumber_Style];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Graphics_Text_Attributes_Underline_Pattern_RawValue(Graphics_Text_Attributes_Underline *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Underline descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Underline_FieldNumber_Pattern];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Underline_Pattern_RawValue(Graphics_Text_Attributes_Underline *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Underline descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Underline_FieldNumber_Pattern];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_Attributes_Underline_Style

GPBEnumDescriptor *Graphics_Text_Attributes_Underline_Style_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StyleNone\000StyleSingle\000StyleThick\000StyleDo"
        "uble\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Underline_Style_StyleNone,
        Graphics_Text_Attributes_Underline_Style_StyleSingle,
        Graphics_Text_Attributes_Underline_Style_StyleThick,
        Graphics_Text_Attributes_Underline_Style_StyleDouble,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Underline_Style)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Underline_Style_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Underline_Style_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Underline_Style_StyleNone:
    case Graphics_Text_Attributes_Underline_Style_StyleSingle:
    case Graphics_Text_Attributes_Underline_Style_StyleThick:
    case Graphics_Text_Attributes_Underline_Style_StyleDouble:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Graphics_Text_Attributes_Underline_Pattern

GPBEnumDescriptor *Graphics_Text_Attributes_Underline_Pattern_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PatternSolid\000PatternDot\000PatternDash\000Patt"
        "ernDashDot\000PatternDashDotDot\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Underline_Pattern_PatternSolid,
        Graphics_Text_Attributes_Underline_Pattern_PatternDot,
        Graphics_Text_Attributes_Underline_Pattern_PatternDash,
        Graphics_Text_Attributes_Underline_Pattern_PatternDashDot,
        Graphics_Text_Attributes_Underline_Pattern_PatternDashDotDot,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Underline_Pattern)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Underline_Pattern_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Underline_Pattern_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Underline_Pattern_PatternSolid:
    case Graphics_Text_Attributes_Underline_Pattern_PatternDot:
    case Graphics_Text_Attributes_Underline_Pattern_PatternDash:
    case Graphics_Text_Attributes_Underline_Pattern_PatternDashDot:
    case Graphics_Text_Attributes_Underline_Pattern_PatternDashDotDot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_Attributes_Paragraph

@implementation Graphics_Text_Attributes_Paragraph

@dynamic alignment;
@dynamic firstLineHeadIndent;
@dynamic headIndent;
@dynamic tailIndent;
@dynamic lineHeightMultiple;
@dynamic maximumLineHeight;
@dynamic minimumLineHeight;
@dynamic lineSpacing;
@dynamic paragraphSpacing;
@dynamic paragraphSpacingBefore;
@dynamic tabStopsArray, tabStopsArray_Count;
@dynamic defaultTabInterval;
@dynamic hasTextList, textList;
@dynamic textListsArray, textListsArray_Count;

typedef struct Graphics_Text_Attributes_Paragraph__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_Attributes_Paragraph_Alignment alignment;
  NSMutableArray *tabStopsArray;
  Graphics_Text_Attributes_Paragraph_TextList *textList;
  NSMutableArray *textListsArray;
  double firstLineHeadIndent;
  double headIndent;
  double tailIndent;
  double lineHeightMultiple;
  double maximumLineHeight;
  double minimumLineHeight;
  double lineSpacing;
  double paragraphSpacing;
  double paragraphSpacingBefore;
  double defaultTabInterval;
} Graphics_Text_Attributes_Paragraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alignment",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Paragraph_Alignment_EnumDescriptor,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_Alignment,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, alignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "firstLineHeadIndent",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_FirstLineHeadIndent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, firstLineHeadIndent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "headIndent",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_HeadIndent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, headIndent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "tailIndent",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_TailIndent,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, tailIndent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lineHeightMultiple",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_LineHeightMultiple,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, lineHeightMultiple),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maximumLineHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_MaximumLineHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, maximumLineHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "minimumLineHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_MinimumLineHeight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, minimumLineHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lineSpacing",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_LineSpacing,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, lineSpacing),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "paragraphSpacing",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_ParagraphSpacing,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, paragraphSpacing),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "paragraphSpacingBefore",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_ParagraphSpacingBefore,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, paragraphSpacingBefore),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "tabStopsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Paragraph_TabStop),
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_TabStopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, tabStopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultTabInterval",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_DefaultTabInterval,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, defaultTabInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "textList",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Paragraph_TextList),
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_TextList,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, textList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textListsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_Attributes_Paragraph_TextList),
        .number = Graphics_Text_Attributes_Paragraph_FieldNumber_TextListsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph__storage_, textListsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_Paragraph class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_Paragraph__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_Paragraph_Alignment_RawValue(Graphics_Text_Attributes_Paragraph *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_FieldNumber_Alignment];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Paragraph_Alignment_RawValue(Graphics_Text_Attributes_Paragraph *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_FieldNumber_Alignment];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_Attributes_Paragraph_Alignment

GPBEnumDescriptor *Graphics_Text_Attributes_Paragraph_Alignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AlignmentLeft\000AlignmentRight\000AlignmentCe"
        "nter\000AlignmentJustified\000AlignmentNatural"
        "\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Paragraph_Alignment_AlignmentLeft,
        Graphics_Text_Attributes_Paragraph_Alignment_AlignmentRight,
        Graphics_Text_Attributes_Paragraph_Alignment_AlignmentCenter,
        Graphics_Text_Attributes_Paragraph_Alignment_AlignmentJustified,
        Graphics_Text_Attributes_Paragraph_Alignment_AlignmentNatural,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Paragraph_Alignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Paragraph_Alignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Paragraph_Alignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Paragraph_Alignment_AlignmentLeft:
    case Graphics_Text_Attributes_Paragraph_Alignment_AlignmentRight:
    case Graphics_Text_Attributes_Paragraph_Alignment_AlignmentCenter:
    case Graphics_Text_Attributes_Paragraph_Alignment_AlignmentJustified:
    case Graphics_Text_Attributes_Paragraph_Alignment_AlignmentNatural:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_Attributes_Paragraph_TabStop

@implementation Graphics_Text_Attributes_Paragraph_TabStop

@dynamic location;
@dynamic alignment;

typedef struct Graphics_Text_Attributes_Paragraph_TabStop__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_Attributes_Paragraph_TabStop_Alignment alignment;
  double location;
} Graphics_Text_Attributes_Paragraph_TabStop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "location",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_TabStop_FieldNumber_Location,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TabStop__storage_, location),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "alignment",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Paragraph_TabStop_Alignment_EnumDescriptor,
        .number = Graphics_Text_Attributes_Paragraph_TabStop_FieldNumber_Alignment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TabStop__storage_, alignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_Paragraph_TabStop class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_Paragraph_TabStop__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes_Paragraph)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_Paragraph_TabStop_Alignment_RawValue(Graphics_Text_Attributes_Paragraph_TabStop *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph_TabStop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_TabStop_FieldNumber_Alignment];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Paragraph_TabStop_Alignment_RawValue(Graphics_Text_Attributes_Paragraph_TabStop *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph_TabStop descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_TabStop_FieldNumber_Alignment];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_Attributes_Paragraph_TabStop_Alignment

GPBEnumDescriptor *Graphics_Text_Attributes_Paragraph_TabStop_Alignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AlignmentLeft\000AlignmentRight\000AlignmentCe"
        "nter\000AlignmentJustified\000AlignmentNatural"
        "\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentLeft,
        Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentRight,
        Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentCenter,
        Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentJustified,
        Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentNatural,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Paragraph_TabStop_Alignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Paragraph_TabStop_Alignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Paragraph_TabStop_Alignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentLeft:
    case Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentRight:
    case Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentCenter:
    case Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentJustified:
    case Graphics_Text_Attributes_Paragraph_TabStop_Alignment_AlignmentNatural:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_Attributes_Paragraph_TextList

@implementation Graphics_Text_Attributes_Paragraph_TextList

@dynamic isEnabled;
@dynamic numberType;
@dynamic prefix;
@dynamic postfix;
@dynamic startingNumber;

typedef struct Graphics_Text_Attributes_Paragraph_TextList__storage_ {
  uint32_t _has_storage_[1];
  Graphics_Text_Attributes_Paragraph_TextList_NumberType numberType;
  int32_t startingNumber;
  NSString *prefix;
  NSString *postfix;
} Graphics_Text_Attributes_Paragraph_TextList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_IsEnabled,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "numberType",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_Paragraph_TextList_NumberType_EnumDescriptor,
        .number = Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_NumberType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TextList__storage_, numberType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prefix",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_Prefix,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TextList__storage_, prefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "postfix",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_Postfix,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TextList__storage_, postfix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startingNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_StartingNumber,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_Paragraph_TextList__storage_, startingNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_Paragraph_TextList class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_Paragraph_TextList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes_Paragraph)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_Paragraph_TextList_NumberType_RawValue(Graphics_Text_Attributes_Paragraph_TextList *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph_TextList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_NumberType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_Paragraph_TextList_NumberType_RawValue(Graphics_Text_Attributes_Paragraph_TextList *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_Paragraph_TextList descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_Paragraph_TextList_FieldNumber_NumberType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Graphics_Text_Attributes_Paragraph_TextList_NumberType

GPBEnumDescriptor *Graphics_Text_Attributes_Paragraph_TextList_NumberType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NumberTypeBox\000NumberTypeCheck\000NumberType"
        "Circle\000NumberTypeDiamond\000NumberTypeDisc\000"
        "NumberTypeHyphen\000NumberTypeSquare\000Number"
        "TypeDecimal\000NumberTypeLowercaseAlpha\000Num"
        "berTypeUppercaseAlpha\000NumberTypeLowercas"
        "eRoman\000NumberTypeUppercaseRoman\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeBox,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeCheck,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeCircle,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDiamond,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDisc,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeHyphen,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeSquare,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDecimal,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeLowercaseAlpha,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeUppercaseAlpha,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeLowercaseRoman,
        Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeUppercaseRoman,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_Paragraph_TextList_NumberType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_Paragraph_TextList_NumberType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_Paragraph_TextList_NumberType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeBox:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeCheck:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeCircle:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDiamond:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDisc:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeHyphen:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeSquare:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeDecimal:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeLowercaseAlpha:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeUppercaseAlpha:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeLowercaseRoman:
    case Graphics_Text_Attributes_Paragraph_TextList_NumberType_NumberTypeUppercaseRoman:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Graphics_Text_Attributes_CustomAttribute

@implementation Graphics_Text_Attributes_CustomAttribute

@dynamic attributeOneOfCase;
@dynamic hasRange, range;
@dynamic capitalization;
@dynamic originalFontSize;
@dynamic fontScaleFactor;
@dynamic textGradientFill;
@dynamic shouldPreserveForegroundColor;

typedef struct Graphics_Text_Attributes_CustomAttribute__storage_ {
  uint32_t _has_storage_[2];
  Graphics_Text_Attributes_CustomAttribute_Capitalization capitalization;
  IntRange *range;
  Graphics_Text_GradientFill *textGradientFill;
  double originalFontSize;
  double fontScaleFactor;
} Graphics_Text_Attributes_CustomAttribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "range",
        .dataTypeSpecific.clazz = GPBObjCClass(IntRange),
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_Range,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_CustomAttribute__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "capitalization",
        .dataTypeSpecific.enumDescFunc = Graphics_Text_Attributes_CustomAttribute_Capitalization_EnumDescriptor,
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_Capitalization,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_CustomAttribute__storage_, capitalization),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "originalFontSize",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_OriginalFontSize,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_CustomAttribute__storage_, originalFontSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fontScaleFactor",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_FontScaleFactor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_CustomAttribute__storage_, fontScaleFactor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "textGradientFill",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Text_GradientFill),
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_TextGradientFill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Graphics_Text_Attributes_CustomAttribute__storage_, textGradientFill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shouldPreserveForegroundColor",
        .dataTypeSpecific.clazz = Nil,
        .number = Graphics_Text_Attributes_CustomAttribute_FieldNumber_ShouldPreserveForegroundColor,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Graphics_Text_Attributes_CustomAttribute class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Graphics_Text_Attributes_CustomAttribute__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "attribute",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Graphics_Text_Attributes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Graphics_Text_Attributes_CustomAttribute_Capitalization_RawValue(Graphics_Text_Attributes_CustomAttribute *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_CustomAttribute descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_CustomAttribute_FieldNumber_Capitalization];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGraphics_Text_Attributes_CustomAttribute_Capitalization_RawValue(Graphics_Text_Attributes_CustomAttribute *message, int32_t value) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_CustomAttribute descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Graphics_Text_Attributes_CustomAttribute_FieldNumber_Capitalization];
  GPBSetMessageRawEnumField(message, field, value);
}

void Graphics_Text_Attributes_CustomAttribute_ClearAttributeOneOfCase(Graphics_Text_Attributes_CustomAttribute *message) {
  GPBDescriptor *descriptor = [Graphics_Text_Attributes_CustomAttribute descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum Graphics_Text_Attributes_CustomAttribute_Capitalization

GPBEnumDescriptor *Graphics_Text_Attributes_CustomAttribute_Capitalization_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CapitalizationNone\000CapitalizationAllCaps"
        "\000CapitalizationSmallCaps\000CapitalizationT"
        "itleCase\000CapitalizationStartCase\000";
    static const int32_t values[] = {
        Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationNone,
        Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationAllCaps,
        Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationSmallCaps,
        Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationTitleCase,
        Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationStartCase,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Graphics_Text_Attributes_CustomAttribute_Capitalization)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Graphics_Text_Attributes_CustomAttribute_Capitalization_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Graphics_Text_Attributes_CustomAttribute_Capitalization_IsValidValue(int32_t value__) {
  switch (value__) {
    case Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationNone:
    case Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationAllCaps:
    case Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationSmallCaps:
    case Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationTitleCase:
    case Graphics_Text_Attributes_CustomAttribute_Capitalization_CapitalizationStartCase:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Media

@implementation Media

@dynamic typePropertiesOneOfCase;
@dynamic hasUuid, uuid;
@dynamic hasURL, URL;
@dynamic hasMetadata, metadata;
@dynamic audio;
@dynamic image;
@dynamic video;
@dynamic liveVideo;
@dynamic webContent;

typedef struct Media__storage_ {
  uint32_t _has_storage_[2];
  UUID *uuid;
  URL *URL;
  Media_Metadata *metadata;
  Media_AudioTypeProperties *audio;
  Media_ImageTypeProperties *image;
  Media_VideoTypeProperties *video;
  Media_LiveVideoTypeProperties *liveVideo;
  Media_WebContentTypeProperties *webContent;
} Media__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Media_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Media_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_Metadata),
        .number = Media_FieldNumber_Metadata,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioTypeProperties),
        .number = Media_FieldNumber_Audio,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Media__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_ImageTypeProperties),
        .number = Media_FieldNumber_Image,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Media__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_VideoTypeProperties),
        .number = Media_FieldNumber_Video,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Media__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_LiveVideoTypeProperties),
        .number = Media_FieldNumber_LiveVideo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Media__storage_, liveVideo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webContent",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_WebContentTypeProperties),
        .number = Media_FieldNumber_WebContent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Media__storage_, webContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "typeProperties",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Media_ClearTypePropertiesOneOfCase(Media *message) {
  GPBDescriptor *descriptor = [Media descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Media_Metadata

@implementation Media_Metadata

@dynamic manufactureName;
@dynamic hasManufactureURL, manufactureURL;
@dynamic information;
@dynamic artist;
@dynamic format;

typedef struct Media_Metadata__storage_ {
  uint32_t _has_storage_[1];
  NSString *manufactureName;
  URL *manufactureURL;
  NSString *information;
  NSString *artist;
  NSString *format;
} Media_Metadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "manufactureName",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Metadata_FieldNumber_ManufactureName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_Metadata__storage_, manufactureName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufactureURL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Media_Metadata_FieldNumber_ManufactureURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_Metadata__storage_, manufactureURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "information",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Metadata_FieldNumber_Information,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_Metadata__storage_, information),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "artist",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Metadata_FieldNumber_Artist,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_Metadata__storage_, artist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Metadata_FieldNumber_Format,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Media_Metadata__storage_, format),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_Metadata class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_Metadata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_VideoDevice

@implementation Media_VideoDevice

@dynamic type;
@dynamic name;
@dynamic uniqueId;
@dynamic modelId;
@dynamic formatIndex;
@dynamic hasAudioRouting, audioRouting;

typedef struct Media_VideoDevice__storage_ {
  uint32_t _has_storage_[1];
  Media_VideoDevice_Type type;
  uint32_t formatIndex;
  NSString *name;
  NSString *uniqueId;
  NSString *modelId;
  DigitalAudio_Device_Routing *audioRouting;
} Media_VideoDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Media_VideoDevice_Type_EnumDescriptor,
        .number = Media_VideoDevice_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoDevice_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uniqueId",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoDevice_FieldNumber_UniqueId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, uniqueId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modelId",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoDevice_FieldNumber_ModelId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, modelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formatIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoDevice_FieldNumber_FormatIndex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, formatIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "audioRouting",
        .dataTypeSpecific.clazz = GPBObjCClass(DigitalAudio_Device_Routing),
        .number = Media_VideoDevice_FieldNumber_AudioRouting,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Media_VideoDevice__storage_, audioRouting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_VideoDevice class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_VideoDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Media_VideoDevice_Type_RawValue(Media_VideoDevice *message) {
  GPBDescriptor *descriptor = [Media_VideoDevice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoDevice_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_VideoDevice_Type_RawValue(Media_VideoDevice *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_VideoDevice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoDevice_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Media_VideoDevice_Type

GPBEnumDescriptor *Media_VideoDevice_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeGeneric\000TypeDirectshow\000TypeBlackmagi"
        "c\000TypeAja\000TypeAv\000TypeSyphon\000TypeNdi\000Type"
        "Bluefish\000";
    static const int32_t values[] = {
        Media_VideoDevice_Type_TypeGeneric,
        Media_VideoDevice_Type_TypeDirectshow,
        Media_VideoDevice_Type_TypeBlackmagic,
        Media_VideoDevice_Type_TypeAja,
        Media_VideoDevice_Type_TypeAv,
        Media_VideoDevice_Type_TypeSyphon,
        Media_VideoDevice_Type_TypeNdi,
        Media_VideoDevice_Type_TypeBluefish,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_VideoDevice_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_VideoDevice_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_VideoDevice_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_VideoDevice_Type_TypeGeneric:
    case Media_VideoDevice_Type_TypeDirectshow:
    case Media_VideoDevice_Type_TypeBlackmagic:
    case Media_VideoDevice_Type_TypeAja:
    case Media_VideoDevice_Type_TypeAv:
    case Media_VideoDevice_Type_TypeSyphon:
    case Media_VideoDevice_Type_TypeNdi:
    case Media_VideoDevice_Type_TypeBluefish:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Media_AudioDevice

@implementation Media_AudioDevice

@dynamic name;
@dynamic uniqueId;
@dynamic modelId;
@dynamic channelCount;

typedef struct Media_AudioDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t channelCount;
  NSString *name;
  NSString *uniqueId;
  NSString *modelId;
} Media_AudioDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioDevice_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_AudioDevice__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uniqueId",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioDevice_FieldNumber_UniqueId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_AudioDevice__storage_, uniqueId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modelId",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioDevice_FieldNumber_ModelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_AudioDevice__storage_, modelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioDevice_FieldNumber_ChannelCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_AudioDevice__storage_, channelCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_AudioDevice class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_AudioDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_Audio

@implementation Media_Audio


typedef struct Media_Audio__storage_ {
  uint32_t _has_storage_[1];
} Media_Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_Audio class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Media_Audio__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_Audio_Channel

@implementation Media_Audio_Channel

@dynamic index;
@dynamic muted;
@dynamic volume;
@dynamic compressLimit;
@dynamic outputsArray, outputsArray_Count;

typedef struct Media_Audio_Channel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSMutableArray *outputsArray;
  double volume;
} Media_Audio_Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Audio_Channel_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_Audio_Channel__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "muted",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Audio_Channel_FieldNumber_Muted,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Audio_Channel_FieldNumber_Volume,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_Audio_Channel__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "compressLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Audio_Channel_FieldNumber_CompressLimit,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_Audio_Channel_Output),
        .number = Media_Audio_Channel_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Media_Audio_Channel__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_Audio_Channel class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_Audio_Channel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media_Audio)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_Audio_Channel_Output

@implementation Media_Audio_Channel_Output

@dynamic channelIndex;

typedef struct Media_Audio_Channel_Output__storage_ {
  uint32_t _has_storage_[1];
  int32_t channelIndex;
} Media_Audio_Channel_Output__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_Audio_Channel_Output_FieldNumber_ChannelIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_Audio_Channel_Output__storage_, channelIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_Audio_Channel_Output class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_Audio_Channel_Output__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media_Audio_Channel)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_AudioProperties

@implementation Media_AudioProperties

@dynamic volume;
@dynamic audioChannelsArray, audioChannelsArray_Count;
@dynamic isCustomMapping;

typedef struct Media_AudioProperties__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *audioChannelsArray;
  double volume;
} Media_AudioProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioProperties_FieldNumber_Volume,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_AudioProperties__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "audioChannelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_Audio_Channel),
        .number = Media_AudioProperties_FieldNumber_AudioChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Media_AudioProperties__storage_, audioChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isCustomMapping",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_AudioProperties_FieldNumber_IsCustomMapping,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_AudioProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_AudioProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_TransportProperties

@implementation Media_TransportProperties

@dynamic playRate;
@dynamic inPoint;
@dynamic outPoint;
@dynamic fadeInDuration;
@dynamic fadeOutDuration;
@dynamic shouldFadeIn;
@dynamic shouldFadeOut;
@dynamic endPoint;
@dynamic playbackBehavior;
@dynamic loopTime;
@dynamic timesToLoop;

typedef struct Media_TransportProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_TransportProperties_PlaybackBehavior playbackBehavior;
  uint32_t timesToLoop;
  double playRate;
  double inPoint;
  double outPoint;
  double fadeInDuration;
  double fadeOutDuration;
  double endPoint;
  double loopTime;
} Media_TransportProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_PlayRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, playRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "inPoint",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_InPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, inPoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "outPoint",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_OutPoint,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, outPoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fadeInDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_FadeInDuration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, fadeInDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fadeOutDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_FadeOutDuration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, fadeOutDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "shouldFadeIn",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_ShouldFadeIn,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shouldFadeOut",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_ShouldFadeOut,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "endPoint",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_EndPoint,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, endPoint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "playbackBehavior",
        .dataTypeSpecific.enumDescFunc = Media_TransportProperties_PlaybackBehavior_EnumDescriptor,
        .number = Media_TransportProperties_FieldNumber_PlaybackBehavior,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, playbackBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "loopTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_LoopTime,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, loopTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timesToLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_TransportProperties_FieldNumber_TimesToLoop,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Media_TransportProperties__storage_, timesToLoop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_TransportProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_TransportProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Media_TransportProperties_PlaybackBehavior_RawValue(Media_TransportProperties *message) {
  GPBDescriptor *descriptor = [Media_TransportProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_TransportProperties_FieldNumber_PlaybackBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_TransportProperties_PlaybackBehavior_RawValue(Media_TransportProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_TransportProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_TransportProperties_FieldNumber_PlaybackBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Media_TransportProperties_PlaybackBehavior

GPBEnumDescriptor *Media_TransportProperties_PlaybackBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaybackBehaviorStop\000PlaybackBehaviorLoo"
        "p\000PlaybackBehaviorLoopForCount\000PlaybackB"
        "ehaviorLoopForTime\000";
    static const int32_t values[] = {
        Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorStop,
        Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoop,
        Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoopForCount,
        Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoopForTime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_TransportProperties_PlaybackBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_TransportProperties_PlaybackBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_TransportProperties_PlaybackBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorStop:
    case Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoop:
    case Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoopForCount:
    case Media_TransportProperties_PlaybackBehavior_PlaybackBehaviorLoopForTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Media_DrawingProperties

@implementation Media_DrawingProperties

@dynamic scaleBehavior;
@dynamic scaleAlignment;
@dynamic flippedHorizontally;
@dynamic flippedVertically;
@dynamic hasNaturalSize, naturalSize;
@dynamic customImageRotation;
@dynamic hasCustomImageBounds, customImageBounds;
@dynamic customImageAspectLocked;
@dynamic alphaInverted;
@dynamic nativeRotation;
@dynamic hasSelectedEffectPresetUuid, selectedEffectPresetUuid;
@dynamic effectsArray, effectsArray_Count;
@dynamic cropEnable;
@dynamic hasCropInsets, cropInsets;

typedef struct Media_DrawingProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_DrawingProperties_ScaleBehavior scaleBehavior;
  Media_DrawingProperties_ScaleAlignment scaleAlignment;
  Media_DrawingProperties_NativeRotationType nativeRotation;
  Graphics_Size *naturalSize;
  Graphics_Rect *customImageBounds;
  UUID *selectedEffectPresetUuid;
  NSMutableArray *effectsArray;
  Graphics_EdgeInsets *cropInsets;
  double customImageRotation;
} Media_DrawingProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "scaleBehavior",
        .dataTypeSpecific.enumDescFunc = Media_DrawingProperties_ScaleBehavior_EnumDescriptor,
        .number = Media_DrawingProperties_FieldNumber_ScaleBehavior,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, scaleBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "scaleAlignment",
        .dataTypeSpecific.enumDescFunc = Media_DrawingProperties_ScaleAlignment_EnumDescriptor,
        .number = Media_DrawingProperties_FieldNumber_ScaleAlignment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, scaleAlignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "flippedHorizontally",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_FlippedHorizontally,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flippedVertically",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_FlippedVertically,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "naturalSize",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Size),
        .number = Media_DrawingProperties_FieldNumber_NaturalSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, naturalSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customImageRotation",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_CustomImageRotation,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, customImageRotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "customImageBounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Rect),
        .number = Media_DrawingProperties_FieldNumber_CustomImageBounds,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, customImageBounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customImageAspectLocked",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_CustomImageAspectLocked,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "alphaInverted",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_AlphaInverted,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "nativeRotation",
        .dataTypeSpecific.enumDescFunc = Media_DrawingProperties_NativeRotationType_EnumDescriptor,
        .number = Media_DrawingProperties_FieldNumber_NativeRotation,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, nativeRotation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "selectedEffectPresetUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Media_DrawingProperties_FieldNumber_SelectedEffectPresetUuid,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, selectedEffectPresetUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "effectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Effect),
        .number = Media_DrawingProperties_FieldNumber_EffectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, effectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cropEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_DrawingProperties_FieldNumber_CropEnable,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cropInsets",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_EdgeInsets),
        .number = Media_DrawingProperties_FieldNumber_CropInsets,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Media_DrawingProperties__storage_, cropInsets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_DrawingProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_DrawingProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Media_DrawingProperties_ScaleBehavior_RawValue(Media_DrawingProperties *message) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_ScaleBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_DrawingProperties_ScaleBehavior_RawValue(Media_DrawingProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_ScaleBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Media_DrawingProperties_ScaleAlignment_RawValue(Media_DrawingProperties *message) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_ScaleAlignment];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_DrawingProperties_ScaleAlignment_RawValue(Media_DrawingProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_ScaleAlignment];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Media_DrawingProperties_NativeRotation_RawValue(Media_DrawingProperties *message) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_NativeRotation];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_DrawingProperties_NativeRotation_RawValue(Media_DrawingProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_DrawingProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_DrawingProperties_FieldNumber_NativeRotation];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Media_DrawingProperties_ScaleBehavior

GPBEnumDescriptor *Media_DrawingProperties_ScaleBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleBehaviorFit\000ScaleBehaviorFill\000Scale"
        "BehaviorStretch\000ScaleBehaviorCustom\000";
    static const int32_t values[] = {
        Media_DrawingProperties_ScaleBehavior_ScaleBehaviorFit,
        Media_DrawingProperties_ScaleBehavior_ScaleBehaviorFill,
        Media_DrawingProperties_ScaleBehavior_ScaleBehaviorStretch,
        Media_DrawingProperties_ScaleBehavior_ScaleBehaviorCustom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_DrawingProperties_ScaleBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_DrawingProperties_ScaleBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_DrawingProperties_ScaleBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_DrawingProperties_ScaleBehavior_ScaleBehaviorFit:
    case Media_DrawingProperties_ScaleBehavior_ScaleBehaviorFill:
    case Media_DrawingProperties_ScaleBehavior_ScaleBehaviorStretch:
    case Media_DrawingProperties_ScaleBehavior_ScaleBehaviorCustom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Media_DrawingProperties_ScaleAlignment

GPBEnumDescriptor *Media_DrawingProperties_ScaleAlignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleAlignmentMiddleCenter\000ScaleAlignmen"
        "tTopLeft\000ScaleAlignmentTopCenter\000ScaleAl"
        "ignmentTopRight\000ScaleAlignmentMiddleRigh"
        "t\000ScaleAlignmentBottomRight\000ScaleAlignme"
        "ntBottomCenter\000ScaleAlignmentBottomLeft\000"
        "ScaleAlignmentMiddleLeft\000";
    static const int32_t values[] = {
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleCenter,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopLeft,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopCenter,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopRight,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleRight,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomRight,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomCenter,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomLeft,
        Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleLeft,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_DrawingProperties_ScaleAlignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_DrawingProperties_ScaleAlignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_DrawingProperties_ScaleAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleCenter:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopLeft:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopCenter:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentTopRight:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleRight:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomRight:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomCenter:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentBottomLeft:
    case Media_DrawingProperties_ScaleAlignment_ScaleAlignmentMiddleLeft:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Media_DrawingProperties_NativeRotationType

GPBEnumDescriptor *Media_DrawingProperties_NativeRotationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NativeRotationTypeRotateStandard\000NativeR"
        "otationTypeRotate90\000NativeRotationTypeRo"
        "tate180\000NativeRotationTypeRotate270\000";
    static const int32_t values[] = {
        Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotateStandard,
        Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate90,
        Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate180,
        Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate270,
    };
    static const char *extraTextFormatInfo = "\003\001f\350\344\346\202\000\002f\350\344\346\203\000\003f\350\344\346\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_DrawingProperties_NativeRotationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_DrawingProperties_NativeRotationType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_DrawingProperties_NativeRotationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotateStandard:
    case Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate90:
    case Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate180:
    case Media_DrawingProperties_NativeRotationType_NativeRotationTypeRotate270:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Media_VideoProperties

@implementation Media_VideoProperties

@dynamic frameRate;
@dynamic fieldType;
@dynamic thumbnailPosition;
@dynamic endBehavior;
@dynamic softLoop;
@dynamic softLoopDuration;

typedef struct Media_VideoProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_VideoProperties_FieldType fieldType;
  Media_VideoProperties_EndBehavior endBehavior;
  double frameRate;
  double thumbnailPosition;
  double softLoopDuration;
} Media_VideoProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "frameRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoProperties_FieldNumber_FrameRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_VideoProperties__storage_, frameRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fieldType",
        .dataTypeSpecific.enumDescFunc = Media_VideoProperties_FieldType_EnumDescriptor,
        .number = Media_VideoProperties_FieldNumber_FieldType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_VideoProperties__storage_, fieldType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "thumbnailPosition",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoProperties_FieldNumber_ThumbnailPosition,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_VideoProperties__storage_, thumbnailPosition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "endBehavior",
        .dataTypeSpecific.enumDescFunc = Media_VideoProperties_EndBehavior_EnumDescriptor,
        .number = Media_VideoProperties_FieldNumber_EndBehavior,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_VideoProperties__storage_, endBehavior),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "softLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoProperties_FieldNumber_SoftLoop,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "softLoopDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_VideoProperties_FieldNumber_SoftLoopDuration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Media_VideoProperties__storage_, softLoopDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_VideoProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_VideoProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Media_VideoProperties_FieldType_RawValue(Media_VideoProperties *message) {
  GPBDescriptor *descriptor = [Media_VideoProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoProperties_FieldNumber_FieldType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_VideoProperties_FieldType_RawValue(Media_VideoProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_VideoProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoProperties_FieldNumber_FieldType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Media_VideoProperties_EndBehavior_RawValue(Media_VideoProperties *message) {
  GPBDescriptor *descriptor = [Media_VideoProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoProperties_FieldNumber_EndBehavior];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMedia_VideoProperties_EndBehavior_RawValue(Media_VideoProperties *message, int32_t value) {
  GPBDescriptor *descriptor = [Media_VideoProperties descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Media_VideoProperties_FieldNumber_EndBehavior];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Media_VideoProperties_FieldType

GPBEnumDescriptor *Media_VideoProperties_FieldType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FieldTypeUnknown\000FieldTypeProgressive\000Fi"
        "eldTypeInterlacedUpperFirst\000FieldTypeInt"
        "erlacedLowerFirst\000";
    static const int32_t values[] = {
        Media_VideoProperties_FieldType_FieldTypeUnknown,
        Media_VideoProperties_FieldType_FieldTypeProgressive,
        Media_VideoProperties_FieldType_FieldTypeInterlacedUpperFirst,
        Media_VideoProperties_FieldType_FieldTypeInterlacedLowerFirst,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_VideoProperties_FieldType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_VideoProperties_FieldType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_VideoProperties_FieldType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_VideoProperties_FieldType_FieldTypeUnknown:
    case Media_VideoProperties_FieldType_FieldTypeProgressive:
    case Media_VideoProperties_FieldType_FieldTypeInterlacedUpperFirst:
    case Media_VideoProperties_FieldType_FieldTypeInterlacedLowerFirst:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Media_VideoProperties_EndBehavior

GPBEnumDescriptor *Media_VideoProperties_EndBehavior_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EndBehaviorStop\000EndBehaviorStopOnBlack\000E"
        "ndBehaviorStopOnClear\000EndBehaviorFadeToB"
        "lack\000EndBehaviorFadeToClear\000";
    static const int32_t values[] = {
        Media_VideoProperties_EndBehavior_EndBehaviorStop,
        Media_VideoProperties_EndBehavior_EndBehaviorStopOnBlack,
        Media_VideoProperties_EndBehavior_EndBehaviorStopOnClear,
        Media_VideoProperties_EndBehavior_EndBehaviorFadeToBlack,
        Media_VideoProperties_EndBehavior_EndBehaviorFadeToClear,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Media_VideoProperties_EndBehavior)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Media_VideoProperties_EndBehavior_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Media_VideoProperties_EndBehavior_IsValidValue(int32_t value__) {
  switch (value__) {
    case Media_VideoProperties_EndBehavior_EndBehaviorStop:
    case Media_VideoProperties_EndBehavior_EndBehaviorStopOnBlack:
    case Media_VideoProperties_EndBehavior_EndBehaviorStopOnClear:
    case Media_VideoProperties_EndBehavior_EndBehaviorFadeToBlack:
    case Media_VideoProperties_EndBehavior_EndBehaviorFadeToClear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Media_LiveVideoProperties

@implementation Media_LiveVideoProperties

@dynamic hasVideoDevice, videoDevice;
@dynamic hasAudioDevice, audioDevice;
@dynamic liveVideoIndex;

typedef struct Media_LiveVideoProperties__storage_ {
  uint32_t _has_storage_[1];
  int32_t liveVideoIndex;
  Media_VideoDevice *videoDevice;
  Media_AudioDevice *audioDevice;
} Media_LiveVideoProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoDevice",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_VideoDevice),
        .number = Media_LiveVideoProperties_FieldNumber_VideoDevice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_LiveVideoProperties__storage_, videoDevice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioDevice",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioDevice),
        .number = Media_LiveVideoProperties_FieldNumber_AudioDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_LiveVideoProperties__storage_, audioDevice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveVideoIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Media_LiveVideoProperties_FieldNumber_LiveVideoIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_LiveVideoProperties__storage_, liveVideoIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_LiveVideoProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_LiveVideoProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_AudioTypeProperties

@implementation Media_AudioTypeProperties

@dynamic hasAudio, audio;
@dynamic hasTransport, transport;

typedef struct Media_AudioTypeProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_AudioProperties *audio;
  Media_TransportProperties *transport;
} Media_AudioTypeProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioProperties),
        .number = Media_AudioTypeProperties_FieldNumber_Audio,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_AudioTypeProperties__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transport",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_TransportProperties),
        .number = Media_AudioTypeProperties_FieldNumber_Transport,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_AudioTypeProperties__storage_, transport),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_AudioTypeProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_AudioTypeProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_ImageTypeProperties

@implementation Media_ImageTypeProperties

@dynamic hasDrawing, drawing;

typedef struct Media_ImageTypeProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_DrawingProperties *drawing;
} Media_ImageTypeProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "drawing",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_DrawingProperties),
        .number = Media_ImageTypeProperties_FieldNumber_Drawing,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_ImageTypeProperties__storage_, drawing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_ImageTypeProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_ImageTypeProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_VideoTypeProperties

@implementation Media_VideoTypeProperties

@dynamic hasDrawing, drawing;
@dynamic hasAudio, audio;
@dynamic hasTransport, transport;
@dynamic hasVideo, video;

typedef struct Media_VideoTypeProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_DrawingProperties *drawing;
  Media_AudioProperties *audio;
  Media_TransportProperties *transport;
  Media_VideoProperties *video;
} Media_VideoTypeProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "drawing",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_DrawingProperties),
        .number = Media_VideoTypeProperties_FieldNumber_Drawing,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_VideoTypeProperties__storage_, drawing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioProperties),
        .number = Media_VideoTypeProperties_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_VideoTypeProperties__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transport",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_TransportProperties),
        .number = Media_VideoTypeProperties_FieldNumber_Transport,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_VideoTypeProperties__storage_, transport),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_VideoProperties),
        .number = Media_VideoTypeProperties_FieldNumber_Video,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Media_VideoTypeProperties__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_VideoTypeProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_VideoTypeProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_LiveVideoTypeProperties

@implementation Media_LiveVideoTypeProperties

@dynamic hasDrawing, drawing;
@dynamic hasAudio, audio;
@dynamic hasLiveVideo, liveVideo;

typedef struct Media_LiveVideoTypeProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_DrawingProperties *drawing;
  Media_AudioProperties *audio;
  Media_LiveVideoProperties *liveVideo;
} Media_LiveVideoTypeProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "drawing",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_DrawingProperties),
        .number = Media_LiveVideoTypeProperties_FieldNumber_Drawing,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_LiveVideoTypeProperties__storage_, drawing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_AudioProperties),
        .number = Media_LiveVideoTypeProperties_FieldNumber_Audio,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_LiveVideoTypeProperties__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_LiveVideoProperties),
        .number = Media_LiveVideoTypeProperties_FieldNumber_LiveVideo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Media_LiveVideoTypeProperties__storage_, liveVideo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_LiveVideoTypeProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_LiveVideoTypeProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Media_WebContentTypeProperties

@implementation Media_WebContentTypeProperties

@dynamic hasDrawing, drawing;
@dynamic hasURL, URL;

typedef struct Media_WebContentTypeProperties__storage_ {
  uint32_t _has_storage_[1];
  Media_DrawingProperties *drawing;
  URL *URL;
} Media_WebContentTypeProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "drawing",
        .dataTypeSpecific.clazz = GPBObjCClass(Media_DrawingProperties),
        .number = Media_WebContentTypeProperties_FieldNumber_Drawing,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Media_WebContentTypeProperties__storage_, drawing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Media_WebContentTypeProperties_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Media_WebContentTypeProperties__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Media_WebContentTypeProperties class]
                                     rootClass:[GraphicsDataRoot class]
                                          file:GraphicsDataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Media_WebContentTypeProperties__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Media)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
