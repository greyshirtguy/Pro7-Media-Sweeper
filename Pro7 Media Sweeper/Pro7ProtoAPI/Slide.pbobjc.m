// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: slide.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Slide.pbobjc.h"
#import "GraphicsData.pbobjc.h"
#import "BasicTypes.pbobjc.h"
#import "AlignmentGuide.pbobjc.h"
#import "Effects.pbobjc.h"
#import "Timers.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AlignmentGuide);
GPBObjCClassDeclaration(Clock_Format);
GPBObjCClassDeclaration(Color);
GPBObjCClassDeclaration(Graphics_Element);
GPBObjCClassDeclaration(Graphics_Size);
GPBObjCClassDeclaration(Slide);
GPBObjCClassDeclaration(Slide_Element);
GPBObjCClassDeclaration(Slide_Element_Build);
GPBObjCClassDeclaration(Slide_Element_ChildBuild);
GPBObjCClassDeclaration(Slide_Element_DataLink);
GPBObjCClassDeclaration(Slide_Element_DataLink_AlternateElementFill);
GPBObjCClassDeclaration(Slide_Element_DataLink_AlternateElementText);
GPBObjCClassDeclaration(Slide_Element_DataLink_AudioCountdown);
GPBObjCClassDeclaration(Slide_Element_DataLink_AutoAdvanceTimeRemaining);
GPBObjCClassDeclaration(Slide_Element_DataLink_CCLIText);
GPBObjCClassDeclaration(Slide_Element_DataLink_CaptureStatusColor);
GPBObjCClassDeclaration(Slide_Element_DataLink_CaptureStatusText);
GPBObjCClassDeclaration(Slide_Element_DataLink_CaptureStatusText_ElapsedTime);
GPBObjCClassDeclaration(Slide_Element_DataLink_CaptureStatusText_StatusText);
GPBObjCClassDeclaration(Slide_Element_DataLink_ChordChart);
GPBObjCClassDeclaration(Slide_Element_DataLink_ClockText);
GPBObjCClassDeclaration(Slide_Element_DataLink_ColorTrigger);
GPBObjCClassDeclaration(Slide_Element_DataLink_FileFeed);
GPBObjCClassDeclaration(Slide_Element_DataLink_GroupColor);
GPBObjCClassDeclaration(Slide_Element_DataLink_GroupName);
GPBObjCClassDeclaration(Slide_Element_DataLink_OutputScreen);
GPBObjCClassDeclaration(Slide_Element_DataLink_PCOLive);
GPBObjCClassDeclaration(Slide_Element_DataLink_PlaylistItem);
GPBObjCClassDeclaration(Slide_Element_DataLink_Presentation);
GPBObjCClassDeclaration(Slide_Element_DataLink_PresentationNotes);
GPBObjCClassDeclaration(Slide_Element_DataLink_RSSFeed);
GPBObjCClassDeclaration(Slide_Element_DataLink_SlideCount);
GPBObjCClassDeclaration(Slide_Element_DataLink_SlideImage);
GPBObjCClassDeclaration(Slide_Element_DataLink_SlideLabelColor);
GPBObjCClassDeclaration(Slide_Element_DataLink_SlideLabelText);
GPBObjCClassDeclaration(Slide_Element_DataLink_SlideText);
GPBObjCClassDeclaration(Slide_Element_DataLink_StageMessage);
GPBObjCClassDeclaration(Slide_Element_DataLink_Ticker);
GPBObjCClassDeclaration(Slide_Element_DataLink_Ticker_FileType);
GPBObjCClassDeclaration(Slide_Element_DataLink_Ticker_RSSType);
GPBObjCClassDeclaration(Slide_Element_DataLink_Ticker_TextType);
GPBObjCClassDeclaration(Slide_Element_DataLink_TimerText);
GPBObjCClassDeclaration(Slide_Element_DataLink_VideoCountdown);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility);
GPBObjCClassDeclaration(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility);
GPBObjCClassDeclaration(Slide_Element_TextScroller);
GPBObjCClassDeclaration(Timer_Format);
GPBObjCClassDeclaration(Transition);
GPBObjCClassDeclaration(URL);
GPBObjCClassDeclaration(UUID);

#pragma mark - SlideRoot

@implementation SlideRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - SlideRoot_FileDescriptor

static GPBFileDescriptor *SlideRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"rv.data"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Slide

@implementation Slide

@dynamic elementsArray, elementsArray_Count;
@dynamic elementBuildOrderArray, elementBuildOrderArray_Count;
@dynamic guidelinesArray, guidelinesArray_Count;
@dynamic drawsBackgroundColor;
@dynamic hasBackgroundColor, backgroundColor;
@dynamic hasSize, size;
@dynamic hasUuid, uuid;

typedef struct Slide__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *elementsArray;
  NSMutableArray *elementBuildOrderArray;
  NSMutableArray *guidelinesArray;
  Color *backgroundColor;
  Graphics_Size *size;
  UUID *uuid;
} Slide__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "elementsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element),
        .number = Slide_FieldNumber_ElementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide__storage_, elementsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "elementBuildOrderArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_FieldNumber_ElementBuildOrderArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide__storage_, elementBuildOrderArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "guidelinesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(AlignmentGuide),
        .number = Slide_FieldNumber_GuidelinesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide__storage_, guidelinesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "drawsBackgroundColor",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_FieldNumber_DrawsBackgroundColor,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "backgroundColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Slide_FieldNumber_BackgroundColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide__storage_, backgroundColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Size),
        .number = Slide_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_FieldNumber_Uuid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element

@implementation Slide_Element

@dynamic hasElement, element;
@dynamic hasBuildIn, buildIn;
@dynamic hasBuildOut, buildOut;
@dynamic info;
@dynamic revealType;
@dynamic dataLinksArray, dataLinksArray_Count;
@dynamic childBuildsArray, childBuildsArray_Count;
@dynamic revealFromIndex;
@dynamic hasTextScroller, textScroller;

typedef struct Slide_Element__storage_ {
  uint32_t _has_storage_[1];
  uint32_t info;
  Slide_Element_TextRevealType revealType;
  uint32_t revealFromIndex;
  Graphics_Element *element;
  Slide_Element_Build *buildIn;
  Slide_Element_Build *buildOut;
  NSMutableArray *dataLinksArray;
  NSMutableArray *childBuildsArray;
  Slide_Element_TextScroller *textScroller;
} Slide_Element__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "element",
        .dataTypeSpecific.clazz = GPBObjCClass(Graphics_Element),
        .number = Slide_Element_FieldNumber_Element,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, element),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buildIn",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_Build),
        .number = Slide_Element_FieldNumber_BuildIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, buildIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buildOut",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_Build),
        .number = Slide_Element_FieldNumber_BuildOut,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, buildOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_FieldNumber_Info,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "revealType",
        .dataTypeSpecific.enumDescFunc = Slide_Element_TextRevealType_EnumDescriptor,
        .number = Slide_Element_FieldNumber_RevealType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, revealType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dataLinksArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink),
        .number = Slide_Element_FieldNumber_DataLinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, dataLinksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "childBuildsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_ChildBuild),
        .number = Slide_Element_FieldNumber_ChildBuildsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, childBuildsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revealFromIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_FieldNumber_RevealFromIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, revealFromIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "textScroller",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_TextScroller),
        .number = Slide_Element_FieldNumber_TextScroller,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Slide_Element__storage_, textScroller),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\000childBuilds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_RevealType_RawValue(Slide_Element *message) {
  GPBDescriptor *descriptor = [Slide_Element descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_FieldNumber_RevealType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_RevealType_RawValue(Slide_Element *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_FieldNumber_RevealType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_TextRevealType

GPBEnumDescriptor *Slide_Element_TextRevealType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextRevealTypeNone\000TextRevealTypeBullet\000"
        "TextRevealTypeUnderline\000";
    static const int32_t values[] = {
        Slide_Element_TextRevealType_TextRevealTypeNone,
        Slide_Element_TextRevealType_TextRevealTypeBullet,
        Slide_Element_TextRevealType_TextRevealTypeUnderline,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_TextRevealType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_TextRevealType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_TextRevealType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_TextRevealType_TextRevealTypeNone:
    case Slide_Element_TextRevealType_TextRevealTypeBullet:
    case Slide_Element_TextRevealType_TextRevealTypeUnderline:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_Build

@implementation Slide_Element_Build

@dynamic hasUuid, uuid;
@dynamic hasElementUuid, elementUuid;
@dynamic start;
@dynamic delayTime;
@dynamic hasTransition, transition;

typedef struct Slide_Element_Build__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_Build_Start start;
  UUID *uuid;
  UUID *elementUuid;
  Transition *transition;
  double delayTime;
} Slide_Element_Build__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_Build_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_Build__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "elementUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_Build_FieldNumber_ElementUuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_Build__storage_, elementUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "start",
        .dataTypeSpecific.enumDescFunc = Slide_Element_Build_Start_EnumDescriptor,
        .number = Slide_Element_Build_FieldNumber_Start,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_Build__storage_, start),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "delayTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_Build_FieldNumber_DelayTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element_Build__storage_, delayTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "transition",
        .dataTypeSpecific.clazz = GPBObjCClass(Transition),
        .number = Slide_Element_Build_FieldNumber_Transition,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide_Element_Build__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_Build class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_Build__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\010c\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_Build_Start_RawValue(Slide_Element_Build *message) {
  GPBDescriptor *descriptor = [Slide_Element_Build descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_Build_FieldNumber_Start];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_Build_Start_RawValue(Slide_Element_Build *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_Build descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_Build_FieldNumber_Start];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_Build_Start

GPBEnumDescriptor *Slide_Element_Build_Start_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StartOnClick\000StartWithPrevious\000StartAfte"
        "rPrevious\000StartWithSlide\000";
    static const int32_t values[] = {
        Slide_Element_Build_Start_StartOnClick,
        Slide_Element_Build_Start_StartWithPrevious,
        Slide_Element_Build_Start_StartAfterPrevious,
        Slide_Element_Build_Start_StartWithSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_Build_Start)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_Build_Start_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_Build_Start_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_Build_Start_StartOnClick:
    case Slide_Element_Build_Start_StartWithPrevious:
    case Slide_Element_Build_Start_StartAfterPrevious:
    case Slide_Element_Build_Start_StartWithSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_ChildBuild

@implementation Slide_Element_ChildBuild

@dynamic hasUuid, uuid;
@dynamic start;
@dynamic delayTime;
@dynamic index;

typedef struct Slide_Element_ChildBuild__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_ChildBuild_Start start;
  uint32_t index;
  UUID *uuid;
  double delayTime;
} Slide_Element_ChildBuild__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_ChildBuild_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_ChildBuild__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "start",
        .dataTypeSpecific.enumDescFunc = Slide_Element_ChildBuild_Start_EnumDescriptor,
        .number = Slide_Element_ChildBuild_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_ChildBuild__storage_, start),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "delayTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_ChildBuild_FieldNumber_DelayTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_ChildBuild__storage_, delayTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_ChildBuild_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element_ChildBuild__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_ChildBuild class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_ChildBuild__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_ChildBuild_Start_RawValue(Slide_Element_ChildBuild *message) {
  GPBDescriptor *descriptor = [Slide_Element_ChildBuild descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_ChildBuild_FieldNumber_Start];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_ChildBuild_Start_RawValue(Slide_Element_ChildBuild *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_ChildBuild descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_ChildBuild_FieldNumber_Start];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_ChildBuild_Start

GPBEnumDescriptor *Slide_Element_ChildBuild_Start_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StartOnClick\000StartWithPrevious\000StartAfte"
        "rPrevious\000StartWithSlide\000";
    static const int32_t values[] = {
        Slide_Element_ChildBuild_Start_StartOnClick,
        Slide_Element_ChildBuild_Start_StartWithPrevious,
        Slide_Element_ChildBuild_Start_StartAfterPrevious,
        Slide_Element_ChildBuild_Start_StartWithSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_ChildBuild_Start)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_ChildBuild_Start_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_ChildBuild_Start_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_ChildBuild_Start_StartOnClick:
    case Slide_Element_ChildBuild_Start_StartWithPrevious:
    case Slide_Element_ChildBuild_Start_StartAfterPrevious:
    case Slide_Element_ChildBuild_Start_StartWithSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink

@implementation Slide_Element_DataLink

@dynamic propertyTypeOneOfCase;
@dynamic ticker;
@dynamic alternateText;
@dynamic timerText;
@dynamic clockText;
@dynamic chordChart;
@dynamic outputScreen;
@dynamic pcoLive;
@dynamic alternateFill;
@dynamic visibilityLink;
@dynamic slideText;
@dynamic stageMessage;
@dynamic videoCountdown;
@dynamic slideImage;
@dynamic ccliText;
@dynamic groupName;
@dynamic groupColor;
@dynamic presentationNotes;
@dynamic playlistItem;
@dynamic autoAdvanceTimeRemaining;
@dynamic captureStatusText;
@dynamic captureStatusColor;
@dynamic slideCount;
@dynamic audioCountdown;
@dynamic presentation;
@dynamic slideLabelText;
@dynamic slideLabelColor;
@dynamic rssFeed;
@dynamic fileFeed;

typedef struct Slide_Element_DataLink__storage_ {
  uint32_t _has_storage_[2];
  Slide_Element_DataLink_Ticker *ticker;
  Slide_Element_DataLink_AlternateElementText *alternateText;
  Slide_Element_DataLink_TimerText *timerText;
  Slide_Element_DataLink_ClockText *clockText;
  Slide_Element_DataLink_ChordChart *chordChart;
  Slide_Element_DataLink_OutputScreen *outputScreen;
  Slide_Element_DataLink_PCOLive *pcoLive;
  Slide_Element_DataLink_AlternateElementFill *alternateFill;
  Slide_Element_DataLink_VisibilityLink *visibilityLink;
  Slide_Element_DataLink_SlideText *slideText;
  Slide_Element_DataLink_StageMessage *stageMessage;
  Slide_Element_DataLink_VideoCountdown *videoCountdown;
  Slide_Element_DataLink_SlideImage *slideImage;
  Slide_Element_DataLink_CCLIText *ccliText;
  Slide_Element_DataLink_GroupName *groupName;
  Slide_Element_DataLink_GroupColor *groupColor;
  Slide_Element_DataLink_PresentationNotes *presentationNotes;
  Slide_Element_DataLink_PlaylistItem *playlistItem;
  Slide_Element_DataLink_AutoAdvanceTimeRemaining *autoAdvanceTimeRemaining;
  Slide_Element_DataLink_CaptureStatusText *captureStatusText;
  Slide_Element_DataLink_CaptureStatusColor *captureStatusColor;
  Slide_Element_DataLink_SlideCount *slideCount;
  Slide_Element_DataLink_AudioCountdown *audioCountdown;
  Slide_Element_DataLink_Presentation *presentation;
  Slide_Element_DataLink_SlideLabelText *slideLabelText;
  Slide_Element_DataLink_SlideLabelColor *slideLabelColor;
  Slide_Element_DataLink_RSSFeed *rssFeed;
  Slide_Element_DataLink_FileFeed *fileFeed;
} Slide_Element_DataLink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ticker",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_Ticker),
        .number = Slide_Element_DataLink_FieldNumber_Ticker,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, ticker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alternateText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_AlternateElementText),
        .number = Slide_Element_DataLink_FieldNumber_AlternateText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, alternateText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_TimerText),
        .number = Slide_Element_DataLink_FieldNumber_TimerText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, timerText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clockText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_ClockText),
        .number = Slide_Element_DataLink_FieldNumber_ClockText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, clockText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chordChart",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_ChordChart),
        .number = Slide_Element_DataLink_FieldNumber_ChordChart,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, chordChart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputScreen",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_OutputScreen),
        .number = Slide_Element_DataLink_FieldNumber_OutputScreen,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, outputScreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pcoLive",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_PCOLive),
        .number = Slide_Element_DataLink_FieldNumber_PcoLive,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, pcoLive),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alternateFill",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_AlternateElementFill),
        .number = Slide_Element_DataLink_FieldNumber_AlternateFill,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, alternateFill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "visibilityLink",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink),
        .number = Slide_Element_DataLink_FieldNumber_VisibilityLink,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, visibilityLink),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_SlideText),
        .number = Slide_Element_DataLink_FieldNumber_SlideText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, slideText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stageMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_StageMessage),
        .number = Slide_Element_DataLink_FieldNumber_StageMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, stageMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoCountdown",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VideoCountdown),
        .number = Slide_Element_DataLink_FieldNumber_VideoCountdown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, videoCountdown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideImage",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_SlideImage),
        .number = Slide_Element_DataLink_FieldNumber_SlideImage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, slideImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ccliText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_CCLIText),
        .number = Slide_Element_DataLink_FieldNumber_CcliText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, ccliText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_GroupName),
        .number = Slide_Element_DataLink_FieldNumber_GroupName,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_GroupColor),
        .number = Slide_Element_DataLink_FieldNumber_GroupColor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, groupColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "presentationNotes",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_PresentationNotes),
        .number = Slide_Element_DataLink_FieldNumber_PresentationNotes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, presentationNotes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playlistItem",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_PlaylistItem),
        .number = Slide_Element_DataLink_FieldNumber_PlaylistItem,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, playlistItem),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAdvanceTimeRemaining",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_AutoAdvanceTimeRemaining),
        .number = Slide_Element_DataLink_FieldNumber_AutoAdvanceTimeRemaining,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, autoAdvanceTimeRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureStatusText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_CaptureStatusText),
        .number = Slide_Element_DataLink_FieldNumber_CaptureStatusText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, captureStatusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureStatusColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_CaptureStatusColor),
        .number = Slide_Element_DataLink_FieldNumber_CaptureStatusColor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, captureStatusColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideCount",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_SlideCount),
        .number = Slide_Element_DataLink_FieldNumber_SlideCount,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, slideCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioCountdown",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_AudioCountdown),
        .number = Slide_Element_DataLink_FieldNumber_AudioCountdown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, audioCountdown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "presentation",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_Presentation),
        .number = Slide_Element_DataLink_FieldNumber_Presentation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, presentation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideLabelText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_SlideLabelText),
        .number = Slide_Element_DataLink_FieldNumber_SlideLabelText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, slideLabelText),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slideLabelColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_SlideLabelColor),
        .number = Slide_Element_DataLink_FieldNumber_SlideLabelColor,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, slideLabelColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rssFeed",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_RSSFeed),
        .number = Slide_Element_DataLink_FieldNumber_RssFeed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, rssFeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fileFeed",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_FileFeed),
        .number = Slide_Element_DataLink_FieldNumber_FileFeed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink__storage_, fileFeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "propertyType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\031\005\205\204\000\032\005\205\205\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Slide_Element_DataLink_ClearPropertyTypeOneOfCase(Slide_Element_DataLink *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Slide_Element_DataLink_RSSFeed

@implementation Slide_Element_DataLink_RSSFeed

@dynamic hasURL, URL;
@dynamic content;
@dynamic textDelimiter;

typedef struct Slide_Element_DataLink_RSSFeed__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_RSSFeed_ContentType content;
  URL *URL;
  NSString *textDelimiter;
} Slide_Element_DataLink_RSSFeed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Slide_Element_DataLink_RSSFeed_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_RSSFeed__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_RSSFeed_ContentType_EnumDescriptor,
        .number = Slide_Element_DataLink_RSSFeed_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_RSSFeed__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "textDelimiter",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_RSSFeed_FieldNumber_TextDelimiter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_RSSFeed__storage_, textDelimiter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_RSSFeed class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_RSSFeed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_RSSFeed_Content_RawValue(Slide_Element_DataLink_RSSFeed *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_RSSFeed descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_RSSFeed_FieldNumber_Content];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_RSSFeed_Content_RawValue(Slide_Element_DataLink_RSSFeed *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_RSSFeed descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_RSSFeed_FieldNumber_Content];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_RSSFeed_ContentType

GPBEnumDescriptor *Slide_Element_DataLink_RSSFeed_ContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentTypeTitleOnly\000ContentTypeTitleAnd"
        "Description\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_RSSFeed_ContentType_ContentTypeTitleOnly,
        Slide_Element_DataLink_RSSFeed_ContentType_ContentTypeTitleAndDescription,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_RSSFeed_ContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_RSSFeed_ContentType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_RSSFeed_ContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_RSSFeed_ContentType_ContentTypeTitleOnly:
    case Slide_Element_DataLink_RSSFeed_ContentType_ContentTypeTitleAndDescription:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_FileFeed

@implementation Slide_Element_DataLink_FileFeed

@dynamic hasURL, URL;

typedef struct Slide_Element_DataLink_FileFeed__storage_ {
  uint32_t _has_storage_[1];
  URL *URL;
} Slide_Element_DataLink_FileFeed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Slide_Element_DataLink_FileFeed_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_FileFeed__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_FileFeed class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_FileFeed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_Ticker

@implementation Slide_Element_DataLink_Ticker

@dynamic sourceTypeOneOfCase;
@dynamic playRate;
@dynamic shouldLoop;
@dynamic loopDelay;
@dynamic textDelimiter;
@dynamic textType;
@dynamic rssType;
@dynamic fileType;

typedef struct Slide_Element_DataLink_Ticker__storage_ {
  uint32_t _has_storage_[2];
  Slide_Element_DataLink_Ticker_TextType *textType;
  Slide_Element_DataLink_Ticker_RSSType *rssType;
  Slide_Element_DataLink_Ticker_FileType *fileType;
  NSString *textDelimiter;
  double playRate;
  double loopDelay;
} Slide_Element_DataLink_Ticker__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "textType",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_Ticker_TextType),
        .number = Slide_Element_DataLink_Ticker_FieldNumber_TextType,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, textType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rssType",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_Ticker_RSSType),
        .number = Slide_Element_DataLink_Ticker_FieldNumber_RssType,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, rssType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fileType",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_Ticker_FileType),
        .number = Slide_Element_DataLink_Ticker_FieldNumber_FileType,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, fileType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_Ticker_FieldNumber_PlayRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, playRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "shouldLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_Ticker_FieldNumber_ShouldLoop,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "loopDelay",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_Ticker_FieldNumber_LoopDelay,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, loopDelay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "textDelimiter",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_Ticker_FieldNumber_TextDelimiter,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker__storage_, textDelimiter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_Ticker class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_Ticker__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "sourceType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Slide_Element_DataLink_Ticker_ClearSourceTypeOneOfCase(Slide_Element_DataLink_Ticker *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_Ticker descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Slide_Element_DataLink_Ticker_TextType

@implementation Slide_Element_DataLink_Ticker_TextType

@dynamic text;

typedef struct Slide_Element_DataLink_Ticker_TextType__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} Slide_Element_DataLink_Ticker_TextType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_Ticker_TextType_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker_TextType__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_Ticker_TextType class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_Ticker_TextType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_Ticker)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_Ticker_RSSType

@implementation Slide_Element_DataLink_Ticker_RSSType

@dynamic hasURL, URL;
@dynamic content;

typedef struct Slide_Element_DataLink_Ticker_RSSType__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_Ticker_RSSType_ContentType content;
  URL *URL;
} Slide_Element_DataLink_Ticker_RSSType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Slide_Element_DataLink_Ticker_RSSType_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker_RSSType__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_Ticker_RSSType_ContentType_EnumDescriptor,
        .number = Slide_Element_DataLink_Ticker_RSSType_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker_RSSType__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_Ticker_RSSType class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_Ticker_RSSType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_Ticker)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_Ticker_RSSType_Content_RawValue(Slide_Element_DataLink_Ticker_RSSType *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_Ticker_RSSType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_Ticker_RSSType_FieldNumber_Content];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_Ticker_RSSType_Content_RawValue(Slide_Element_DataLink_Ticker_RSSType *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_Ticker_RSSType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_Ticker_RSSType_FieldNumber_Content];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_Ticker_RSSType_ContentType

GPBEnumDescriptor *Slide_Element_DataLink_Ticker_RSSType_ContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentTypeTitleOnly\000ContentTypeTitleAnd"
        "Description\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_Ticker_RSSType_ContentType_ContentTypeTitleOnly,
        Slide_Element_DataLink_Ticker_RSSType_ContentType_ContentTypeTitleAndDescription,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_Ticker_RSSType_ContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_Ticker_RSSType_ContentType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_Ticker_RSSType_ContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_Ticker_RSSType_ContentType_ContentTypeTitleOnly:
    case Slide_Element_DataLink_Ticker_RSSType_ContentType_ContentTypeTitleAndDescription:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_Ticker_FileType

@implementation Slide_Element_DataLink_Ticker_FileType

@dynamic hasURL, URL;

typedef struct Slide_Element_DataLink_Ticker_FileType__storage_ {
  uint32_t _has_storage_[1];
  URL *URL;
} Slide_Element_DataLink_Ticker_FileType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = GPBObjCClass(URL),
        .number = Slide_Element_DataLink_Ticker_FileType_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Ticker_FileType__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_Ticker_FileType class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_Ticker_FileType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_Ticker)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_AlternateElementText

@implementation Slide_Element_DataLink_AlternateElementText

@dynamic hasOtherElementUuid, otherElementUuid;
@dynamic otherElementName;
@dynamic textTransformOptions;
@dynamic textTransform;

typedef struct Slide_Element_DataLink_AlternateElementText__storage_ {
  uint32_t _has_storage_[1];
  uint32_t textTransformOptions;
  Slide_Element_DataLink_AlternateElementText_TextTransformOption textTransform;
  UUID *otherElementUuid;
  NSString *otherElementName;
} Slide_Element_DataLink_AlternateElementText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "otherElementUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_AlternateElementText_FieldNumber_OtherElementUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementText__storage_, otherElementUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "otherElementName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_AlternateElementText_FieldNumber_OtherElementName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementText__storage_, otherElementName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "textTransformOptions",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_AlternateElementText_FieldNumber_TextTransformOptions,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementText__storage_, textTransformOptions),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "textTransform",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_AlternateElementText_TextTransformOption_EnumDescriptor,
        .number = Slide_Element_DataLink_AlternateElementText_FieldNumber_TextTransform,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementText__storage_, textTransform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_AlternateElementText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_AlternateElementText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_AlternateElementText_TextTransform_RawValue(Slide_Element_DataLink_AlternateElementText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_AlternateElementText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_AlternateElementText_FieldNumber_TextTransform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_AlternateElementText_TextTransform_RawValue(Slide_Element_DataLink_AlternateElementText *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_AlternateElementText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_AlternateElementText_FieldNumber_TextTransform];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_AlternateElementText_TextTransformOption

GPBEnumDescriptor *Slide_Element_DataLink_AlternateElementText_TextTransformOption_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextTransformOptionNone\000TextTransformOpt"
        "ionRemoveLineReturns\000TextTransformOption"
        "OneWordPerLine\000TextTransformOptionOneCha"
        "racterPerLine\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionNone,
        Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionRemoveLineReturns,
        Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionOneWordPerLine,
        Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionOneCharacterPerLine,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_AlternateElementText_TextTransformOption)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_AlternateElementText_TextTransformOption_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_AlternateElementText_TextTransformOption_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionNone:
    case Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionRemoveLineReturns:
    case Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionOneWordPerLine:
    case Slide_Element_DataLink_AlternateElementText_TextTransformOption_TextTransformOptionOneCharacterPerLine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_CCLIText

@implementation Slide_Element_DataLink_CCLIText


typedef struct Slide_Element_DataLink_CCLIText__storage_ {
  uint32_t _has_storage_[1];
} Slide_Element_DataLink_CCLIText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_CCLIText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Slide_Element_DataLink_CCLIText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_ColorTrigger

@implementation Slide_Element_DataLink_ColorTrigger

@dynamic time;
@dynamic hasColor, color;

typedef struct Slide_Element_DataLink_ColorTrigger__storage_ {
  uint32_t _has_storage_[1];
  Color *color;
  double time;
} Slide_Element_DataLink_ColorTrigger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_ColorTrigger_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_ColorTrigger__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "color",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Slide_Element_DataLink_ColorTrigger_FieldNumber_Color,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_ColorTrigger__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_ColorTrigger class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_ColorTrigger__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_TimerText

@implementation Slide_Element_DataLink_TimerText

@dynamic hasTimerUuid, timerUuid;
@dynamic timerName;
@dynamic hasTimerFormat, timerFormat;
@dynamic timerFormatString;
@dynamic colorTriggersArray, colorTriggersArray_Count;

typedef struct Slide_Element_DataLink_TimerText__storage_ {
  uint32_t _has_storage_[1];
  UUID *timerUuid;
  NSString *timerName;
  Timer_Format *timerFormat;
  NSString *timerFormatString;
  NSMutableArray *colorTriggersArray;
} Slide_Element_DataLink_TimerText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timerUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_TimerText_FieldNumber_TimerUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_TimerText__storage_, timerUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_TimerText_FieldNumber_TimerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_TimerText__storage_, timerName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timerFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Format),
        .number = Slide_Element_DataLink_TimerText_FieldNumber_TimerFormat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_TimerText__storage_, timerFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerFormatString",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_TimerText_FieldNumber_TimerFormatString,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_TimerText__storage_, timerFormatString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "colorTriggersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_ColorTrigger),
        .number = Slide_Element_DataLink_TimerText_FieldNumber_ColorTriggersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_TimerText__storage_, colorTriggersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_TimerText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_TimerText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_ClockText

@implementation Slide_Element_DataLink_ClockText

@dynamic clockFormatString;
@dynamic hasFormat, format;

typedef struct Slide_Element_DataLink_ClockText__storage_ {
  uint32_t _has_storage_[1];
  NSString *clockFormatString;
  Clock_Format *format;
} Slide_Element_DataLink_ClockText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clockFormatString",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_ClockText_FieldNumber_ClockFormatString,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_ClockText__storage_, clockFormatString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = GPBObjCClass(Clock_Format),
        .number = Slide_Element_DataLink_ClockText_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_ClockText__storage_, format),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_ClockText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_ClockText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_ChordChart

@implementation Slide_Element_DataLink_ChordChart


typedef struct Slide_Element_DataLink_ChordChart__storage_ {
  uint32_t _has_storage_[1];
} Slide_Element_DataLink_ChordChart__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_ChordChart class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Slide_Element_DataLink_ChordChart__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_OutputScreen

@implementation Slide_Element_DataLink_OutputScreen

@dynamic hasScreenId, screenId;
@dynamic screenName;

typedef struct Slide_Element_DataLink_OutputScreen__storage_ {
  uint32_t _has_storage_[1];
  UUID *screenId;
  NSString *screenName;
} Slide_Element_DataLink_OutputScreen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "screenId",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_OutputScreen_FieldNumber_ScreenId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_OutputScreen__storage_, screenId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_OutputScreen_FieldNumber_ScreenName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_OutputScreen__storage_, screenName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_OutputScreen class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_OutputScreen__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_PCOLive

@implementation Slide_Element_DataLink_PCOLive

@dynamic theme;
@dynamic countdownType;

typedef struct Slide_Element_DataLink_PCOLive__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_PCOLive_Theme theme;
  Slide_Element_DataLink_PCOLive_CountdownType countdownType;
} Slide_Element_DataLink_PCOLive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "theme",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_PCOLive_Theme_EnumDescriptor,
        .number = Slide_Element_DataLink_PCOLive_FieldNumber_Theme,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_PCOLive__storage_, theme),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "countdownType",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_PCOLive_CountdownType_EnumDescriptor,
        .number = Slide_Element_DataLink_PCOLive_FieldNumber_CountdownType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_PCOLive__storage_, countdownType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_PCOLive class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_PCOLive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_PCOLive_Theme_RawValue(Slide_Element_DataLink_PCOLive *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PCOLive descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PCOLive_FieldNumber_Theme];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_PCOLive_Theme_RawValue(Slide_Element_DataLink_PCOLive *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PCOLive descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PCOLive_FieldNumber_Theme];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Slide_Element_DataLink_PCOLive_CountdownType_RawValue(Slide_Element_DataLink_PCOLive *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PCOLive descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PCOLive_FieldNumber_CountdownType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_PCOLive_CountdownType_RawValue(Slide_Element_DataLink_PCOLive *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PCOLive descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PCOLive_FieldNumber_CountdownType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_PCOLive_Theme

GPBEnumDescriptor *Slide_Element_DataLink_PCOLive_Theme_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PcoliveThemeLight\000PcoliveThemeDark\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_PCOLive_Theme_PcoliveThemeLight,
        Slide_Element_DataLink_PCOLive_Theme_PcoliveThemeDark,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_PCOLive_Theme)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_PCOLive_Theme_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_PCOLive_Theme_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_PCOLive_Theme_PcoliveThemeLight:
    case Slide_Element_DataLink_PCOLive_Theme_PcoliveThemeDark:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Slide_Element_DataLink_PCOLive_CountdownType

GPBEnumDescriptor *Slide_Element_DataLink_PCOLive_CountdownType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CountdownTypeFullItemLength\000CountdownTyp"
        "eEndItemOnTime\000CountdownTypeEndServiceOn"
        "Time\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeFullItemLength,
        Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeEndItemOnTime,
        Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeEndServiceOnTime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_PCOLive_CountdownType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_PCOLive_CountdownType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_PCOLive_CountdownType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeFullItemLength:
    case Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeEndItemOnTime:
    case Slide_Element_DataLink_PCOLive_CountdownType_CountdownTypeEndServiceOnTime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_AlternateElementFill

@implementation Slide_Element_DataLink_AlternateElementFill

@dynamic hasOtherElementUuid, otherElementUuid;
@dynamic otherElementName;

typedef struct Slide_Element_DataLink_AlternateElementFill__storage_ {
  uint32_t _has_storage_[1];
  UUID *otherElementUuid;
  NSString *otherElementName;
} Slide_Element_DataLink_AlternateElementFill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "otherElementUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_AlternateElementFill_FieldNumber_OtherElementUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementFill__storage_, otherElementUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "otherElementName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_AlternateElementFill_FieldNumber_OtherElementName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AlternateElementFill__storage_, otherElementName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_AlternateElementFill class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_AlternateElementFill__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_VisibilityLink

@implementation Slide_Element_DataLink_VisibilityLink

@dynamic visibilityCriterion;
@dynamic conditionsArray, conditionsArray_Count;

typedef struct Slide_Element_DataLink_VisibilityLink__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_VisibilityCriterion visibilityCriterion;
  NSMutableArray *conditionsArray;
} Slide_Element_DataLink_VisibilityLink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_FieldNumber_VisibilityCriterion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "conditionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition),
        .number = Slide_Element_DataLink_VisibilityLink_FieldNumber_ConditionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink__storage_, conditionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_VisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VisibilityCriterionAll\000VisibilityCriteri"
        "onAny\000VisibilityCriterionNone\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionAll,
        Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionAny,
        Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionNone,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_VisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionAll:
    case Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionAny:
    case Slide_Element_DataLink_VisibilityLink_VisibilityCriterion_VisibilityCriterionNone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition

@implementation Slide_Element_DataLink_VisibilityLink_Condition

@dynamic conditionTypeOneOfCase;
@dynamic elementVisibility;
@dynamic timerVisibility;
@dynamic videoCountdownVisibility;
@dynamic captureSessionVisibility;
@dynamic videoInputVisibility;
@dynamic audioCountdownVisibility;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition__storage_ {
  uint32_t _has_storage_[2];
  Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility *elementVisibility;
  Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility *timerVisibility;
  Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility *videoCountdownVisibility;
  Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility *captureSessionVisibility;
  Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility *videoInputVisibility;
  Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility *audioCountdownVisibility;
} Slide_Element_DataLink_VisibilityLink_Condition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "elementVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_ElementVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, elementVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_TimerVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, timerVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoCountdownVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_VideoCountdownVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, videoCountdownVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "captureSessionVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_CaptureSessionVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, captureSessionVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoInputVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_VideoInputVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, videoInputVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioCountdownVisibility",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_FieldNumber_AudioCountdownVisibility,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition__storage_, audioCountdownVisibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "conditionType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Slide_Element_DataLink_VisibilityLink_Condition_ClearConditionTypeOneOfCase(Slide_Element_DataLink_VisibilityLink_Condition *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility

@dynamic hasOtherElementUuid, otherElementUuid;
@dynamic otherElementName;
@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion visibilityCriterion;
  UUID *otherElementUuid;
  NSString *otherElementName;
} Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "otherElementUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_FieldNumber_OtherElementUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_, otherElementUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "otherElementName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_FieldNumber_OtherElementName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_, otherElementName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ElementVisibilityCriterionHasText\000Elemen"
        "tVisibilityCriterionHasNoText\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_ElementVisibilityCriterionHasText,
        Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_ElementVisibilityCriterionHasNoText,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_ElementVisibilityCriterionHasText:
    case Slide_Element_DataLink_VisibilityLink_Condition_ElementVisibility_ElementVisibilityCriterion_ElementVisibilityCriterionHasNoText:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility

@dynamic hasTimerUuid, timerUuid;
@dynamic timerName;
@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion visibilityCriterion;
  UUID *timerUuid;
  NSString *timerName;
} Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timerUuid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUID),
        .number = Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_FieldNumber_TimerUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_, timerUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerName",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_FieldNumber_TimerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_, timerName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TimerVisibilityCriterionHasTimeRemaining"
        "\000TimerVisibilityCriterionHasExpired\000Time"
        "rVisibilityCriterionIsRunning\000TimerVisib"
        "ilityCriterionNotRunning\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionHasTimeRemaining,
        Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionHasExpired,
        Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionIsRunning,
        Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionNotRunning,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionHasTimeRemaining:
    case Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionHasExpired:
    case Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionIsRunning:
    case Slide_Element_DataLink_VisibilityLink_Condition_TimerVisibility_TimerVisibilityCriterion_TimerVisibilityCriterionNotRunning:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility

@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion visibilityCriterion;
} Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VideoCountdownVisibilityCriterionHasTime"
        "Remaining\000VideoCountdownVisibilityCriter"
        "ionHasExpired\000VideoCountdownVisibilityCr"
        "iterionIsRunning\000VideoCountdownVisibilit"
        "yCriterionNotRunning\000VideoCountdownVisib"
        "ilityCriterionLooping\000VideoCountdownVisi"
        "bilityCriterionNotLooping\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionHasTimeRemaining,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionHasExpired,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionIsRunning,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionNotRunning,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionLooping,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionNotLooping,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionHasTimeRemaining:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionHasExpired:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionIsRunning:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionNotRunning:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionLooping:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoCountdownVisibility_VideoCountdownVisibilityCriterion_VideoCountdownVisibilityCriterionNotLooping:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility

@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion visibilityCriterion;
} Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AudioCountdownVisibilityCriterionHasTime"
        "Remaining\000AudioCountdownVisibilityCriter"
        "ionHasExpired\000AudioCountdownVisibilityCr"
        "iterionIsRunning\000AudioCountdownVisibilit"
        "yCriterionNotRunning\000AudioCountdownVisib"
        "ilityCriterionLooping\000AudioCountdownVisi"
        "bilityCriterionNotLooping\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionHasTimeRemaining,
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionHasExpired,
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionIsRunning,
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionNotRunning,
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionLooping,
        Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionNotLooping,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionHasTimeRemaining:
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionHasExpired:
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionIsRunning:
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionNotRunning:
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionLooping:
    case Slide_Element_DataLink_VisibilityLink_Condition_AudioCountdownVisibility_AudioCountdownVisibilityCriterion_AudioCountdownVisibilityCriterionNotLooping:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility

@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion visibilityCriterion;
} Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CaptureSessionVisibilityCriterionActive\000"
        "CaptureSessionVisibilityCriterionInactiv"
        "e\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_CaptureSessionVisibilityCriterionActive,
        Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_CaptureSessionVisibilityCriterionInactive,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_CaptureSessionVisibilityCriterionActive:
    case Slide_Element_DataLink_VisibilityLink_Condition_CaptureSessionVisibility_CaptureSessionVisibilityCriterion_CaptureSessionVisibilityCriterionInactive:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility

@implementation Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility

@dynamic videoInputIndex;
@dynamic visibilityCriterion;

typedef struct Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility__storage_ {
  uint32_t _has_storage_[1];
  int32_t videoInputIndex;
  Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion visibilityCriterion;
} Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoInputIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_FieldNumber_VideoInputIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility__storage_, videoInputIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "visibilityCriterion",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_EnumDescriptor,
        .number = Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_FieldNumber_VisibilityCriterion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility__storage_, visibilityCriterion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_VisibilityLink_Condition)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_FieldNumber_VisibilityCriterion];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VisibilityCriterion_RawValue(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_FieldNumber_VisibilityCriterion];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion

GPBEnumDescriptor *Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VideoInputVisibilityCriterionActive\000Vide"
        "oInputVisibilityCriterionInactive\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_VideoInputVisibilityCriterionActive,
        Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_VideoInputVisibilityCriterionInactive,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_VideoInputVisibilityCriterionActive:
    case Slide_Element_DataLink_VisibilityLink_Condition_VideoInputVisibility_VideoInputVisibilityCriterion_VideoInputVisibilityCriterionInactive:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_SlideText

@implementation Slide_Element_DataLink_SlideText

@dynamic sourceSlide;
@dynamic sourceOption;
@dynamic preserveNotesFormat;
@dynamic nameToMatch;
@dynamic elementTextTransform;

typedef struct Slide_Element_DataLink_SlideText__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_SlideText_SlideSourceType sourceSlide;
  Slide_Element_DataLink_SlideText_TextSourceOption sourceOption;
  Slide_Element_DataLink_SlideText_TextTransformOption elementTextTransform;
  NSString *nameToMatch;
} Slide_Element_DataLink_SlideText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceSlide",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideText_SlideSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideText_FieldNumber_SourceSlide,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideText__storage_, sourceSlide),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sourceOption",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideText_TextSourceOption_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideText_FieldNumber_SourceOption,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideText__storage_, sourceOption),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "preserveNotesFormat",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_SlideText_FieldNumber_PreserveNotesFormat,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "nameToMatch",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_SlideText_FieldNumber_NameToMatch,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideText__storage_, nameToMatch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "elementTextTransform",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideText_TextTransformOption_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideText_FieldNumber_ElementTextTransform,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideText__storage_, elementTextTransform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_SlideText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_SlideText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_SlideText_SourceSlide_RawValue(Slide_Element_DataLink_SlideText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_SourceSlide];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideText_SourceSlide_RawValue(Slide_Element_DataLink_SlideText *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_SourceSlide];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Slide_Element_DataLink_SlideText_SourceOption_RawValue(Slide_Element_DataLink_SlideText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_SourceOption];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideText_SourceOption_RawValue(Slide_Element_DataLink_SlideText *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_SourceOption];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Slide_Element_DataLink_SlideText_ElementTextTransform_RawValue(Slide_Element_DataLink_SlideText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_ElementTextTransform];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideText_ElementTextTransform_RawValue(Slide_Element_DataLink_SlideText *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideText_FieldNumber_ElementTextTransform];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_SlideText_SlideSourceType

GPBEnumDescriptor *Slide_Element_DataLink_SlideText_SlideSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideSourceTypeCurrentSlide\000SlideSourceT"
        "ypeNextSlide\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideText_SlideSourceType_SlideSourceTypeCurrentSlide,
        Slide_Element_DataLink_SlideText_SlideSourceType_SlideSourceTypeNextSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideText_SlideSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideText_SlideSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideText_SlideSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideText_SlideSourceType_SlideSourceTypeCurrentSlide:
    case Slide_Element_DataLink_SlideText_SlideSourceType_SlideSourceTypeNextSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Slide_Element_DataLink_SlideText_TextSourceOption

GPBEnumDescriptor *Slide_Element_DataLink_SlideText_TextSourceOption_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextSourceOptionText\000TextSourceOptionNot"
        "es\000TextSourceOptionElementMatchingName\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionText,
        Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionNotes,
        Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionElementMatchingName,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideText_TextSourceOption)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideText_TextSourceOption_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideText_TextSourceOption_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionText:
    case Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionNotes:
    case Slide_Element_DataLink_SlideText_TextSourceOption_TextSourceOptionElementMatchingName:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Slide_Element_DataLink_SlideText_TextTransformOption

GPBEnumDescriptor *Slide_Element_DataLink_SlideText_TextTransformOption_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextTransformOptionNone\000TextTransformOpt"
        "ionRemoveLineReturns\000TextTransformOption"
        "OneWordPerLine\000TextTransformOptionOneCha"
        "racterPerLine\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionNone,
        Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionRemoveLineReturns,
        Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionOneWordPerLine,
        Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionOneCharacterPerLine,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideText_TextTransformOption)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideText_TextTransformOption_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideText_TextTransformOption_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionNone:
    case Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionRemoveLineReturns:
    case Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionOneWordPerLine:
    case Slide_Element_DataLink_SlideText_TextTransformOption_TextTransformOptionOneCharacterPerLine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_SlideImage

@implementation Slide_Element_DataLink_SlideImage

@dynamic sourceSlide;

typedef struct Slide_Element_DataLink_SlideImage__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_SlideImage_SlideSourceType sourceSlide;
} Slide_Element_DataLink_SlideImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceSlide",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideImage_SlideSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideImage_FieldNumber_SourceSlide,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideImage__storage_, sourceSlide),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_SlideImage class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_SlideImage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_SlideImage_SourceSlide_RawValue(Slide_Element_DataLink_SlideImage *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideImage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideImage_FieldNumber_SourceSlide];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideImage_SourceSlide_RawValue(Slide_Element_DataLink_SlideImage *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideImage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideImage_FieldNumber_SourceSlide];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_SlideImage_SlideSourceType

GPBEnumDescriptor *Slide_Element_DataLink_SlideImage_SlideSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideSourceTypeCurrentSlide\000SlideSourceT"
        "ypeNextSlide\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideImage_SlideSourceType_SlideSourceTypeCurrentSlide,
        Slide_Element_DataLink_SlideImage_SlideSourceType_SlideSourceTypeNextSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideImage_SlideSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideImage_SlideSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideImage_SlideSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideImage_SlideSourceType_SlideSourceTypeCurrentSlide:
    case Slide_Element_DataLink_SlideImage_SlideSourceType_SlideSourceTypeNextSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_StageMessage

@implementation Slide_Element_DataLink_StageMessage

@dynamic shouldFlash;
@dynamic hasFlashColor, flashColor;

typedef struct Slide_Element_DataLink_StageMessage__storage_ {
  uint32_t _has_storage_[1];
  Color *flashColor;
} Slide_Element_DataLink_StageMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shouldFlash",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_StageMessage_FieldNumber_ShouldFlash,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flashColor",
        .dataTypeSpecific.clazz = GPBObjCClass(Color),
        .number = Slide_Element_DataLink_StageMessage_FieldNumber_FlashColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_StageMessage__storage_, flashColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_StageMessage class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_StageMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_VideoCountdown

@implementation Slide_Element_DataLink_VideoCountdown

@dynamic hasTimerFormat, timerFormat;
@dynamic timerFormatString;
@dynamic colorTriggersArray, colorTriggersArray_Count;
@dynamic ignoreLoopingVideos;
@dynamic videoCountdownSource;

typedef struct Slide_Element_DataLink_VideoCountdown__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_VideoCountdown_VideoCountdownSource videoCountdownSource;
  Timer_Format *timerFormat;
  NSString *timerFormatString;
  NSMutableArray *colorTriggersArray;
} Slide_Element_DataLink_VideoCountdown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timerFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Format),
        .number = Slide_Element_DataLink_VideoCountdown_FieldNumber_TimerFormat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VideoCountdown__storage_, timerFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerFormatString",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_VideoCountdown_FieldNumber_TimerFormatString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VideoCountdown__storage_, timerFormatString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "colorTriggersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_ColorTrigger),
        .number = Slide_Element_DataLink_VideoCountdown_FieldNumber_ColorTriggersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VideoCountdown__storage_, colorTriggersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ignoreLoopingVideos",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_VideoCountdown_FieldNumber_IgnoreLoopingVideos,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "videoCountdownSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_EnumDescriptor,
        .number = Slide_Element_DataLink_VideoCountdown_FieldNumber_VideoCountdownSource,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_VideoCountdown__storage_, videoCountdownSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_VideoCountdown class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_VideoCountdown__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_RawValue(Slide_Element_DataLink_VideoCountdown *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VideoCountdown descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VideoCountdown_FieldNumber_VideoCountdownSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_VideoCountdown_VideoCountdownSource_RawValue(Slide_Element_DataLink_VideoCountdown *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_VideoCountdown descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_VideoCountdown_FieldNumber_VideoCountdownSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_VideoCountdown_VideoCountdownSource

GPBEnumDescriptor *Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VideoCountdownSourcePresentation\000VideoCo"
        "untdownSourceAnnouncement\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_VideoCountdownSourcePresentation,
        Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_VideoCountdownSourceAnnouncement,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_VideoCountdown_VideoCountdownSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_VideoCountdownSourcePresentation:
    case Slide_Element_DataLink_VideoCountdown_VideoCountdownSource_VideoCountdownSourceAnnouncement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_AudioCountdown

@implementation Slide_Element_DataLink_AudioCountdown

@dynamic hasTimerFormat, timerFormat;
@dynamic timerFormatString;
@dynamic colorTriggersArray, colorTriggersArray_Count;
@dynamic ignoreLoopingAudio;

typedef struct Slide_Element_DataLink_AudioCountdown__storage_ {
  uint32_t _has_storage_[1];
  Timer_Format *timerFormat;
  NSString *timerFormatString;
  NSMutableArray *colorTriggersArray;
} Slide_Element_DataLink_AudioCountdown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timerFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Format),
        .number = Slide_Element_DataLink_AudioCountdown_FieldNumber_TimerFormat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AudioCountdown__storage_, timerFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timerFormatString",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_AudioCountdown_FieldNumber_TimerFormatString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AudioCountdown__storage_, timerFormatString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "colorTriggersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_ColorTrigger),
        .number = Slide_Element_DataLink_AudioCountdown_FieldNumber_ColorTriggersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AudioCountdown__storage_, colorTriggersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ignoreLoopingAudio",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_AudioCountdown_FieldNumber_IgnoreLoopingAudio,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_AudioCountdown class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_AudioCountdown__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_GroupName

@implementation Slide_Element_DataLink_GroupName

@dynamic groupSource;

typedef struct Slide_Element_DataLink_GroupName__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_GroupName_GroupSourceType groupSource;
} Slide_Element_DataLink_GroupName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_GroupName_GroupSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_GroupName_FieldNumber_GroupSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_GroupName__storage_, groupSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_GroupName class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_GroupName__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_GroupName_GroupSource_RawValue(Slide_Element_DataLink_GroupName *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_GroupName descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_GroupName_FieldNumber_GroupSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_GroupName_GroupSource_RawValue(Slide_Element_DataLink_GroupName *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_GroupName descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_GroupName_FieldNumber_GroupSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_GroupName_GroupSourceType

GPBEnumDescriptor *Slide_Element_DataLink_GroupName_GroupSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GroupSourceTypeCurrentSlide\000GroupSourceT"
        "ypeNextSlide\000GroupSourceTypeNextGroup\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeCurrentSlide,
        Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeNextSlide,
        Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeNextGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_GroupName_GroupSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_GroupName_GroupSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_GroupName_GroupSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeCurrentSlide:
    case Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeNextSlide:
    case Slide_Element_DataLink_GroupName_GroupSourceType_GroupSourceTypeNextGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_GroupColor

@implementation Slide_Element_DataLink_GroupColor

@dynamic groupSource;

typedef struct Slide_Element_DataLink_GroupColor__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_GroupColor_GroupSourceType groupSource;
} Slide_Element_DataLink_GroupColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_GroupColor_GroupSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_GroupColor_FieldNumber_GroupSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_GroupColor__storage_, groupSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_GroupColor class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_GroupColor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_GroupColor_GroupSource_RawValue(Slide_Element_DataLink_GroupColor *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_GroupColor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_GroupColor_FieldNumber_GroupSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_GroupColor_GroupSource_RawValue(Slide_Element_DataLink_GroupColor *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_GroupColor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_GroupColor_FieldNumber_GroupSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_GroupColor_GroupSourceType

GPBEnumDescriptor *Slide_Element_DataLink_GroupColor_GroupSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "GroupSourceTypeCurrentSlide\000GroupSourceT"
        "ypeNextSlide\000GroupSourceTypeNextGroup\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeCurrentSlide,
        Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeNextSlide,
        Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeNextGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_GroupColor_GroupSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_GroupColor_GroupSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_GroupColor_GroupSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeCurrentSlide:
    case Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeNextSlide:
    case Slide_Element_DataLink_GroupColor_GroupSourceType_GroupSourceTypeNextGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_SlideLabelText

@implementation Slide_Element_DataLink_SlideLabelText

@dynamic slideLabelSource;

typedef struct Slide_Element_DataLink_SlideLabelText__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_SlideLabelText_SlideLabelSource slideLabelSource;
} Slide_Element_DataLink_SlideLabelText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slideLabelSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideLabelText_SlideLabelSource_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideLabelText_FieldNumber_SlideLabelSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideLabelText__storage_, slideLabelSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_SlideLabelText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_SlideLabelText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_SlideLabelText_SlideLabelSource_RawValue(Slide_Element_DataLink_SlideLabelText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideLabelText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideLabelText_FieldNumber_SlideLabelSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideLabelText_SlideLabelSource_RawValue(Slide_Element_DataLink_SlideLabelText *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideLabelText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideLabelText_FieldNumber_SlideLabelSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_SlideLabelText_SlideLabelSource

GPBEnumDescriptor *Slide_Element_DataLink_SlideLabelText_SlideLabelSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideLabelSourceCurrentSlide\000SlideLabelS"
        "ourceNextSlide\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideLabelText_SlideLabelSource_SlideLabelSourceCurrentSlide,
        Slide_Element_DataLink_SlideLabelText_SlideLabelSource_SlideLabelSourceNextSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideLabelText_SlideLabelSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideLabelText_SlideLabelSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideLabelText_SlideLabelSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideLabelText_SlideLabelSource_SlideLabelSourceCurrentSlide:
    case Slide_Element_DataLink_SlideLabelText_SlideLabelSource_SlideLabelSourceNextSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_SlideLabelColor

@implementation Slide_Element_DataLink_SlideLabelColor

@dynamic slideLabelSource;

typedef struct Slide_Element_DataLink_SlideLabelColor__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_SlideLabelColor_SlideLabelSource slideLabelSource;
} Slide_Element_DataLink_SlideLabelColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slideLabelSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideLabelColor_FieldNumber_SlideLabelSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideLabelColor__storage_, slideLabelSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_SlideLabelColor class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_SlideLabelColor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_RawValue(Slide_Element_DataLink_SlideLabelColor *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideLabelColor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideLabelColor_FieldNumber_SlideLabelSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideLabelColor_SlideLabelSource_RawValue(Slide_Element_DataLink_SlideLabelColor *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideLabelColor descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideLabelColor_FieldNumber_SlideLabelSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_SlideLabelColor_SlideLabelSource

GPBEnumDescriptor *Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideLabelSourceCurrentSlide\000SlideLabelS"
        "ourceNextSlide\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_SlideLabelSourceCurrentSlide,
        Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_SlideLabelSourceNextSlide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideLabelColor_SlideLabelSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_SlideLabelSourceCurrentSlide:
    case Slide_Element_DataLink_SlideLabelColor_SlideLabelSource_SlideLabelSourceNextSlide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_PresentationNotes

@implementation Slide_Element_DataLink_PresentationNotes


typedef struct Slide_Element_DataLink_PresentationNotes__storage_ {
  uint32_t _has_storage_[1];
} Slide_Element_DataLink_PresentationNotes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_PresentationNotes class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Slide_Element_DataLink_PresentationNotes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_Presentation

@implementation Slide_Element_DataLink_Presentation

@dynamic presentationSource;

typedef struct Slide_Element_DataLink_Presentation__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_Presentation_PresentationSource presentationSource;
} Slide_Element_DataLink_Presentation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "presentationSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_Presentation_PresentationSource_EnumDescriptor,
        .number = Slide_Element_DataLink_Presentation_FieldNumber_PresentationSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_Presentation__storage_, presentationSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_Presentation class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_Presentation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_Presentation_PresentationSource_RawValue(Slide_Element_DataLink_Presentation *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_Presentation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_Presentation_FieldNumber_PresentationSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_Presentation_PresentationSource_RawValue(Slide_Element_DataLink_Presentation *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_Presentation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_Presentation_FieldNumber_PresentationSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_Presentation_PresentationSource

GPBEnumDescriptor *Slide_Element_DataLink_Presentation_PresentationSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PresentationSourcePresentation\000Presentat"
        "ionSourceAnnouncement\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_Presentation_PresentationSource_PresentationSourcePresentation,
        Slide_Element_DataLink_Presentation_PresentationSource_PresentationSourceAnnouncement,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_Presentation_PresentationSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_Presentation_PresentationSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_Presentation_PresentationSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_Presentation_PresentationSource_PresentationSourcePresentation:
    case Slide_Element_DataLink_Presentation_PresentationSource_PresentationSourceAnnouncement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_PlaylistItem

@implementation Slide_Element_DataLink_PlaylistItem

@dynamic playlistItemSource;
@dynamic showArrangement;

typedef struct Slide_Element_DataLink_PlaylistItem__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType playlistItemSource;
} Slide_Element_DataLink_PlaylistItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playlistItemSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_PlaylistItem_FieldNumber_PlaylistItemSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_PlaylistItem__storage_, playlistItemSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "showArrangement",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_DataLink_PlaylistItem_FieldNumber_ShowArrangement,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_PlaylistItem class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_PlaylistItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\022\000\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_PlaylistItem_PlaylistItemSource_RawValue(Slide_Element_DataLink_PlaylistItem *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PlaylistItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PlaylistItem_FieldNumber_PlaylistItemSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_PlaylistItem_PlaylistItemSource_RawValue(Slide_Element_DataLink_PlaylistItem *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_PlaylistItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_PlaylistItem_FieldNumber_PlaylistItemSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType

GPBEnumDescriptor *Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaylistItemSourceTypeCurrent\000PlaylistIt"
        "emSourceTypeNext\000PlaylistItemSourceTypeC"
        "urrentHeader\000PlaylistItemSourceTypeNextH"
        "eader\000PlaylistItemSourceTypeParentPlayli"
        "st\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeCurrent,
        Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeNext,
        Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeCurrentHeader,
        Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeNextHeader,
        Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeParentPlaylist,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeCurrent:
    case Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeNext:
    case Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeCurrentHeader:
    case Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeNextHeader:
    case Slide_Element_DataLink_PlaylistItem_PlaylistItemSourceType_PlaylistItemSourceTypeParentPlaylist:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_AutoAdvanceTimeRemaining

@implementation Slide_Element_DataLink_AutoAdvanceTimeRemaining

@dynamic autoAdvanceSource;
@dynamic hasTimerFormat, timerFormat;

typedef struct Slide_Element_DataLink_AutoAdvanceTimeRemaining__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource autoAdvanceSource;
  Timer_Format *timerFormat;
} Slide_Element_DataLink_AutoAdvanceTimeRemaining__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "autoAdvanceSource",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_EnumDescriptor,
        .number = Slide_Element_DataLink_AutoAdvanceTimeRemaining_FieldNumber_AutoAdvanceSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AutoAdvanceTimeRemaining__storage_, autoAdvanceSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timerFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Format),
        .number = Slide_Element_DataLink_AutoAdvanceTimeRemaining_FieldNumber_TimerFormat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_AutoAdvanceTimeRemaining__storage_, timerFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_AutoAdvanceTimeRemaining class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_AutoAdvanceTimeRemaining__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_RawValue(Slide_Element_DataLink_AutoAdvanceTimeRemaining *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_AutoAdvanceTimeRemaining descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_AutoAdvanceTimeRemaining_FieldNumber_AutoAdvanceSource];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_RawValue(Slide_Element_DataLink_AutoAdvanceTimeRemaining *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_AutoAdvanceTimeRemaining descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_AutoAdvanceTimeRemaining_FieldNumber_AutoAdvanceSource];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource

GPBEnumDescriptor *Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AutoAdvanceSourcePresentation\000AutoAdvanc"
        "eSourceAnnouncement\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_AutoAdvanceSourcePresentation,
        Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_AutoAdvanceSourceAnnouncement,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_AutoAdvanceSourcePresentation:
    case Slide_Element_DataLink_AutoAdvanceTimeRemaining_AutoAdvanceSource_AutoAdvanceSourceAnnouncement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_DataLink_CaptureStatusText

@implementation Slide_Element_DataLink_CaptureStatusText

@dynamic textTypeOneOfCase;
@dynamic statusText;
@dynamic elapsedTime;

typedef struct Slide_Element_DataLink_CaptureStatusText__storage_ {
  uint32_t _has_storage_[2];
  Slide_Element_DataLink_CaptureStatusText_StatusText *statusText;
  Slide_Element_DataLink_CaptureStatusText_ElapsedTime *elapsedTime;
} Slide_Element_DataLink_CaptureStatusText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusText",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_CaptureStatusText_StatusText),
        .number = Slide_Element_DataLink_CaptureStatusText_FieldNumber_StatusText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_CaptureStatusText__storage_, statusText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "elapsedTime",
        .dataTypeSpecific.clazz = GPBObjCClass(Slide_Element_DataLink_CaptureStatusText_ElapsedTime),
        .number = Slide_Element_DataLink_CaptureStatusText_FieldNumber_ElapsedTime,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_CaptureStatusText__storage_, elapsedTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_CaptureStatusText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_CaptureStatusText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "textType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Slide_Element_DataLink_CaptureStatusText_ClearTextTypeOneOfCase(Slide_Element_DataLink_CaptureStatusText *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_CaptureStatusText descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Slide_Element_DataLink_CaptureStatusText_StatusText

@implementation Slide_Element_DataLink_CaptureStatusText_StatusText


typedef struct Slide_Element_DataLink_CaptureStatusText_StatusText__storage_ {
  uint32_t _has_storage_[1];
} Slide_Element_DataLink_CaptureStatusText_StatusText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_CaptureStatusText_StatusText class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Slide_Element_DataLink_CaptureStatusText_StatusText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_CaptureStatusText)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_CaptureStatusText_ElapsedTime

@implementation Slide_Element_DataLink_CaptureStatusText_ElapsedTime

@dynamic hasTimerFormat, timerFormat;

typedef struct Slide_Element_DataLink_CaptureStatusText_ElapsedTime__storage_ {
  uint32_t _has_storage_[1];
  Timer_Format *timerFormat;
} Slide_Element_DataLink_CaptureStatusText_ElapsedTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timerFormat",
        .dataTypeSpecific.clazz = GPBObjCClass(Timer_Format),
        .number = Slide_Element_DataLink_CaptureStatusText_ElapsedTime_FieldNumber_TimerFormat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_CaptureStatusText_ElapsedTime__storage_, timerFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_CaptureStatusText_ElapsedTime class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_CaptureStatusText_ElapsedTime__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink_CaptureStatusText)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_CaptureStatusColor

@implementation Slide_Element_DataLink_CaptureStatusColor


typedef struct Slide_Element_DataLink_CaptureStatusColor__storage_ {
  uint32_t _has_storage_[1];
} Slide_Element_DataLink_CaptureStatusColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_CaptureStatusColor class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Slide_Element_DataLink_CaptureStatusColor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Slide_Element_DataLink_SlideCount

@implementation Slide_Element_DataLink_SlideCount

@dynamic slideCountSourceType;

typedef struct Slide_Element_DataLink_SlideCount__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_DataLink_SlideCount_SlideCountSourceType slideCountSourceType;
} Slide_Element_DataLink_SlideCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slideCountSourceType",
        .dataTypeSpecific.enumDescFunc = Slide_Element_DataLink_SlideCount_SlideCountSourceType_EnumDescriptor,
        .number = Slide_Element_DataLink_SlideCount_FieldNumber_SlideCountSourceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Slide_Element_DataLink_SlideCount__storage_, slideCountSourceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_DataLink_SlideCount class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_DataLink_SlideCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\024\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element_DataLink)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_DataLink_SlideCount_SlideCountSourceType_RawValue(Slide_Element_DataLink_SlideCount *message) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideCount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideCount_FieldNumber_SlideCountSourceType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_DataLink_SlideCount_SlideCountSourceType_RawValue(Slide_Element_DataLink_SlideCount *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_DataLink_SlideCount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_DataLink_SlideCount_FieldNumber_SlideCountSourceType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_DataLink_SlideCount_SlideCountSourceType

GPBEnumDescriptor *Slide_Element_DataLink_SlideCount_SlideCountSourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SlideCountSourceTypeCurrent\000SlideCountSo"
        "urceTypeRemaining\000SlideCountSourceTypeTo"
        "tal\000";
    static const int32_t values[] = {
        Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeCurrent,
        Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeRemaining,
        Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeTotal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_DataLink_SlideCount_SlideCountSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_DataLink_SlideCount_SlideCountSourceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_DataLink_SlideCount_SlideCountSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeCurrent:
    case Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeRemaining:
    case Slide_Element_DataLink_SlideCount_SlideCountSourceType_SlideCountSourceTypeTotal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Slide_Element_TextScroller

@implementation Slide_Element_TextScroller

@dynamic shouldScroll;
@dynamic scrollRate;
@dynamic shouldRepeat;
@dynamic repeatDistance;
@dynamic scrollingDirection;
@dynamic startsOffScreen;
@dynamic fadeLeft;
@dynamic fadeRight;

typedef struct Slide_Element_TextScroller__storage_ {
  uint32_t _has_storage_[1];
  Slide_Element_TextScroller_Direction scrollingDirection;
  double scrollRate;
  double repeatDistance;
  double fadeLeft;
  double fadeRight;
} Slide_Element_TextScroller__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shouldScroll",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_ShouldScroll,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "scrollRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_ScrollRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Slide_Element_TextScroller__storage_, scrollRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "shouldRepeat",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_ShouldRepeat,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "repeatDistance",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_RepeatDistance,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Slide_Element_TextScroller__storage_, repeatDistance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "scrollingDirection",
        .dataTypeSpecific.enumDescFunc = Slide_Element_TextScroller_Direction_EnumDescriptor,
        .number = Slide_Element_TextScroller_FieldNumber_ScrollingDirection,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Slide_Element_TextScroller__storage_, scrollingDirection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startsOffScreen",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_StartsOffScreen,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fadeLeft",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_FadeLeft,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Slide_Element_TextScroller__storage_, fadeLeft),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fadeRight",
        .dataTypeSpecific.clazz = Nil,
        .number = Slide_Element_TextScroller_FieldNumber_FadeRight,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Slide_Element_TextScroller__storage_, fadeRight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Slide_Element_TextScroller class]
                                     rootClass:[SlideRoot class]
                                          file:SlideRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Slide_Element_TextScroller__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Slide_Element)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Slide_Element_TextScroller_ScrollingDirection_RawValue(Slide_Element_TextScroller *message) {
  GPBDescriptor *descriptor = [Slide_Element_TextScroller descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_TextScroller_FieldNumber_ScrollingDirection];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSlide_Element_TextScroller_ScrollingDirection_RawValue(Slide_Element_TextScroller *message, int32_t value) {
  GPBDescriptor *descriptor = [Slide_Element_TextScroller descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Slide_Element_TextScroller_FieldNumber_ScrollingDirection];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum Slide_Element_TextScroller_Direction

GPBEnumDescriptor *Slide_Element_TextScroller_Direction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DirectionLeft\000DirectionRight\000DirectionUp"
        "\000DirectionDown\000";
    static const int32_t values[] = {
        Slide_Element_TextScroller_Direction_DirectionLeft,
        Slide_Element_TextScroller_Direction_DirectionRight,
        Slide_Element_TextScroller_Direction_DirectionUp,
        Slide_Element_TextScroller_Direction_DirectionDown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Slide_Element_TextScroller_Direction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Slide_Element_TextScroller_Direction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Slide_Element_TextScroller_Direction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Slide_Element_TextScroller_Direction_DirectionLeft:
    case Slide_Element_TextScroller_Direction_DirectionRight:
    case Slide_Element_TextScroller_Direction_DirectionUp:
    case Slide_Element_TextScroller_Direction_DirectionDown:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
